
boschSpeedUp.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002e70  10001000  10001000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000010  10003e70  10003e70  00003e70  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .rodata       000000d8  10003e80  10003e80  00003e80  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .VENEER_Code  00000110  2000000c  10003f60  0000800c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .GUARD_Band   00000004  2000011c  00000000  0000011c  2**0
                  ALLOC
  5 Stack         00000800  20000120  00000000  00000120  2**0
                  ALLOC
  6 .bss          000001b8  20000920  20000920  00010920  2**2
                  ALLOC
  7 .data         00000008  20000ae0  10004070  00008ae0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .debug_aranges 00000398  00000000  00000000  00008ae8  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000041c7  00000000  00000000  00008e80  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00000c2b  00000000  00000000  0000d047  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00004fad  00000000  00000000  0000dc72  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000b80  00000000  00000000  00012c20  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00025fc1  00000000  00000000  000137a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00000ed4  00000000  00000000  00039761  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000002d0  00000000  00000000  0003a638  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .build_attributes 0000048f  00000000  00000000  0003a908  2**0
                  CONTENTS, READONLY
 17 .debug_macro  00007cc0  00000000  00000000  0003ad97  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

10001000 <__Xmc1100_interrupt_vector_cortex_m>:
10001000:	20 09 00 20 19 10 00 10 d5 10 00 10 d7 10 00 10      .. ............
10001010:	00 04 00 00 00 00 00 00                             ........

10001018 <__Xmc1100_reset_cortex_m>:
__Xmc1100_reset_cortex_m:
    .fnstart

    /* C routines are likely to be called. Setup the stack now */
    /* This is already setup by BootROM,hence this step is optional */ 
    LDR R0,=__Xmc1100_stack
10001018:	4802      	ldr	r0, [pc, #8]	; (10001024 <__Xmc1100_reset_cortex_m+0xc>)
    MOV SP,R0
1000101a:	4685      	mov	sp, r0
    
    /* Launch custom pre-program loading startup procedure */
    LDR R0,=hardware_init_hook
1000101c:	4802      	ldr	r0, [pc, #8]	; (10001028 <__Xmc1100_reset_cortex_m+0x10>)
    BLX R0
1000101e:	4780      	blx	r0

    /* Branch to the program loader now */
    B       __Xmc1100_Program_Loader 
10001020:	e012      	b.n	10001048 <__Xmc1100_Program_Loader>
10001022:	0000      	.short	0x0000
__Xmc1100_reset_cortex_m:
    .fnstart

    /* C routines are likely to be called. Setup the stack now */
    /* This is already setup by BootROM,hence this step is optional */ 
    LDR R0,=__Xmc1100_stack
10001024:	20000920 	.word	0x20000920
    MOV SP,R0
    
    /* Launch custom pre-program loading startup procedure */
    LDR R0,=hardware_init_hook
10001028:	100010d1 	.word	0x100010d1

1000102c <__COPY_FLASH2RAM>:
   to C land is given */
   .section .Xmc1100.postreset,"x",%progbits
 __COPY_FLASH2RAM:
   .fnstart:
   /* Is there anything to be copied? */
   CMP R2,#0
1000102c:	2a00      	cmp	r2, #0
   BEQ SKIPCOPY
1000102e:	d00a      	beq.n	10001046 <SKIPCOPY>
   
   /* For bytecount less than 4, at least 1 word must be copied */
   CMP R2,#4
10001030:	2a04      	cmp	r2, #4
   BCS STARTCOPY
10001032:	d200      	bcs.n	10001036 <STARTCOPY>
   
   /* Byte count < 4 ; so bump it up */
   MOVS R2,#4
10001034:	2204      	movs	r2, #4

10001036 <STARTCOPY>:
STARTCOPY:
   /* 
      R2 contains byte count. Change it to word count. It is ensured in the 
      linker script that the length is always word aligned.
   */
   LSRS R2,R2,#2 /* Divide by 4 to obtain word count */
10001036:	0892      	lsrs	r2, r2, #2

10001038 <COPYLOOP>:

   /* The proverbial loop from the schooldays */
COPYLOOP:
   LDR R3,[R0]
10001038:	6803      	ldr	r3, [r0, #0]
   STR R3,[R1]
1000103a:	600b      	str	r3, [r1, #0]
   SUBS R2,#1
1000103c:	3a01      	subs	r2, #1
   BEQ SKIPCOPY
1000103e:	d002      	beq.n	10001046 <SKIPCOPY>
   ADDS R0,#4
10001040:	3004      	adds	r0, #4
   ADDS R1,#4
10001042:	3104      	adds	r1, #4
   B COPYLOOP
10001044:	e7f8      	b.n	10001038 <COPYLOOP>

10001046 <SKIPCOPY>:
    
SKIPCOPY:
   BX LR
10001046:	4770      	bx	lr

10001048 <__Xmc1100_Program_Loader>:
   .fnstart
   /* Memories are accessible now*/
   
   /* DATA COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =DataLoadAddr
10001048:	4811      	ldr	r0, [pc, #68]	; (10001090 <SKIPCLEAR+0x14>)
   LDR R1, =__Xmc1100_sData
1000104a:	4912      	ldr	r1, [pc, #72]	; (10001094 <SKIPCLEAR+0x18>)
   LDR R2, =__Xmc1100_Data_Size
1000104c:	4a12      	ldr	r2, [pc, #72]	; (10001098 <SKIPCLEAR+0x1c>)
   BL __COPY_FLASH2RAM
1000104e:	f7ff ffed 	bl	1000102c <__COPY_FLASH2RAM>

   /* RAM_CODE COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =__ram_code_load
10001052:	4812      	ldr	r0, [pc, #72]	; (1000109c <SKIPCLEAR+0x20>)
   LDR R1, =__ram_code_start
10001054:	4912      	ldr	r1, [pc, #72]	; (100010a0 <SKIPCLEAR+0x24>)
   LDR R2, =__ram_code_size
10001056:	4a13      	ldr	r2, [pc, #76]	; (100010a4 <SKIPCLEAR+0x28>)
   BL __COPY_FLASH2RAM
10001058:	f7ff ffe8 	bl	1000102c <__COPY_FLASH2RAM>

   /* VENEER COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =VeneerLoadAddr
1000105c:	4812      	ldr	r0, [pc, #72]	; (100010a8 <SKIPCLEAR+0x2c>)
   LDR R1, =VeneerStart
1000105e:	4913      	ldr	r1, [pc, #76]	; (100010ac <SKIPCLEAR+0x30>)
   LDR R2, =VeneerSize
10001060:	4a13      	ldr	r2, [pc, #76]	; (100010b0 <SKIPCLEAR+0x34>)
   BL __COPY_FLASH2RAM
10001062:	f7ff ffe3 	bl	1000102c <__COPY_FLASH2RAM>

   /* BSS CLEAR */
   LDR R0, =__Xmc1100_sBSS     /* Start of BSS */
10001066:	4813      	ldr	r0, [pc, #76]	; (100010b4 <SKIPCLEAR+0x38>)
   LDR R1, =__Xmc1100_BSS_Size /* BSS size in bytes */
10001068:	4913      	ldr	r1, [pc, #76]	; (100010b8 <SKIPCLEAR+0x3c>)

   /* Find out if there are items assigned to BSS */   
   CMP R1,#0 
1000106a:	2900      	cmp	r1, #0
   BEQ SKIPCLEAR
1000106c:	d006      	beq.n	1000107c <SKIPCLEAR>

1000106e <STARTCLEAR>:

STARTCLEAR:
   LSRS R1,R1,#2            /* BSS size in words */
1000106e:	0889      	lsrs	r1, r1, #2
   
   MOVS R2,#0
10001070:	2200      	movs	r2, #0

10001072 <CLEARLOOP>:
CLEARLOOP:
   STR R2,[R0]
10001072:	6002      	str	r2, [r0, #0]
   SUBS R1,#1
10001074:	3901      	subs	r1, #1
   BEQ SKIPCLEAR
10001076:	d001      	beq.n	1000107c <SKIPCLEAR>
   ADDS R0,#4
10001078:	3004      	adds	r0, #4
   B CLEARLOOP
1000107a:	e7fa      	b.n	10001072 <CLEARLOOP>

1000107c <SKIPCLEAR>:
    
SKIPCLEAR:

   /* Reset stack pointer before zipping off to user application, Optional */
   LDR R0,=__Xmc1100_stack 
1000107c:	480f      	ldr	r0, [pc, #60]	; (100010bc <SKIPCLEAR+0x40>)
   MOV SP,R0
1000107e:	4685      	mov	sp, r0

   /* Perform System Initialization */   
   LDR R0,=SystemInit
10001080:	480f      	ldr	r0, [pc, #60]	; (100010c0 <SKIPCLEAR+0x44>)
   BLX R0
10001082:	4780      	blx	r0

   /* Launch custom post-program loading startup procedure */
   LDR R0,=software_init_hook
10001084:	480f      	ldr	r0, [pc, #60]	; (100010c4 <SKIPCLEAR+0x48>)
   BLX R0
10001086:	4780      	blx	r0

   MOVS R0,#0
10001088:	2000      	movs	r0, #0
   MOVS R1,#0
1000108a:	2100      	movs	r1, #0
   LDR R2, =main
1000108c:	4a0e      	ldr	r2, [pc, #56]	; (100010c8 <SKIPCLEAR+0x4c>)
   MOV PC,R2
1000108e:	4697      	mov	pc, r2
   .fnstart
   /* Memories are accessible now*/
   
   /* DATA COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =DataLoadAddr
10001090:	10004070 	.word	0x10004070
   LDR R1, =__Xmc1100_sData
10001094:	20000ae0 	.word	0x20000ae0
   LDR R2, =__Xmc1100_Data_Size
10001098:	00000008 	.word	0x00000008
   BL __COPY_FLASH2RAM

   /* RAM_CODE COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =__ram_code_load
1000109c:	10004078 	.word	0x10004078
   LDR R1, =__ram_code_start
100010a0:	20000ae8 	.word	0x20000ae8
   LDR R2, =__ram_code_size
100010a4:	00000000 	.word	0x00000000
   BL __COPY_FLASH2RAM

   /* VENEER COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =VeneerLoadAddr
100010a8:	10003f60 	.word	0x10003f60
   LDR R1, =VeneerStart
100010ac:	2000000c 	.word	0x2000000c
   LDR R2, =VeneerSize
100010b0:	00000110 	.word	0x00000110
   BL __COPY_FLASH2RAM

   /* BSS CLEAR */
   LDR R0, =__Xmc1100_sBSS     /* Start of BSS */
100010b4:	20000920 	.word	0x20000920
   LDR R1, =__Xmc1100_BSS_Size /* BSS size in bytes */
100010b8:	000001b8 	.word	0x000001b8
   B CLEARLOOP
    
SKIPCLEAR:

   /* Reset stack pointer before zipping off to user application, Optional */
   LDR R0,=__Xmc1100_stack 
100010bc:	20000920 	.word	0x20000920
   MOV SP,R0

   /* Perform System Initialization */   
   LDR R0,=SystemInit
100010c0:	10001105 	.word	0x10001105
   BLX R0

   /* Launch custom post-program loading startup procedure */
   LDR R0,=software_init_hook
100010c4:	100010cd 	.word	0x100010cd
   BLX R0

   MOVS R0,#0
   MOVS R1,#0
   LDR R2, =main
100010c8:	10001205 	.word	0x10001205

100010cc <software_init_hook>:
   has not been started.
 */
     .weak software_init_hook
     .type software_init_hook, %function
software_init_hook:
     NOP
100010cc:	46c0      	nop			; (mov r8, r8)
     BX LR
100010ce:	4770      	bx	lr

100010d0 <hardware_init_hook>:
     .size software_init_hook, . - software_init_hook

     .weak hardware_init_hook
     .type hardware_init_hook, %function
hardware_init_hook:
     NOP
100010d0:	46c0      	nop			; (mov r8, r8)
     BX LR
100010d2:	4770      	bx	lr

100010d4 <NMI_Handler>:
/* Default exception Handlers - Users may override this default functionality by
   defining handlers of the same name in their C code */
    .thumb 
    .text

    Insert_ExceptionHandler NMI_Handler
100010d4:	e7fe      	b.n	100010d4 <NMI_Handler>

100010d6 <HardFault_Handler>:
/* ======================================================================== */
    Insert_ExceptionHandler HardFault_Handler
100010d6:	e7fe      	b.n	100010d6 <HardFault_Handler>

100010d8 <SVC_Handler>:
/* ======================================================================== */
    Insert_ExceptionHandler SVC_Handler
100010d8:	e7fe      	b.n	100010d8 <SVC_Handler>

100010da <PendSV_Handler>:
/* ======================================================================== */
    Insert_ExceptionHandler PendSV_Handler
100010da:	e7fe      	b.n	100010da <PendSV_Handler>

100010dc <SysTick_Handler>:
/* ======================================================================== */
    Insert_ExceptionHandler SysTick_Handler
100010dc:	e7fe      	b.n	100010dc <SysTick_Handler>

100010de <SCU_0_IRQHandler>:
/* ============= END OF EXCEPTION HANDLER DEFINITION ======================== */

/* ============= START OF INTERRUPT HANDLER DEFINITION ====================== */

/* IRQ Handlers */
    Insert_ExceptionHandler SCU_0_IRQHandler
100010de:	e7fe      	b.n	100010de <SCU_0_IRQHandler>

100010e0 <SCU_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler SCU_1_IRQHandler
100010e0:	e7fe      	b.n	100010e0 <SCU_1_IRQHandler>

100010e2 <SCU_2_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler SCU_2_IRQHandler
100010e2:	e7fe      	b.n	100010e2 <SCU_2_IRQHandler>

100010e4 <ERU0_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler ERU0_0_IRQHandler
100010e4:	e7fe      	b.n	100010e4 <ERU0_0_IRQHandler>

100010e6 <ERU0_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler ERU0_1_IRQHandler
100010e6:	e7fe      	b.n	100010e6 <ERU0_1_IRQHandler>

100010e8 <ERU0_2_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler ERU0_2_IRQHandler
100010e8:	e7fe      	b.n	100010e8 <ERU0_2_IRQHandler>

100010ea <ERU0_3_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler ERU0_3_IRQHandler
100010ea:	e7fe      	b.n	100010ea <ERU0_3_IRQHandler>

100010ec <VADC0_C0_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler VADC0_C0_0_IRQHandler
100010ec:	e7fe      	b.n	100010ec <VADC0_C0_0_IRQHandler>

100010ee <VADC0_C0_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler VADC0_C0_1_IRQHandler
100010ee:	e7fe      	b.n	100010ee <VADC0_C0_1_IRQHandler>

100010f0 <CCU40_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler CCU40_0_IRQHandler
100010f0:	e7fe      	b.n	100010f0 <CCU40_0_IRQHandler>

100010f2 <CCU40_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler CCU40_1_IRQHandler
100010f2:	e7fe      	b.n	100010f2 <CCU40_1_IRQHandler>

100010f4 <CCU40_2_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler CCU40_2_IRQHandler
100010f4:	e7fe      	b.n	100010f4 <CCU40_2_IRQHandler>
/* ======================================================================== */
    Insert_ExceptionHandler CCU40_3_IRQHandler
100010f6:	e7fe      	b.n	100010f6 <CCU40_2_IRQHandler+0x2>

100010f8 <USIC0_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_0_IRQHandler
100010f8:	e7fe      	b.n	100010f8 <USIC0_0_IRQHandler>

100010fa <USIC0_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_1_IRQHandler
100010fa:	e7fe      	b.n	100010fa <USIC0_1_IRQHandler>

100010fc <USIC0_2_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_2_IRQHandler
100010fc:	e7fe      	b.n	100010fc <USIC0_2_IRQHandler>

100010fe <USIC0_3_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_3_IRQHandler
100010fe:	e7fe      	b.n	100010fe <USIC0_3_IRQHandler>

10001100 <USIC0_4_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_4_IRQHandler
10001100:	e7fe      	b.n	10001100 <USIC0_4_IRQHandler>

10001102 <USIC0_5_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_5_IRQHandler
10001102:	e7fe      	b.n	10001102 <USIC0_5_IRQHandler>

10001104 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{    
10001104:	b580      	push	{r7, lr}
10001106:	af00      	add	r7, sp, #0
   * while((SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk));
   * SCU_GENERAL->PASSWD = 0x000000C3UL; // enable bit protection
   * SystemCoreClockUpdate();
   *
   */
  SystemCoreClockUpdate();
10001108:	f000 f802 	bl	10001110 <SystemCoreClockUpdate>
}
1000110c:	46bd      	mov	sp, r7
1000110e:	bd80      	pop	{r7, pc}

10001110 <SystemCoreClockUpdate>:
  * @note   -  
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
10001110:	b580      	push	{r7, lr}
10001112:	b082      	sub	sp, #8
10001114:	af00      	add	r7, sp, #0
  uint32_t IDIV, FDIV;

  IDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
10001116:	4b11      	ldr	r3, [pc, #68]	; (1000115c <SystemCoreClockUpdate+0x4c>)
10001118:	681a      	ldr	r2, [r3, #0]
1000111a:	23ff      	movs	r3, #255	; 0xff
1000111c:	021b      	lsls	r3, r3, #8
1000111e:	4013      	ands	r3, r2
10001120:	0a1b      	lsrs	r3, r3, #8
10001122:	607b      	str	r3, [r7, #4]
  FDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_FDIV_Msk) >> SCU_CLK_CLKCR_FDIV_Pos;
10001124:	4b0d      	ldr	r3, [pc, #52]	; (1000115c <SystemCoreClockUpdate+0x4c>)
10001126:	681a      	ldr	r2, [r3, #0]
10001128:	23ff      	movs	r3, #255	; 0xff
1000112a:	4013      	ands	r3, r2
1000112c:	603b      	str	r3, [r7, #0]
  
  if(IDIV)
1000112e:	687b      	ldr	r3, [r7, #4]
10001130:	2b00      	cmp	r3, #0
10001132:	d00c      	beq.n	1000114e <SystemCoreClockUpdate+0x3e>
  {
    /* Fractional divider is enabled and used */
    SystemCoreClock = ((MCLK_MHZ << 7) / ((IDIV << 8) + FDIV)) << 1;
10001134:	687b      	ldr	r3, [r7, #4]
10001136:	021a      	lsls	r2, r3, #8
10001138:	683b      	ldr	r3, [r7, #0]
1000113a:	18d3      	adds	r3, r2, r3
1000113c:	4808      	ldr	r0, [pc, #32]	; (10001160 <SystemCoreClockUpdate+0x50>)
1000113e:	1c19      	adds	r1, r3, #0
10001140:	f002 f806 	bl	10003150 <__aeabi_uidiv>
10001144:	1c03      	adds	r3, r0, #0
10001146:	005a      	lsls	r2, r3, #1
10001148:	4b06      	ldr	r3, [pc, #24]	; (10001164 <SystemCoreClockUpdate+0x54>)
1000114a:	601a      	str	r2, [r3, #0]
1000114c:	e002      	b.n	10001154 <SystemCoreClockUpdate+0x44>
  }
  else
  {
    /* Fractional divider bypassed. Simply divide DCO_DCLK by 2 */
    SystemCoreClock = MCLK_MHZ;
1000114e:	4b05      	ldr	r3, [pc, #20]	; (10001164 <SystemCoreClockUpdate+0x54>)
10001150:	4a05      	ldr	r2, [pc, #20]	; (10001168 <SystemCoreClockUpdate+0x58>)
10001152:	601a      	str	r2, [r3, #0]
  }
}
10001154:	46bd      	mov	sp, r7
10001156:	b002      	add	sp, #8
10001158:	bd80      	pop	{r7, pc}
1000115a:	46c0      	nop			; (mov r8, r8)
1000115c:	40010300 	.word	0x40010300
10001160:	f4240000 	.word	0xf4240000
10001164:	20000ad4 	.word	0x20000ad4
10001168:	01e84800 	.word	0x01e84800

1000116c <P0_5_set_large_hysteresis>:

__STATIC_INLINE void P0_5_set_standard_hysteresis(){
    PORT0->PHCR0 &= ~0x00400000UL;
}

__STATIC_INLINE void P0_5_set_large_hysteresis(){
1000116c:	b580      	push	{r7, lr}
1000116e:	af00      	add	r7, sp, #0
    PORT0->PHCR0 |= 0x00400000UL;
10001170:	4b04      	ldr	r3, [pc, #16]	; (10001184 <P0_5_set_large_hysteresis+0x18>)
10001172:	4a04      	ldr	r2, [pc, #16]	; (10001184 <P0_5_set_large_hysteresis+0x18>)
10001174:	6c12      	ldr	r2, [r2, #64]	; 0x40
10001176:	2180      	movs	r1, #128	; 0x80
10001178:	03c9      	lsls	r1, r1, #15
1000117a:	430a      	orrs	r2, r1
1000117c:	641a      	str	r2, [r3, #64]	; 0x40
}
1000117e:	46bd      	mov	sp, r7
10001180:	bd80      	pop	{r7, pc}
10001182:	46c0      	nop			; (mov r8, r8)
10001184:	40040000 	.word	0x40040000

10001188 <P0_5_read>:

__STATIC_INLINE void P0_5_toggle(void){
    PORT0->OMR = 0x00200020UL;
}

__STATIC_INLINE uint32_t P0_5_read(void){
10001188:	b580      	push	{r7, lr}
1000118a:	af00      	add	r7, sp, #0
    return(PORT0->IN & 0x00000020UL);
1000118c:	4b03      	ldr	r3, [pc, #12]	; (1000119c <P0_5_read+0x14>)
1000118e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
10001190:	2320      	movs	r3, #32
10001192:	4013      	ands	r3, r2
}
10001194:	1c18      	adds	r0, r3, #0
10001196:	46bd      	mov	sp, r7
10001198:	bd80      	pop	{r7, pc}
1000119a:	46c0      	nop			; (mov r8, r8)
1000119c:	40040000 	.word	0x40040000

100011a0 <P0_6_set_mode>:

__STATIC_INLINE void P0_5_disable_pps(void){
    PORT0->PPS &= ~0x00000020UL;
}

__STATIC_INLINE void P0_6_set_mode(uint8_t mode){
100011a0:	b580      	push	{r7, lr}
100011a2:	b082      	sub	sp, #8
100011a4:	af00      	add	r7, sp, #0
100011a6:	1c02      	adds	r2, r0, #0
100011a8:	1dfb      	adds	r3, r7, #7
100011aa:	701a      	strb	r2, [r3, #0]
    PORT0->IOCR4 &= ~0x00f80000UL;
100011ac:	4b08      	ldr	r3, [pc, #32]	; (100011d0 <P0_6_set_mode+0x30>)
100011ae:	4a08      	ldr	r2, [pc, #32]	; (100011d0 <P0_6_set_mode+0x30>)
100011b0:	6951      	ldr	r1, [r2, #20]
100011b2:	4a08      	ldr	r2, [pc, #32]	; (100011d4 <P0_6_set_mode+0x34>)
100011b4:	400a      	ands	r2, r1
100011b6:	615a      	str	r2, [r3, #20]
    PORT0->IOCR4 |= mode << 16;
100011b8:	4b05      	ldr	r3, [pc, #20]	; (100011d0 <P0_6_set_mode+0x30>)
100011ba:	4a05      	ldr	r2, [pc, #20]	; (100011d0 <P0_6_set_mode+0x30>)
100011bc:	6951      	ldr	r1, [r2, #20]
100011be:	1dfa      	adds	r2, r7, #7
100011c0:	7812      	ldrb	r2, [r2, #0]
100011c2:	0412      	lsls	r2, r2, #16
100011c4:	430a      	orrs	r2, r1
100011c6:	615a      	str	r2, [r3, #20]
}
100011c8:	46bd      	mov	sp, r7
100011ca:	b002      	add	sp, #8
100011cc:	bd80      	pop	{r7, pc}
100011ce:	46c0      	nop			; (mov r8, r8)
100011d0:	40040000 	.word	0x40040000
100011d4:	ff07ffff 	.word	0xff07ffff

100011d8 <P0_6_set>:

__STATIC_INLINE void P0_6_set_large_hysteresis(){
    PORT0->PHCR0 |= 0x04000000UL;
}

__STATIC_INLINE void P0_6_set(void){
100011d8:	b580      	push	{r7, lr}
100011da:	af00      	add	r7, sp, #0
    PORT0->OMR = 0x00000040UL;
100011dc:	4b02      	ldr	r3, [pc, #8]	; (100011e8 <P0_6_set+0x10>)
100011de:	2240      	movs	r2, #64	; 0x40
100011e0:	605a      	str	r2, [r3, #4]
}
100011e2:	46bd      	mov	sp, r7
100011e4:	bd80      	pop	{r7, pc}
100011e6:	46c0      	nop			; (mov r8, r8)
100011e8:	40040000 	.word	0x40040000

100011ec <P0_6_toggle>:

__STATIC_INLINE void P0_6_reset(void){
    PORT0->OMR = 0x00400000UL;
}

__STATIC_INLINE void P0_6_toggle(void){
100011ec:	b580      	push	{r7, lr}
100011ee:	af00      	add	r7, sp, #0
    PORT0->OMR = 0x00400040UL;
100011f0:	4b02      	ldr	r3, [pc, #8]	; (100011fc <P0_6_toggle+0x10>)
100011f2:	4a03      	ldr	r2, [pc, #12]	; (10001200 <P0_6_toggle+0x14>)
100011f4:	605a      	str	r2, [r3, #4]
}
100011f6:	46bd      	mov	sp, r7
100011f8:	bd80      	pop	{r7, pc}
100011fa:	46c0      	nop			; (mov r8, r8)
100011fc:	40040000 	.word	0x40040000
10001200:	00400040 	.word	0x00400040

10001204 <main>:




int main(void)
{
10001204:	b580      	push	{r7, lr}
10001206:	b08a      	sub	sp, #40	; 0x28
10001208:	af00      	add	r7, sp, #0
	status_t status;		// Declaration of return variable for DAVE3 APIs


	DAVE_Init();			// Initialization of DAVE Apps
1000120a:	f001 fdf9 	bl	10002e00 <DAVE_Init>

	
	/* Starts the PWMSP001 App (LED) */
	status = PWMSP001_Start((PWMSP001_HandleType*)&PWMSP001_Handle0);
1000120e:	4b58      	ldr	r3, [pc, #352]	; (10001370 <main+0x16c>)
10001210:	1c18      	adds	r0, r3, #0
10001212:	f000 fc23 	bl	10001a5c <PWMSP001_Start>
10001216:	1c03      	adds	r3, r0, #0
10001218:	607b      	str	r3, [r7, #4]
	if(status != DAVEApp_SUCCESS)
1000121a:	687b      	ldr	r3, [r7, #4]
1000121c:	2b00      	cmp	r3, #0
1000121e:	d003      	beq.n	10001228 <main+0x24>
	{
		PWMSP001_Stop((PWMSP001_HandleType*)&PWMSP001_Handle0);
10001220:	4b53      	ldr	r3, [pc, #332]	; (10001370 <main+0x16c>)
10001222:	1c18      	adds	r0, r3, #0
10001224:	f000 fcd6 	bl	10001bd4 <PWMSP001_Stop>
	}

	PIN_LOW_INIT();
10001228:	20c0      	movs	r0, #192	; 0xc0
1000122a:	f7ff ffb9 	bl	100011a0 <P0_6_set_mode>
1000122e:	f7ff ffd3 	bl	100011d8 <P0_6_set>
	PIN_IS_INIT();
10001232:	f7ff ff9b 	bl	1000116c <P0_5_set_large_hysteresis>
10001236:	f7ff ffa7 	bl	10001188 <P0_5_read>



	bool lastPinState = PIN_IS_HIGH();
1000123a:	f7ff ffa5 	bl	10001188 <P0_5_read>
1000123e:	1c02      	adds	r2, r0, #0
10001240:	1c3b      	adds	r3, r7, #0
10001242:	3327      	adds	r3, #39	; 0x27
10001244:	701a      	strb	r2, [r3, #0]
	bool trigger = FALSE;
10001246:	1c3b      	adds	r3, r7, #0
10001248:	3326      	adds	r3, #38	; 0x26
1000124a:	2200      	movs	r2, #0
1000124c:	701a      	strb	r2, [r3, #0]
	int noTriggerCnt=0;
1000124e:	2300      	movs	r3, #0
10001250:	623b      	str	r3, [r7, #32]
	int speed=0;
10001252:	2300      	movs	r3, #0
10001254:	61fb      	str	r3, [r7, #28]
	int speedLow=0;
10001256:	2300      	movs	r3, #0
10001258:	61bb      	str	r3, [r7, #24]
	int speedLowHigh=0;
1000125a:	2300      	movs	r3, #0
1000125c:	617b      	str	r3, [r7, #20]

	int pinCheckCycles = 100;
1000125e:	2364      	movs	r3, #100	; 0x64
10001260:	603b      	str	r3, [r7, #0]
10001262:	e000      	b.n	10001266 <main+0x62>
			{
				PIN_LOW_TOGGLE();
			}
		}

	}
10001264:	46c0      	nop			; (mov r8, r8)



	while(1)
	{
		speed++;
10001266:	69fb      	ldr	r3, [r7, #28]
10001268:	3301      	adds	r3, #1
1000126a:	61fb      	str	r3, [r7, #28]
		speedLow++;
1000126c:	69bb      	ldr	r3, [r7, #24]
1000126e:	3301      	adds	r3, #1
10001270:	61bb      	str	r3, [r7, #24]
		

		int cnt_high=0;
10001272:	2300      	movs	r3, #0
10001274:	613b      	str	r3, [r7, #16]
		int cnt_low=0;
10001276:	2300      	movs	r3, #0
10001278:	60fb      	str	r3, [r7, #12]
		for (int i = 0; i < pinCheckCycles; i++)
1000127a:	2300      	movs	r3, #0
1000127c:	60bb      	str	r3, [r7, #8]
1000127e:	e00e      	b.n	1000129e <main+0x9a>
		{
			if (PIN_IS_HIGH())
10001280:	f7ff ff82 	bl	10001188 <P0_5_read>
10001284:	1c03      	adds	r3, r0, #0
10001286:	2b00      	cmp	r3, #0
10001288:	d003      	beq.n	10001292 <main+0x8e>
				cnt_high++;
1000128a:	693b      	ldr	r3, [r7, #16]
1000128c:	3301      	adds	r3, #1
1000128e:	613b      	str	r3, [r7, #16]
10001290:	e002      	b.n	10001298 <main+0x94>
			else
				cnt_low++;
10001292:	68fb      	ldr	r3, [r7, #12]
10001294:	3301      	adds	r3, #1
10001296:	60fb      	str	r3, [r7, #12]
		speedLow++;
		

		int cnt_high=0;
		int cnt_low=0;
		for (int i = 0; i < pinCheckCycles; i++)
10001298:	68bb      	ldr	r3, [r7, #8]
1000129a:	3301      	adds	r3, #1
1000129c:	60bb      	str	r3, [r7, #8]
1000129e:	68ba      	ldr	r2, [r7, #8]
100012a0:	683b      	ldr	r3, [r7, #0]
100012a2:	429a      	cmp	r2, r3
100012a4:	dbec      	blt.n	10001280 <main+0x7c>
			else
				cnt_low++;
		}
		
		
		if (cnt_low > 0)
100012a6:	68fb      	ldr	r3, [r7, #12]
100012a8:	2b00      	cmp	r3, #0
100012aa:	dd39      	ble.n	10001320 <main+0x11c>
		{
			if (lastPinState)
100012ac:	1c3b      	adds	r3, r7, #0
100012ae:	3327      	adds	r3, #39	; 0x27
100012b0:	781b      	ldrb	r3, [r3, #0]
100012b2:	2b00      	cmp	r3, #0
100012b4:	d02f      	beq.n	10001316 <main+0x112>
			{
				trigger = TRUE;
100012b6:	1c3b      	adds	r3, r7, #0
100012b8:	3326      	adds	r3, #38	; 0x26
100012ba:	2201      	movs	r2, #1
100012bc:	701a      	strb	r2, [r3, #0]
				speedLowHigh = (speed<<3)/10; // *16/10/2
100012be:	69fb      	ldr	r3, [r7, #28]
100012c0:	00db      	lsls	r3, r3, #3
100012c2:	1c18      	adds	r0, r3, #0
100012c4:	210a      	movs	r1, #10
100012c6:	f001 ff91 	bl	100031ec <__aeabi_idiv>
100012ca:	1c03      	adds	r3, r0, #0
100012cc:	617b      	str	r3, [r7, #20]
				debugSpeedBuffer[debugCount%DEBUG_CNT_BUFFER_SIZE] = speed;
100012ce:	4b29      	ldr	r3, [pc, #164]	; (10001374 <main+0x170>)
100012d0:	681b      	ldr	r3, [r3, #0]
100012d2:	1c18      	adds	r0, r3, #0
100012d4:	2164      	movs	r1, #100	; 0x64
100012d6:	f001 ffdf 	bl	10003298 <__aeabi_idivmod>
100012da:	1c0b      	adds	r3, r1, #0
100012dc:	1c1a      	adds	r2, r3, #0
100012de:	4b26      	ldr	r3, [pc, #152]	; (10001378 <main+0x174>)
100012e0:	0092      	lsls	r2, r2, #2
100012e2:	69f9      	ldr	r1, [r7, #28]
100012e4:	50d1      	str	r1, [r2, r3]
				debugCount++;
100012e6:	4b23      	ldr	r3, [pc, #140]	; (10001374 <main+0x170>)
100012e8:	681b      	ldr	r3, [r3, #0]
100012ea:	1c5a      	adds	r2, r3, #1
100012ec:	4b21      	ldr	r3, [pc, #132]	; (10001374 <main+0x170>)
100012ee:	601a      	str	r2, [r3, #0]
				debugSpeedBuffer[debugCount%DEBUG_CNT_BUFFER_SIZE] = speedLowHigh;
100012f0:	4b20      	ldr	r3, [pc, #128]	; (10001374 <main+0x170>)
100012f2:	681b      	ldr	r3, [r3, #0]
100012f4:	1c18      	adds	r0, r3, #0
100012f6:	2164      	movs	r1, #100	; 0x64
100012f8:	f001 ffce 	bl	10003298 <__aeabi_idivmod>
100012fc:	1c0b      	adds	r3, r1, #0
100012fe:	1c1a      	adds	r2, r3, #0
10001300:	4b1d      	ldr	r3, [pc, #116]	; (10001378 <main+0x174>)
10001302:	0092      	lsls	r2, r2, #2
10001304:	6979      	ldr	r1, [r7, #20]
10001306:	50d1      	str	r1, [r2, r3]
				debugCount++;
10001308:	4b1a      	ldr	r3, [pc, #104]	; (10001374 <main+0x170>)
1000130a:	681b      	ldr	r3, [r3, #0]
1000130c:	1c5a      	adds	r2, r3, #1
1000130e:	4b19      	ldr	r3, [pc, #100]	; (10001374 <main+0x170>)
10001310:	601a      	str	r2, [r3, #0]
				speed=0;
10001312:	2300      	movs	r3, #0
10001314:	61fb      	str	r3, [r7, #28]

			}
			lastPinState = FALSE;
10001316:	1c3b      	adds	r3, r7, #0
10001318:	3327      	adds	r3, #39	; 0x27
1000131a:	2200      	movs	r2, #0
1000131c:	701a      	strb	r2, [r3, #0]
1000131e:	e006      	b.n	1000132e <main+0x12a>
		}
		else if (cnt_high > 0)
10001320:	693b      	ldr	r3, [r7, #16]
10001322:	2b00      	cmp	r3, #0
10001324:	dd03      	ble.n	1000132e <main+0x12a>
		{
			lastPinState = TRUE;
10001326:	1c3b      	adds	r3, r7, #0
10001328:	3327      	adds	r3, #39	; 0x27
1000132a:	2201      	movs	r2, #1
1000132c:	701a      	strb	r2, [r3, #0]
		}
		
		if (speedLow >= speedLowHigh)
1000132e:	69ba      	ldr	r2, [r7, #24]
10001330:	697b      	ldr	r3, [r7, #20]
10001332:	429a      	cmp	r2, r3
10001334:	db96      	blt.n	10001264 <main+0x60>
		{
			speedLow = 0;
10001336:	2300      	movs	r3, #0
10001338:	61bb      	str	r3, [r7, #24]
			
			if (!trigger)
1000133a:	1c3b      	adds	r3, r7, #0
1000133c:	3326      	adds	r3, #38	; 0x26
1000133e:	781b      	ldrb	r3, [r3, #0]
10001340:	2b00      	cmp	r3, #0
10001342:	d103      	bne.n	1000134c <main+0x148>
				noTriggerCnt++;
10001344:	6a3b      	ldr	r3, [r7, #32]
10001346:	3301      	adds	r3, #1
10001348:	623b      	str	r3, [r7, #32]
1000134a:	e001      	b.n	10001350 <main+0x14c>
			else
				noTriggerCnt=0;
1000134c:	2300      	movs	r3, #0
1000134e:	623b      	str	r3, [r7, #32]
			trigger = FALSE;
10001350:	1c3b      	adds	r3, r7, #0
10001352:	3326      	adds	r3, #38	; 0x26
10001354:	2200      	movs	r2, #0
10001356:	701a      	strb	r2, [r3, #0]
			
			if (noTriggerCnt > 1)
10001358:	6a3b      	ldr	r3, [r7, #32]
1000135a:	2b01      	cmp	r3, #1
1000135c:	dd04      	ble.n	10001368 <main+0x164>
			{
				noTriggerCnt=1;
1000135e:	2301      	movs	r3, #1
10001360:	623b      	str	r3, [r7, #32]
				PIN_LOW_DEASSERT();
10001362:	f7ff ff39 	bl	100011d8 <P0_6_set>
			{
				PIN_LOW_TOGGLE();
			}
		}

	}
10001366:	e77d      	b.n	10001264 <main+0x60>
				noTriggerCnt=1;
				PIN_LOW_DEASSERT();
			}
			else
			{
				PIN_LOW_TOGGLE();
10001368:	f7ff ff40 	bl	100011ec <P0_6_toggle>
			}
		}

	}
1000136c:	e77a      	b.n	10001264 <main+0x60>
1000136e:	46c0      	nop			; (mov r8, r8)
10001370:	10003e80 	.word	0x10003e80
10001374:	2000092c 	.word	0x2000092c
10001378:	20000930 	.word	0x20000930

1000137c <CCU40_3_IRQHandler>:

/*
 * PWM_Period_Interrupt handler: executes every period match of PWMSP001/0.
 */
void PWM_Period_Interrupt(void)
{
1000137c:	b580      	push	{r7, lr}
1000137e:	af00      	add	r7, sp, #0
	static uint32_t state = 0;
	static uint32_t cycles = 0;
	static status_t status = DAVEApp_SUCCESS;

	/* state machine to change the different duty cycle */
	if (cycles == 0)
10001380:	4b1b      	ldr	r3, [pc, #108]	; (100013f0 <CCU40_3_IRQHandler+0x74>)
10001382:	681b      	ldr	r3, [r3, #0]
10001384:	2b00      	cmp	r3, #0
10001386:	d12b      	bne.n	100013e0 <CCU40_3_IRQHandler+0x64>
	{
		cycles = (state%MAXFREQ) + 1;
10001388:	4b1a      	ldr	r3, [pc, #104]	; (100013f4 <CCU40_3_IRQHandler+0x78>)
1000138a:	681b      	ldr	r3, [r3, #0]
1000138c:	1c18      	adds	r0, r3, #0
1000138e:	2107      	movs	r1, #7
10001390:	f001 ff22 	bl	100031d8 <__aeabi_uidivmod>
10001394:	1c0b      	adds	r3, r1, #0
10001396:	1c5a      	adds	r2, r3, #1
10001398:	4b15      	ldr	r3, [pc, #84]	; (100013f0 <CCU40_3_IRQHandler+0x74>)
1000139a:	601a      	str	r2, [r3, #0]
		status = PWMSP001_SetPwmFreqAndDutyCycle((PWMSP001_HandleType*)&PWMSP001_Handle0, cycles, 50);
1000139c:	4b14      	ldr	r3, [pc, #80]	; (100013f0 <CCU40_3_IRQHandler+0x74>)
1000139e:	681b      	ldr	r3, [r3, #0]
100013a0:	1c18      	adds	r0, r3, #0
100013a2:	f002 fcf3 	bl	10003d8c <__aeabi_ui2f>
100013a6:	1c02      	adds	r2, r0, #0
100013a8:	4913      	ldr	r1, [pc, #76]	; (100013f8 <CCU40_3_IRQHandler+0x7c>)
100013aa:	4b14      	ldr	r3, [pc, #80]	; (100013fc <CCU40_3_IRQHandler+0x80>)
100013ac:	1c08      	adds	r0, r1, #0
100013ae:	1c11      	adds	r1, r2, #0
100013b0:	1c1a      	adds	r2, r3, #0
100013b2:	f000 ff0f 	bl	100021d4 <PWMSP001_SetPwmFreqAndDutyCycle>
100013b6:	1c02      	adds	r2, r0, #0
100013b8:	4b11      	ldr	r3, [pc, #68]	; (10001400 <CCU40_3_IRQHandler+0x84>)
100013ba:	601a      	str	r2, [r3, #0]
		cycles = cycles<<2;
100013bc:	4b0c      	ldr	r3, [pc, #48]	; (100013f0 <CCU40_3_IRQHandler+0x74>)
100013be:	681b      	ldr	r3, [r3, #0]
100013c0:	009a      	lsls	r2, r3, #2
100013c2:	4b0b      	ldr	r3, [pc, #44]	; (100013f0 <CCU40_3_IRQHandler+0x74>)
100013c4:	601a      	str	r2, [r3, #0]
//				status = PWMSP001_SetPwmFreqAndDutyCycle((PWMSP001_HandleType*)&PWMSP001_Handle0, FSLOW, 50);
//				cycles = SLOWCYCLES;
//				break;
//
//		}
		state++;
100013c6:	4b0b      	ldr	r3, [pc, #44]	; (100013f4 <CCU40_3_IRQHandler+0x78>)
100013c8:	681b      	ldr	r3, [r3, #0]
100013ca:	1c5a      	adds	r2, r3, #1
100013cc:	4b09      	ldr	r3, [pc, #36]	; (100013f4 <CCU40_3_IRQHandler+0x78>)
100013ce:	601a      	str	r2, [r3, #0]
		if(status != DAVEApp_SUCCESS)
100013d0:	4b0b      	ldr	r3, [pc, #44]	; (10001400 <CCU40_3_IRQHandler+0x84>)
100013d2:	681b      	ldr	r3, [r3, #0]
100013d4:	2b00      	cmp	r3, #0
100013d6:	d003      	beq.n	100013e0 <CCU40_3_IRQHandler+0x64>
		{
			PWMSP001_Stop((PWMSP001_HandleType*)&PWMSP001_Handle0);
100013d8:	4b07      	ldr	r3, [pc, #28]	; (100013f8 <CCU40_3_IRQHandler+0x7c>)
100013da:	1c18      	adds	r0, r3, #0
100013dc:	f000 fbfa 	bl	10001bd4 <PWMSP001_Stop>
		}
	}

	/* Updation of the state machine */

	cycles--;
100013e0:	4b03      	ldr	r3, [pc, #12]	; (100013f0 <CCU40_3_IRQHandler+0x74>)
100013e2:	681b      	ldr	r3, [r3, #0]
100013e4:	1e5a      	subs	r2, r3, #1
100013e6:	4b02      	ldr	r3, [pc, #8]	; (100013f0 <CCU40_3_IRQHandler+0x74>)
100013e8:	601a      	str	r2, [r3, #0]
//	{
//		state= 0;
//	}


}
100013ea:	46bd      	mov	sp, r7
100013ec:	bd80      	pop	{r7, pc}
100013ee:	46c0      	nop			; (mov r8, r8)
100013f0:	20000920 	.word	0x20000920
100013f4:	20000924 	.word	0x20000924
100013f8:	10003e80 	.word	0x10003e80
100013fc:	42480000 	.word	0x42480000
10001400:	20000928 	.word	0x20000928

10001404 <_open>:
/* ========================================================================= */
/*
 * File open
 */
__attribute__((weak)) int _open(const char *name, int flags, int mode)
{
10001404:	b580      	push	{r7, lr}
10001406:	b084      	sub	sp, #16
10001408:	af00      	add	r7, sp, #0
1000140a:	60f8      	str	r0, [r7, #12]
1000140c:	60b9      	str	r1, [r7, #8]
1000140e:	607a      	str	r2, [r7, #4]
 flags = flags;
 mode = mode;
 return -1;
10001410:	2301      	movs	r3, #1
10001412:	425b      	negs	r3, r3
}
10001414:	1c18      	adds	r0, r3, #0
10001416:	46bd      	mov	sp, r7
10001418:	b004      	add	sp, #16
1000141a:	bd80      	pop	{r7, pc}

1000141c <_lseek>:

/*
 * File position seek
 */
__attribute__((weak)) int _lseek(int file, int offset, int whence)
{
1000141c:	b580      	push	{r7, lr}
1000141e:	b084      	sub	sp, #16
10001420:	af00      	add	r7, sp, #0
10001422:	60f8      	str	r0, [r7, #12]
10001424:	60b9      	str	r1, [r7, #8]
10001426:	607a      	str	r2, [r7, #4]
 file = file;
 offset = offset;
 whence = whence;
 return -1;
10001428:	2301      	movs	r3, #1
1000142a:	425b      	negs	r3, r3
}
1000142c:	1c18      	adds	r0, r3, #0
1000142e:	46bd      	mov	sp, r7
10001430:	b004      	add	sp, #16
10001432:	bd80      	pop	{r7, pc}

10001434 <_read>:

/*
 * File read
 */
__attribute__((weak)) int _read(int file, char *ptr, int len)
{
10001434:	b580      	push	{r7, lr}
10001436:	b084      	sub	sp, #16
10001438:	af00      	add	r7, sp, #0
1000143a:	60f8      	str	r0, [r7, #12]
1000143c:	60b9      	str	r1, [r7, #8]
1000143e:	607a      	str	r2, [r7, #4]
 file = file;
 len  = len;
 return 0;
10001440:	2300      	movs	r3, #0
}
10001442:	1c18      	adds	r0, r3, #0
10001444:	46bd      	mov	sp, r7
10001446:	b004      	add	sp, #16
10001448:	bd80      	pop	{r7, pc}
1000144a:	46c0      	nop			; (mov r8, r8)

1000144c <_write>:

/*
 * File write
 */
__attribute__((weak)) int _write(int file, char *buf, int nbytes)
{
1000144c:	b580      	push	{r7, lr}
1000144e:	b084      	sub	sp, #16
10001450:	af00      	add	r7, sp, #0
10001452:	60f8      	str	r0, [r7, #12]
10001454:	60b9      	str	r1, [r7, #8]
10001456:	607a      	str	r2, [r7, #4]
 return -1;
10001458:	2301      	movs	r3, #1
1000145a:	425b      	negs	r3, r3
}
1000145c:	1c18      	adds	r0, r3, #0
1000145e:	46bd      	mov	sp, r7
10001460:	b004      	add	sp, #16
10001462:	bd80      	pop	{r7, pc}

10001464 <_close>:

/*
 * File close
 */
__attribute__((weak)) int _close(void)
{
10001464:	b580      	push	{r7, lr}
10001466:	af00      	add	r7, sp, #0
 return -1;
10001468:	2301      	movs	r3, #1
1000146a:	425b      	negs	r3, r3
}
1000146c:	1c18      	adds	r0, r3, #0
1000146e:	46bd      	mov	sp, r7
10001470:	bd80      	pop	{r7, pc}
10001472:	46c0      	nop			; (mov r8, r8)

10001474 <_fstat>:

/*
 * File status
 */
__attribute__((weak)) int _fstat(int file, struct stat *st)
{
10001474:	b580      	push	{r7, lr}
10001476:	b082      	sub	sp, #8
10001478:	af00      	add	r7, sp, #0
1000147a:	6078      	str	r0, [r7, #4]
1000147c:	6039      	str	r1, [r7, #0]
 file = file;
 if(st)
1000147e:	683b      	ldr	r3, [r7, #0]
10001480:	2b00      	cmp	r3, #0
10001482:	d002      	beq.n	1000148a <_fstat+0x16>
  return -1;
10001484:	2301      	movs	r3, #1
10001486:	425b      	negs	r3, r3
10001488:	e001      	b.n	1000148e <_fstat+0x1a>
 else
  return -2;
1000148a:	2302      	movs	r3, #2
1000148c:	425b      	negs	r3, r3
}
1000148e:	1c18      	adds	r0, r3, #0
10001490:	46bd      	mov	sp, r7
10001492:	b002      	add	sp, #8
10001494:	bd80      	pop	{r7, pc}
10001496:	46c0      	nop			; (mov r8, r8)

10001498 <_link>:
/*
 * File linking
 */
__attribute__((weak)) int _link (char *old, char *new)
{
10001498:	b580      	push	{r7, lr}
1000149a:	b082      	sub	sp, #8
1000149c:	af00      	add	r7, sp, #0
1000149e:	6078      	str	r0, [r7, #4]
100014a0:	6039      	str	r1, [r7, #0]
 if (old == new)
100014a2:	687a      	ldr	r2, [r7, #4]
100014a4:	683b      	ldr	r3, [r7, #0]
100014a6:	429a      	cmp	r2, r3
100014a8:	d102      	bne.n	100014b0 <_link+0x18>
  return -1;
100014aa:	2301      	movs	r3, #1
100014ac:	425b      	negs	r3, r3
100014ae:	e001      	b.n	100014b4 <_link+0x1c>
 else
  return -2;
100014b0:	2302      	movs	r3, #2
100014b2:	425b      	negs	r3, r3
}
100014b4:	1c18      	adds	r0, r3, #0
100014b6:	46bd      	mov	sp, r7
100014b8:	b002      	add	sp, #8
100014ba:	bd80      	pop	{r7, pc}

100014bc <_unlink>:

/*
 * Unlinking directory entry
 */
__attribute__((weak)) int _unlink(char *name)
{
100014bc:	b580      	push	{r7, lr}
100014be:	b082      	sub	sp, #8
100014c0:	af00      	add	r7, sp, #0
100014c2:	6078      	str	r0, [r7, #4]
 return -1;
100014c4:	2301      	movs	r3, #1
100014c6:	425b      	negs	r3, r3
}
100014c8:	1c18      	adds	r0, r3, #0
100014ca:	46bd      	mov	sp, r7
100014cc:	b002      	add	sp, #8
100014ce:	bd80      	pop	{r7, pc}

100014d0 <_sbrk>:
/* ========================================================================= */
/*
 * Heap break (position)
 */
__attribute__((weak)) void *_sbrk(int RequestedSize)
{
100014d0:	b580      	push	{r7, lr}
100014d2:	b086      	sub	sp, #24
100014d4:	af00      	add	r7, sp, #0
100014d6:	6078      	str	r0, [r7, #4]
 unsigned int  HeapSize;
 static unsigned char *HeapBound;
 static unsigned char * heap= (unsigned char *)NULL;


 HeapSize   = (unsigned int)(&Heap_Bank1_Size);
100014d8:	4b14      	ldr	r3, [pc, #80]	; (1000152c <_sbrk+0x5c>)
100014da:	617b      	str	r3, [r7, #20]

 /*
  * If this is the first time malloc() was invoked, we start with the
  * begining of the heap.
  */
 if(heap == (unsigned char *)NULL)
100014dc:	4b14      	ldr	r3, [pc, #80]	; (10001530 <_sbrk+0x60>)
100014de:	681b      	ldr	r3, [r3, #0]
100014e0:	2b00      	cmp	r3, #0
100014e2:	d108      	bne.n	100014f6 <_sbrk+0x26>
  {
   heap = (unsigned char *)&Heap_Bank1_Start;
100014e4:	4b12      	ldr	r3, [pc, #72]	; (10001530 <_sbrk+0x60>)
100014e6:	4a13      	ldr	r2, [pc, #76]	; (10001534 <_sbrk+0x64>)
100014e8:	601a      	str	r2, [r3, #0]
   HeapBound  = (unsigned char *) (heap + HeapSize);
100014ea:	4b11      	ldr	r3, [pc, #68]	; (10001530 <_sbrk+0x60>)
100014ec:	681a      	ldr	r2, [r3, #0]
100014ee:	697b      	ldr	r3, [r7, #20]
100014f0:	18d2      	adds	r2, r2, r3
100014f2:	4b11      	ldr	r3, [pc, #68]	; (10001538 <_sbrk+0x68>)
100014f4:	601a      	str	r2, [r3, #0]
  }

 /* Super duper algo to find out if we have memory for the latest request */
 /* Given conditions are: */
 /* 1. Latest break */
 CurrBreak = heap;
100014f6:	4b0e      	ldr	r3, [pc, #56]	; (10001530 <_sbrk+0x60>)
100014f8:	681b      	ldr	r3, [r3, #0]
100014fa:	613b      	str	r3, [r7, #16]

 /* And 2. Potential break based on requested size */
 NextBreak = (unsigned char *)( (((unsigned int)(heap)) + RequestedSize + 7)
100014fc:	4b0c      	ldr	r3, [pc, #48]	; (10001530 <_sbrk+0x60>)
100014fe:	681b      	ldr	r3, [r3, #0]
10001500:	1c1a      	adds	r2, r3, #0
10001502:	687b      	ldr	r3, [r7, #4]
10001504:	18d3      	adds	r3, r2, r3
10001506:	3307      	adds	r3, #7
                                          & 0xFFFFFFF8);
10001508:	2207      	movs	r2, #7
1000150a:	4393      	bics	r3, r2
 /* Given conditions are: */
 /* 1. Latest break */
 CurrBreak = heap;

 /* And 2. Potential break based on requested size */
 NextBreak = (unsigned char *)( (((unsigned int)(heap)) + RequestedSize + 7)
1000150c:	60fb      	str	r3, [r7, #12]
                                          & 0xFFFFFFF8);

 /* Return no memory condition if we sense we are crossing the limit */
 if (NextBreak >=  HeapBound )
1000150e:	4b0a      	ldr	r3, [pc, #40]	; (10001538 <_sbrk+0x68>)
10001510:	681b      	ldr	r3, [r3, #0]
10001512:	68fa      	ldr	r2, [r7, #12]
10001514:	429a      	cmp	r2, r3
10001516:	d301      	bcc.n	1000151c <_sbrk+0x4c>
  return ((unsigned char *)NULL);
10001518:	2300      	movs	r3, #0
1000151a:	e003      	b.n	10001524 <_sbrk+0x54>
 else
 {
  heap = NextBreak;
1000151c:	4b04      	ldr	r3, [pc, #16]	; (10001530 <_sbrk+0x60>)
1000151e:	68fa      	ldr	r2, [r7, #12]
10001520:	601a      	str	r2, [r3, #0]
  return CurrBreak;
10001522:	693b      	ldr	r3, [r7, #16]
 }
}
10001524:	1c18      	adds	r0, r3, #0
10001526:	46bd      	mov	sp, r7
10001528:	b006      	add	sp, #24
1000152a:	bd80      	pop	{r7, pc}
1000152c:	00003518 	.word	0x00003518
10001530:	20000ac4 	.word	0x20000ac4
10001534:	20000ae8 	.word	0x20000ae8
10001538:	20000ac8 	.word	0x20000ac8

1000153c <_times>:
/* ========================================================================= */
/*
 * Process timing information
 */
__attribute__((weak)) int _times(struct tms *buf)
{
1000153c:	b580      	push	{r7, lr}
1000153e:	b082      	sub	sp, #8
10001540:	af00      	add	r7, sp, #0
10001542:	6078      	str	r0, [r7, #4]
 return -1;
10001544:	2301      	movs	r3, #1
10001546:	425b      	negs	r3, r3
}
10001548:	1c18      	adds	r0, r3, #0
1000154a:	46bd      	mov	sp, r7
1000154c:	b002      	add	sp, #8
1000154e:	bd80      	pop	{r7, pc}

10001550 <_wait>:
/*
 * Waiting for a child process to complete
 */
__attribute__((weak)) int _wait(int *status)
{
10001550:	b580      	push	{r7, lr}
10001552:	b082      	sub	sp, #8
10001554:	af00      	add	r7, sp, #0
10001556:	6078      	str	r0, [r7, #4]
 return -1;
10001558:	2301      	movs	r3, #1
1000155a:	425b      	negs	r3, r3
}
1000155c:	1c18      	adds	r0, r3, #0
1000155e:	46bd      	mov	sp, r7
10001560:	b002      	add	sp, #8
10001562:	bd80      	pop	{r7, pc}

10001564 <_kill>:

/*
 * Kill a process
 */
__attribute__((weak)) int _kill(int pid,int sig)
{
10001564:	b580      	push	{r7, lr}
10001566:	b082      	sub	sp, #8
10001568:	af00      	add	r7, sp, #0
1000156a:	6078      	str	r0, [r7, #4]
1000156c:	6039      	str	r1, [r7, #0]
 pid = pid;
 sig = sig;
 return -1;
1000156e:	2301      	movs	r3, #1
10001570:	425b      	negs	r3, r3
}
10001572:	1c18      	adds	r0, r3, #0
10001574:	46bd      	mov	sp, r7
10001576:	b002      	add	sp, #8
10001578:	bd80      	pop	{r7, pc}
1000157a:	46c0      	nop			; (mov r8, r8)

1000157c <_fork>:

/*
 * Forking a child process
 */
__attribute__((weak)) int _fork(void)
{
1000157c:	b580      	push	{r7, lr}
1000157e:	af00      	add	r7, sp, #0
 return -1;
10001580:	2301      	movs	r3, #1
10001582:	425b      	negs	r3, r3
}
10001584:	1c18      	adds	r0, r3, #0
10001586:	46bd      	mov	sp, r7
10001588:	bd80      	pop	{r7, pc}
1000158a:	46c0      	nop			; (mov r8, r8)

1000158c <_getpid>:

/*
 * Process ID
 */
__attribute__((weak)) int _getpid(void)
{
1000158c:	b580      	push	{r7, lr}
1000158e:	af00      	add	r7, sp, #0
 return -1;
10001590:	2301      	movs	r3, #1
10001592:	425b      	negs	r3, r3
}
10001594:	1c18      	adds	r0, r3, #0
10001596:	46bd      	mov	sp, r7
10001598:	bd80      	pop	{r7, pc}
1000159a:	46c0      	nop			; (mov r8, r8)

1000159c <_exit>:

/*
 * Program/process exit
 */
__attribute__((weak)) void _exit(int rc)
{
1000159c:	b580      	push	{r7, lr}
1000159e:	b082      	sub	sp, #8
100015a0:	af00      	add	r7, sp, #0
100015a2:	6078      	str	r0, [r7, #4]
 rc = rc;
 while(1){}
100015a4:	e7fe      	b.n	100015a4 <_exit+0x8>
100015a6:	46c0      	nop			; (mov r8, r8)

100015a8 <_init>:
}

/* Init */
__attribute__((weak)) void _init(void)
{}
100015a8:	b580      	push	{r7, lr}
100015aa:	af00      	add	r7, sp, #0
100015ac:	46bd      	mov	sp, r7
100015ae:	bd80      	pop	{r7, pc}

100015b0 <_isatty>:

/*
 * Terminal type evaluation
 */
__attribute__((weak)) int _isatty(int file)
{
100015b0:	b580      	push	{r7, lr}
100015b2:	b082      	sub	sp, #8
100015b4:	af00      	add	r7, sp, #0
100015b6:	6078      	str	r0, [r7, #4]
 file = file;
 return -1;
100015b8:	2301      	movs	r3, #1
100015ba:	425b      	negs	r3, r3
}
100015bc:	1c18      	adds	r0, r3, #0
100015be:	46bd      	mov	sp, r7
100015c0:	b002      	add	sp, #8
100015c2:	bd80      	pop	{r7, pc}

100015c4 <PWMSP001_Init>:
 **                 Function definitions                                       **
 *******************************************************************************/
   
/* This function initializes the app */
void PWMSP001_Init(void)
{
100015c4:	b580      	push	{r7, lr}
100015c6:	b082      	sub	sp, #8
100015c8:	af00      	add	r7, sp, #0
  status_t Error = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
100015ca:	2301      	movs	r3, #1
100015cc:	607b      	str	r3, [r7, #4]
  CCU4GLOBAL_Init();
100015ce:	f001 fd5b 	bl	10003088 <CCU4GLOBAL_Init>
  Error = PWMSP001_lInit((PWMSP001_HandleType*) &PWMSP001_Handle0);
100015d2:	4b10      	ldr	r3, [pc, #64]	; (10001614 <PWMSP001_Init+0x50>)
100015d4:	1c18      	adds	r0, r3, #0
100015d6:	f000 f823 	bl	10001620 <PWMSP001_lInit>
100015da:	1c03      	adds	r3, r0, #0
100015dc:	607b      	str	r3, [r7, #4]
  /* Start the app if "Start after initialization" is checked */
  if(Error == (uint32_t)DAVEApp_SUCCESS)
100015de:	687b      	ldr	r3, [r7, #4]
100015e0:	2b00      	cmp	r3, #0
100015e2:	d109      	bne.n	100015f8 <PWMSP001_Init+0x34>
  {   
    if (PWMSP001_Handle0.StartControl == (uint8_t)SET)
100015e4:	4b0b      	ldr	r3, [pc, #44]	; (10001614 <PWMSP001_Init+0x50>)
100015e6:	785b      	ldrb	r3, [r3, #1]
100015e8:	2b01      	cmp	r3, #1
100015ea:	d105      	bne.n	100015f8 <PWMSP001_Init+0x34>
    {
      Error = PWMSP001_Start((PWMSP001_HandleType*) &PWMSP001_Handle0);
100015ec:	4b09      	ldr	r3, [pc, #36]	; (10001614 <PWMSP001_Init+0x50>)
100015ee:	1c18      	adds	r0, r3, #0
100015f0:	f000 fa34 	bl	10001a5c <PWMSP001_Start>
100015f4:	1c03      	adds	r3, r0, #0
100015f6:	607b      	str	r3, [r7, #4]
      DBG002_N(Error != DAVEApp_SUCCESS);
    }
  }
    
      PORT0->IOCR4  &= (uint32_t)(~(PORT_IOCR_PC1_PO_Msk));
100015f8:	4b07      	ldr	r3, [pc, #28]	; (10001618 <PWMSP001_Init+0x54>)
100015fa:	4a07      	ldr	r2, [pc, #28]	; (10001618 <PWMSP001_Init+0x54>)
100015fc:	6951      	ldr	r1, [r2, #20]
100015fe:	4a07      	ldr	r2, [pc, #28]	; (1000161c <PWMSP001_Init+0x58>)
10001600:	400a      	ands	r2, r1
10001602:	615a      	str	r2, [r3, #20]
      PORT0->IOCR4  |= (((uint32_t)0 << (uint32_t)PORT_IOCR_PC1_PO_Pos) & \
10001604:	4b04      	ldr	r3, [pc, #16]	; (10001618 <PWMSP001_Init+0x54>)
10001606:	4a04      	ldr	r2, [pc, #16]	; (10001618 <PWMSP001_Init+0x54>)
10001608:	6952      	ldr	r2, [r2, #20]
1000160a:	615a      	str	r2, [r3, #20]
                                   (uint32_t)PORT_IOCR_PC1_PO_Msk);
}
1000160c:	46bd      	mov	sp, r7
1000160e:	b002      	add	sp, #8
10001610:	bd80      	pop	{r7, pc}
10001612:	46c0      	nop			; (mov r8, r8)
10001614:	10003e80 	.word	0x10003e80
10001618:	40040000 	.word	0x40040000
1000161c:	ffffbfff 	.word	0xffffbfff

10001620 <PWMSP001_lInit>:

/*<<<DD_PWMSP001_API_1>>>*/
/* This function initializes an instance of the app */
status_t PWMSP001_lInit(const PWMSP001_HandleType* HandlePtr)
{
10001620:	b5b0      	push	{r4, r5, r7, lr}
10001622:	b084      	sub	sp, #16
10001624:	af00      	add	r7, sp, #0
10001626:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
10001628:	2301      	movs	r3, #1
1000162a:	60fb      	str	r3, [r7, #12]

  do
  {
    /*<<<DD_PWMSP001_API_1_1>>>*/
    if (HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED)
1000162c:	687b      	ldr	r3, [r7, #4]
1000162e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10001630:	781b      	ldrb	r3, [r3, #0]
10001632:	2b00      	cmp	r3, #0
10001634:	d000      	beq.n	10001638 <PWMSP001_lInit+0x18>
10001636:	e156      	b.n	100018e6 <PWMSP001_lInit+0x2c6>
    {
      break;
    }
    HandlePtr->CC4yRegsPtr->TCCLR = PWMSP001_SLICE_CLEAR;
10001638:	687b      	ldr	r3, [r7, #4]
1000163a:	699b      	ldr	r3, [r3, #24]
1000163c:	2207      	movs	r2, #7
1000163e:	611a      	str	r2, [r3, #16]

    /*<<<DD_PWMSP001_API_1_3>>>*/
    /* If external stop trigger is setelected */
    if (HandlePtr->kExtStopTrig == (uint8_t)SET)
10001640:	687b      	ldr	r3, [r7, #4]
10001642:	7bdb      	ldrb	r3, [r3, #15]
10001644:	2b01      	cmp	r3, #1
10001646:	d125      	bne.n	10001694 <PWMSP001_lInit+0x74>
    {
      HandlePtr->CC4yRegsPtr->INS &= (uint32_t)~((uint32_t)CCU4_CC4_INS_EV1EM_Msk | CCU4_CC4_INS_LPF1M_Msk);
10001648:	687b      	ldr	r3, [r7, #4]
1000164a:	699b      	ldr	r3, [r3, #24]
1000164c:	687a      	ldr	r2, [r7, #4]
1000164e:	6992      	ldr	r2, [r2, #24]
10001650:	6811      	ldr	r1, [r2, #0]
10001652:	4aa8      	ldr	r2, [pc, #672]	; (100018f4 <PWMSP001_lInit+0x2d4>)
10001654:	400a      	ands	r2, r1
10001656:	601a      	str	r2, [r3, #0]
      HandlePtr->CC4yRegsPtr->CMC &= (uint32_t)~CCU4_CC4_CMC_ENDS_Msk;
10001658:	687b      	ldr	r3, [r7, #4]
1000165a:	699b      	ldr	r3, [r3, #24]
1000165c:	687a      	ldr	r2, [r7, #4]
1000165e:	6992      	ldr	r2, [r2, #24]
10001660:	6852      	ldr	r2, [r2, #4]
10001662:	210c      	movs	r1, #12
10001664:	438a      	bics	r2, r1
10001666:	605a      	str	r2, [r3, #4]
      HandlePtr->CC4yRegsPtr->INS |= ((((uint32_t)HandlePtr->kStopEdge << (uint32_t)CCU4_CC4_INS_EV1EM_Pos)\
10001668:	687b      	ldr	r3, [r7, #4]
1000166a:	699b      	ldr	r3, [r3, #24]
1000166c:	687a      	ldr	r2, [r7, #4]
1000166e:	6992      	ldr	r2, [r2, #24]
10001670:	6811      	ldr	r1, [r2, #0]
10001672:	6878      	ldr	r0, [r7, #4]
10001674:	2224      	movs	r2, #36	; 0x24
10001676:	5c82      	ldrb	r2, [r0, r2]
10001678:	0490      	lsls	r0, r2, #18
	    & (uint32_t)CCU4_CC4_INS_EV1EM_Msk)| (((uint32_t)PWMSP001_LPF  << (uint32_t)CCU4_CC4_INS_LPF1M_Pos)\
1000167a:	22c0      	movs	r2, #192	; 0xc0
1000167c:	0312      	lsls	r2, r2, #12
1000167e:	4002      	ands	r2, r0
    /* If external stop trigger is setelected */
    if (HandlePtr->kExtStopTrig == (uint8_t)SET)
    {
      HandlePtr->CC4yRegsPtr->INS &= (uint32_t)~((uint32_t)CCU4_CC4_INS_EV1EM_Msk | CCU4_CC4_INS_LPF1M_Msk);
      HandlePtr->CC4yRegsPtr->CMC &= (uint32_t)~CCU4_CC4_CMC_ENDS_Msk;
      HandlePtr->CC4yRegsPtr->INS |= ((((uint32_t)HandlePtr->kStopEdge << (uint32_t)CCU4_CC4_INS_EV1EM_Pos)\
10001680:	430a      	orrs	r2, r1
10001682:	601a      	str	r2, [r3, #0]
	    & (uint32_t)CCU4_CC4_INS_EV1EM_Msk)| (((uint32_t)PWMSP001_LPF  << (uint32_t)CCU4_CC4_INS_LPF1M_Pos)\
		  & (uint32_t)CCU4_CC4_INS_LPF1M_Msk));

      HandlePtr->CC4yRegsPtr->CMC |= (((uint32_t)PWMSP001_EVENT_1  <<
10001684:	687b      	ldr	r3, [r7, #4]
10001686:	699b      	ldr	r3, [r3, #24]
10001688:	687a      	ldr	r2, [r7, #4]
1000168a:	6992      	ldr	r2, [r2, #24]
1000168c:	6852      	ldr	r2, [r2, #4]
1000168e:	2108      	movs	r1, #8
10001690:	430a      	orrs	r2, r1
10001692:	605a      	str	r2, [r3, #4]
          (uint32_t)CCU4_CC4_CMC_ENDS_Pos)& (uint32_t)CCU4_CC4_CMC_ENDS_Msk);
    }/*End of if (HandlePtr->kExtStopTrig == SET)*/

    /*<<<DD_PWMSP001_API_1_4>>>*/
    /* Trap configurations if trap is enabled */
    if ((HandlePtr->kTrapEnable == (uint8_t)SET) &&\
10001694:	687b      	ldr	r3, [r7, #4]
10001696:	7c5b      	ldrb	r3, [r3, #17]
10001698:	2b01      	cmp	r3, #1
1000169a:	d12a      	bne.n	100016f2 <PWMSP001_lInit+0xd2>
        ((HandlePtr->kTimerConcatenation != (uint8_t)SET))
1000169c:	687a      	ldr	r2, [r7, #4]
1000169e:	2320      	movs	r3, #32
100016a0:	5cd3      	ldrb	r3, [r2, r3]
          (uint32_t)CCU4_CC4_CMC_ENDS_Pos)& (uint32_t)CCU4_CC4_CMC_ENDS_Msk);
    }/*End of if (HandlePtr->kExtStopTrig == SET)*/

    /*<<<DD_PWMSP001_API_1_4>>>*/
    /* Trap configurations if trap is enabled */
    if ((HandlePtr->kTrapEnable == (uint8_t)SET) &&\
100016a2:	2b01      	cmp	r3, #1
100016a4:	d025      	beq.n	100016f2 <PWMSP001_lInit+0xd2>
        ((HandlePtr->kTimerConcatenation != (uint8_t)SET))
    )
    {
      HandlePtr->CC4yRegsPtr -> INS &= ~((uint32_t)CCU4_CC4_INS_EV2EM_Msk | \
100016a6:	687b      	ldr	r3, [r7, #4]
100016a8:	699b      	ldr	r3, [r3, #24]
100016aa:	687a      	ldr	r2, [r7, #4]
100016ac:	6992      	ldr	r2, [r2, #24]
100016ae:	6811      	ldr	r1, [r2, #0]
100016b0:	4a91      	ldr	r2, [pc, #580]	; (100018f8 <PWMSP001_lInit+0x2d8>)
100016b2:	400a      	ands	r2, r1
100016b4:	601a      	str	r2, [r3, #0]
	    (uint32_t)CCU4_CC4_INS_EV2LM_Msk | (uint32_t)CCU4_CC4_INS_LPF2M_Msk);
      HandlePtr->CC4yRegsPtr->CMC &= (uint32_t)~CCU4_CC4_CMC_TS_Msk;
100016b6:	687b      	ldr	r3, [r7, #4]
100016b8:	699b      	ldr	r3, [r3, #24]
100016ba:	687a      	ldr	r2, [r7, #4]
100016bc:	6992      	ldr	r2, [r2, #24]
100016be:	6851      	ldr	r1, [r2, #4]
100016c0:	4a8e      	ldr	r2, [pc, #568]	; (100018fc <PWMSP001_lInit+0x2dc>)
100016c2:	400a      	ands	r2, r1
100016c4:	605a      	str	r2, [r3, #4]
      HandlePtr->CC4yRegsPtr -> INS |= ((((uint32_t)0 << (uint32_t)CCU4_CC4_INS_EV2EM_Pos)\
100016c6:	687b      	ldr	r3, [r7, #4]
100016c8:	699b      	ldr	r3, [r3, #24]
100016ca:	687a      	ldr	r2, [r7, #4]
100016cc:	6992      	ldr	r2, [r2, #24]
100016ce:	6811      	ldr	r1, [r2, #0]
	    &(uint32_t)CCU4_CC4_INS_EV2EM_Msk) | (((uint32_t)HandlePtr->kTrapLevel  <<	\
100016d0:	687a      	ldr	r2, [r7, #4]
100016d2:	7812      	ldrb	r2, [r2, #0]
100016d4:	0610      	lsls	r0, r2, #24
		  (uint32_t)CCU4_CC4_INS_EV2LM_Pos)& (uint32_t)CCU4_CC4_INS_EV2LM_Msk ) | \
100016d6:	2280      	movs	r2, #128	; 0x80
100016d8:	0452      	lsls	r2, r2, #17
100016da:	4002      	ands	r2, r0
    )
    {
      HandlePtr->CC4yRegsPtr -> INS &= ~((uint32_t)CCU4_CC4_INS_EV2EM_Msk | \
	    (uint32_t)CCU4_CC4_INS_EV2LM_Msk | (uint32_t)CCU4_CC4_INS_LPF2M_Msk);
      HandlePtr->CC4yRegsPtr->CMC &= (uint32_t)~CCU4_CC4_CMC_TS_Msk;
      HandlePtr->CC4yRegsPtr -> INS |= ((((uint32_t)0 << (uint32_t)CCU4_CC4_INS_EV2EM_Pos)\
100016dc:	430a      	orrs	r2, r1
100016de:	601a      	str	r2, [r3, #0]
	    &(uint32_t)CCU4_CC4_INS_EV2EM_Msk) | (((uint32_t)HandlePtr->kTrapLevel  <<	\
		  (uint32_t)CCU4_CC4_INS_EV2LM_Pos)& (uint32_t)CCU4_CC4_INS_EV2LM_Msk ) | \
		    (((uint32_t)0 << (uint32_t)CCU4_CC4_INS_LPF2M_Pos)& \
			  (uint32_t)CCU4_CC4_INS_LPF2M_Msk));

      HandlePtr->CC4yRegsPtr->CMC |= ((uint32_t)1 << (uint32_t)CCU4_CC4_CMC_TS_Pos);
100016e0:	687b      	ldr	r3, [r7, #4]
100016e2:	699b      	ldr	r3, [r3, #24]
100016e4:	687a      	ldr	r2, [r7, #4]
100016e6:	6992      	ldr	r2, [r2, #24]
100016e8:	6852      	ldr	r2, [r2, #4]
100016ea:	2180      	movs	r1, #128	; 0x80
100016ec:	0289      	lsls	r1, r1, #10
100016ee:	430a      	orrs	r2, r1
100016f0:	605a      	str	r2, [r3, #4]
    }/* End of  if (HandlePtr->kTrapEnable == (uint8_t)SET)*/
    
    HandlePtr->CC4yRegsPtr->TC &= ~((uint32_t)CCU4_CC4_TC_TCM_Msk | \
100016f2:	687b      	ldr	r3, [r7, #4]
100016f4:	699b      	ldr	r3, [r3, #24]
100016f6:	687a      	ldr	r2, [r7, #4]
100016f8:	6992      	ldr	r2, [r2, #24]
100016fa:	6951      	ldr	r1, [r2, #20]
100016fc:	4a80      	ldr	r2, [pc, #512]	; (10001900 <PWMSP001_lInit+0x2e0>)
100016fe:	400a      	ands	r2, r1
10001700:	615a      	str	r2, [r3, #20]
	   (uint32_t)CCU4_CC4_TC_CMOD_Msk | (uint32_t)CCU4_CC4_TC_STRM_Msk | \
	   (uint32_t)CCU4_CC4_TC_ENDM_Msk | (uint32_t)CCU4_CC4_TC_DITHE_Msk);
    
    HandlePtr->CC4yRegsPtr->TC |= (((uint32_t)HandlePtr->CountingModeType << \
10001702:	687b      	ldr	r3, [r7, #4]
10001704:	699b      	ldr	r3, [r3, #24]
10001706:	687a      	ldr	r2, [r7, #4]
10001708:	6992      	ldr	r2, [r2, #24]
1000170a:	6951      	ldr	r1, [r2, #20]
1000170c:	6878      	ldr	r0, [r7, #4]
1000170e:	2236      	movs	r2, #54	; 0x36
10001710:	5c82      	ldrb	r2, [r0, r2]
10001712:	1c10      	adds	r0, r2, #0
	  (uint32_t)CCU4_CC4_TC_TCM_Pos)& (uint32_t)CCU4_CC4_TC_TCM_Msk)|\
10001714:	2201      	movs	r2, #1
10001716:	4010      	ands	r0, r2
		  (((uint32_t)PWMSP001_COMPARE_MODE  << \
		    (uint32_t)CCU4_CC4_TC_CMOD_Pos)& (uint32_t)CCU4_CC4_TC_CMOD_Msk)| \
			  (((uint32_t)HandlePtr->ExtStartConfigType  << (uint32_t)CCU4_CC4_TC_STRM_Pos)\
10001718:	687c      	ldr	r4, [r7, #4]
1000171a:	2234      	movs	r2, #52	; 0x34
1000171c:	5ca2      	ldrb	r2, [r4, r2]
1000171e:	0294      	lsls	r4, r2, #10
			    &(uint32_t)CCU4_CC4_TC_STRM_Msk)|(((uint32_t)HandlePtr->ExtStopConfigType <<\
10001720:	2280      	movs	r2, #128	; 0x80
10001722:	00d2      	lsls	r2, r2, #3
10001724:	4022      	ands	r2, r4
	   (uint32_t)CCU4_CC4_TC_ENDM_Msk | (uint32_t)CCU4_CC4_TC_DITHE_Msk);
    
    HandlePtr->CC4yRegsPtr->TC |= (((uint32_t)HandlePtr->CountingModeType << \
	  (uint32_t)CCU4_CC4_TC_TCM_Pos)& (uint32_t)CCU4_CC4_TC_TCM_Msk)|\
		  (((uint32_t)PWMSP001_COMPARE_MODE  << \
		    (uint32_t)CCU4_CC4_TC_CMOD_Pos)& (uint32_t)CCU4_CC4_TC_CMOD_Msk)| \
10001726:	4310      	orrs	r0, r2
			  (((uint32_t)HandlePtr->ExtStartConfigType  << (uint32_t)CCU4_CC4_TC_STRM_Pos)\
			    &(uint32_t)CCU4_CC4_TC_STRM_Msk)|(((uint32_t)HandlePtr->ExtStopConfigType <<\
10001728:	687c      	ldr	r4, [r7, #4]
1000172a:	2235      	movs	r2, #53	; 0x35
1000172c:	5ca2      	ldrb	r2, [r4, r2]
1000172e:	0214      	lsls	r4, r2, #8
				  (uint32_t)CCU4_CC4_TC_ENDM_Pos)& (uint32_t)CCU4_CC4_TC_ENDM_Msk);
10001730:	22c0      	movs	r2, #192	; 0xc0
10001732:	0092      	lsls	r2, r2, #2
10001734:	4022      	ands	r2, r4
    HandlePtr->CC4yRegsPtr->TC |= (((uint32_t)HandlePtr->CountingModeType << \
	  (uint32_t)CCU4_CC4_TC_TCM_Pos)& (uint32_t)CCU4_CC4_TC_TCM_Msk)|\
		  (((uint32_t)PWMSP001_COMPARE_MODE  << \
		    (uint32_t)CCU4_CC4_TC_CMOD_Pos)& (uint32_t)CCU4_CC4_TC_CMOD_Msk)| \
			  (((uint32_t)HandlePtr->ExtStartConfigType  << (uint32_t)CCU4_CC4_TC_STRM_Pos)\
			    &(uint32_t)CCU4_CC4_TC_STRM_Msk)|(((uint32_t)HandlePtr->ExtStopConfigType <<\
10001736:	4302      	orrs	r2, r0
    
    HandlePtr->CC4yRegsPtr->TC &= ~((uint32_t)CCU4_CC4_TC_TCM_Msk | \
	   (uint32_t)CCU4_CC4_TC_CMOD_Msk | (uint32_t)CCU4_CC4_TC_STRM_Msk | \
	   (uint32_t)CCU4_CC4_TC_ENDM_Msk | (uint32_t)CCU4_CC4_TC_DITHE_Msk);
    
    HandlePtr->CC4yRegsPtr->TC |= (((uint32_t)HandlePtr->CountingModeType << \
10001738:	430a      	orrs	r2, r1
1000173a:	615a      	str	r2, [r3, #20]
				  (uint32_t)CCU4_CC4_TC_ENDM_Pos)& (uint32_t)CCU4_CC4_TC_ENDM_Msk);
    /*
     * If timer concatenation is enabled during single shot mode lower timer 
     * should be free running
     */
	if (HandlePtr->kTimerConcatenation != (uint8_t)SET)
1000173c:	687a      	ldr	r2, [r7, #4]
1000173e:	2320      	movs	r3, #32
10001740:	5cd3      	ldrb	r3, [r2, r3]
10001742:	2b01      	cmp	r3, #1
10001744:	d00d      	beq.n	10001762 <PWMSP001_lInit+0x142>
	{
		WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TSSM_Msk, \
10001746:	687b      	ldr	r3, [r7, #4]
10001748:	699b      	ldr	r3, [r3, #24]
1000174a:	687a      	ldr	r2, [r7, #4]
1000174c:	7b12      	ldrb	r2, [r2, #12]
1000174e:	0051      	lsls	r1, r2, #1
10001750:	2202      	movs	r2, #2
10001752:	4011      	ands	r1, r2
10001754:	687a      	ldr	r2, [r7, #4]
10001756:	6992      	ldr	r2, [r2, #24]
10001758:	6952      	ldr	r2, [r2, #20]
1000175a:	2002      	movs	r0, #2
1000175c:	4382      	bics	r2, r0
1000175e:	430a      	orrs	r2, r1
10001760:	615a      	str	r2, [r3, #20]
			  		  (uint32_t)CCU4_CC4_TC_TSSM_Pos, HandlePtr->kTimerMode);
	} 
    
    /*Set the dither mode setting*/
    HandlePtr->CC4yRegsPtr->TC |= ((uint32_t)HandlePtr->kDitherSetting << \
10001762:	687b      	ldr	r3, [r7, #4]
10001764:	699b      	ldr	r3, [r3, #24]
10001766:	687a      	ldr	r2, [r7, #4]
10001768:	6992      	ldr	r2, [r2, #24]
1000176a:	6951      	ldr	r1, [r2, #20]
1000176c:	6878      	ldr	r0, [r7, #4]
1000176e:	2221      	movs	r2, #33	; 0x21
10001770:	5c82      	ldrb	r2, [r0, r2]
10001772:	0350      	lsls	r0, r2, #13
	  (uint32_t)CCU4_CC4_TC_DITHE_Pos) & (uint32_t)CCU4_CC4_TC_DITHE_Msk ;
10001774:	22c0      	movs	r2, #192	; 0xc0
10001776:	01d2      	lsls	r2, r2, #7
10001778:	4002      	ands	r2, r0
		WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TSSM_Msk, \
			  		  (uint32_t)CCU4_CC4_TC_TSSM_Pos, HandlePtr->kTimerMode);
	} 
    
    /*Set the dither mode setting*/
    HandlePtr->CC4yRegsPtr->TC |= ((uint32_t)HandlePtr->kDitherSetting << \
1000177a:	430a      	orrs	r2, r1
1000177c:	615a      	str	r2, [r3, #20]
	  (uint32_t)CCU4_CC4_TC_DITHE_Pos) & (uint32_t)CCU4_CC4_TC_DITHE_Msk ;
    
    WR_REG(HandlePtr->CC4yRegsPtr->DITS,(uint32_t)CCU4_CC4_DITS_DCVS_Msk,\
1000177e:	687b      	ldr	r3, [r7, #4]
10001780:	699b      	ldr	r3, [r3, #24]
10001782:	687a      	ldr	r2, [r7, #4]
10001784:	7b52      	ldrb	r2, [r2, #13]
10001786:	1c11      	adds	r1, r2, #0
10001788:	220f      	movs	r2, #15
1000178a:	4011      	ands	r1, r2
1000178c:	687a      	ldr	r2, [r7, #4]
1000178e:	6992      	ldr	r2, [r2, #24]
10001790:	6a12      	ldr	r2, [r2, #32]
10001792:	200f      	movs	r0, #15
10001794:	4382      	bics	r2, r0
10001796:	430a      	orrs	r2, r1
10001798:	621a      	str	r2, [r3, #32]
      (uint32_t)CCU4_CC4_DITS_DCVS_Pos, HandlePtr->kDitherCompare);

    /*Configure Trap mode as per GUI*/
    if(HandlePtr->kTimerConcatenation != (uint8_t)SET)
1000179a:	687a      	ldr	r2, [r7, #4]
1000179c:	2320      	movs	r3, #32
1000179e:	5cd3      	ldrb	r3, [r2, r3]
100017a0:	2b01      	cmp	r3, #1
100017a2:	d02c      	beq.n	100017fe <PWMSP001_lInit+0x1de>
    {
      /*<<<DD_PWMSP001_API_1_6>>>*/
      WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRPSE_Msk,
100017a4:	687b      	ldr	r3, [r7, #4]
100017a6:	699b      	ldr	r3, [r3, #24]
100017a8:	687a      	ldr	r2, [r7, #4]
100017aa:	7c92      	ldrb	r2, [r2, #18]
100017ac:	0551      	lsls	r1, r2, #21
100017ae:	2280      	movs	r2, #128	; 0x80
100017b0:	0392      	lsls	r2, r2, #14
100017b2:	4011      	ands	r1, r2
100017b4:	687a      	ldr	r2, [r7, #4]
100017b6:	6992      	ldr	r2, [r2, #24]
100017b8:	6950      	ldr	r0, [r2, #20]
100017ba:	4a52      	ldr	r2, [pc, #328]	; (10001904 <PWMSP001_lInit+0x2e4>)
100017bc:	4002      	ands	r2, r0
100017be:	430a      	orrs	r2, r1
100017c0:	615a      	str	r2, [r3, #20]
          (uint32_t)CCU4_CC4_TC_TRPSE_Pos, HandlePtr->kTrapSync);

      WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRPSW_Msk,
100017c2:	687b      	ldr	r3, [r7, #4]
100017c4:	699b      	ldr	r3, [r3, #24]
100017c6:	687a      	ldr	r2, [r7, #4]
100017c8:	7cd2      	ldrb	r2, [r2, #19]
100017ca:	0591      	lsls	r1, r2, #22
100017cc:	2280      	movs	r2, #128	; 0x80
100017ce:	03d2      	lsls	r2, r2, #15
100017d0:	4011      	ands	r1, r2
100017d2:	687a      	ldr	r2, [r7, #4]
100017d4:	6992      	ldr	r2, [r2, #24]
100017d6:	6950      	ldr	r0, [r2, #20]
100017d8:	4a4b      	ldr	r2, [pc, #300]	; (10001908 <PWMSP001_lInit+0x2e8>)
100017da:	4002      	ands	r2, r0
100017dc:	430a      	orrs	r2, r1
100017de:	615a      	str	r2, [r3, #20]
          (uint32_t)CCU4_CC4_TC_TRPSW_Pos, HandlePtr->kTrapExitControl);
      
	  WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRAPE_Msk, \
100017e0:	687b      	ldr	r3, [r7, #4]
100017e2:	699b      	ldr	r3, [r3, #24]
100017e4:	687a      	ldr	r2, [r7, #4]
100017e6:	7c52      	ldrb	r2, [r2, #17]
100017e8:	0451      	lsls	r1, r2, #17
100017ea:	2280      	movs	r2, #128	; 0x80
100017ec:	0292      	lsls	r2, r2, #10
100017ee:	4011      	ands	r1, r2
100017f0:	687a      	ldr	r2, [r7, #4]
100017f2:	6992      	ldr	r2, [r2, #24]
100017f4:	6950      	ldr	r0, [r2, #20]
100017f6:	4a41      	ldr	r2, [pc, #260]	; (100018fc <PWMSP001_lInit+0x2dc>)
100017f8:	4002      	ands	r2, r0
100017fa:	430a      	orrs	r2, r1
100017fc:	615a      	str	r2, [r3, #20]
		  (uint32_t)CCU4_CC4_TC_TRAPE_Pos, HandlePtr->kTrapEnable);
    }
    /*Set the prescalar divider and passive level of the o/p signal.*/
    WR_REG(HandlePtr->CC4yRegsPtr->PSC, (uint32_t)CCU4_CC4_PSC_PSIV_Msk,\
100017fe:	687b      	ldr	r3, [r7, #4]
10001800:	699b      	ldr	r3, [r3, #24]
10001802:	6879      	ldr	r1, [r7, #4]
10001804:	2222      	movs	r2, #34	; 0x22
10001806:	5c8a      	ldrb	r2, [r1, r2]
10001808:	1c11      	adds	r1, r2, #0
1000180a:	220f      	movs	r2, #15
1000180c:	4011      	ands	r1, r2
1000180e:	687a      	ldr	r2, [r7, #4]
10001810:	6992      	ldr	r2, [r2, #24]
10001812:	6a52      	ldr	r2, [r2, #36]	; 0x24
10001814:	200f      	movs	r0, #15
10001816:	4382      	bics	r2, r0
10001818:	430a      	orrs	r2, r1
1000181a:	625a      	str	r2, [r3, #36]	; 0x24
      (uint32_t)CCU4_CC4_PSC_PSIV_Pos, HandlePtr->kCCUPrescalar);
    HandlePtr->CC4yRegsPtr->PSL = HandlePtr->kPassiveLevel;
1000181c:	687b      	ldr	r3, [r7, #4]
1000181e:	699b      	ldr	r3, [r3, #24]
10001820:	687a      	ldr	r2, [r7, #4]
10001822:	7c12      	ldrb	r2, [r2, #16]
10001824:	619a      	str	r2, [r3, #24]

    /*<<<DD_PWMSP001_API_1_7>>>*/
    /*Setting period register's value*/
    HandlePtr->CC4yRegsPtr->PRS = (uint32_t)(HandlePtr->kPeriodVal & 0xFFFFU);
10001826:	687b      	ldr	r3, [r7, #4]
10001828:	699b      	ldr	r3, [r3, #24]
1000182a:	687a      	ldr	r2, [r7, #4]
1000182c:	6a92      	ldr	r2, [r2, #40]	; 0x28
1000182e:	0412      	lsls	r2, r2, #16
10001830:	0c12      	lsrs	r2, r2, #16
10001832:	635a      	str	r2, [r3, #52]	; 0x34
    /*Setting compare register's value*/
    HandlePtr->CC4yRegsPtr->CRS = (uint32_t)(HandlePtr->kCompareValue & 0xFFFFU);
10001834:	687b      	ldr	r3, [r7, #4]
10001836:	699b      	ldr	r3, [r3, #24]
10001838:	687a      	ldr	r2, [r7, #4]
1000183a:	6892      	ldr	r2, [r2, #8]
1000183c:	0412      	lsls	r2, r2, #16
1000183e:	0c12      	lsrs	r2, r2, #16
10001840:	63da      	str	r2, [r3, #60]	; 0x3c
    HandlePtr->CC4yRegsPtr->SWR |= PWMSP001_ALL_CCU4_INTR_CLEAR;
10001842:	687b      	ldr	r3, [r7, #4]
10001844:	699a      	ldr	r2, [r3, #24]
10001846:	687b      	ldr	r3, [r7, #4]
10001848:	6999      	ldr	r1, [r3, #24]
1000184a:	23b0      	movs	r3, #176	; 0xb0
1000184c:	58cb      	ldr	r3, [r1, r3]
1000184e:	492f      	ldr	r1, [pc, #188]	; (1000190c <PWMSP001_lInit+0x2ec>)
10001850:	4319      	orrs	r1, r3
10001852:	23b0      	movs	r3, #176	; 0xb0
10001854:	50d1      	str	r1, [r2, r3]

    /*Applying register's settings for the second slice if timer concatenation
     * is set */
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
10001856:	687a      	ldr	r2, [r7, #4]
10001858:	2320      	movs	r3, #32
1000185a:	5cd3      	ldrb	r3, [r2, r3]
1000185c:	2b01      	cmp	r3, #1
1000185e:	d10f      	bne.n	10001880 <PWMSP001_lInit+0x260>
    {
      PWMSP001_lConfigureSecondSlice(HandlePtr);
10001860:	687b      	ldr	r3, [r7, #4]
10001862:	1c18      	adds	r0, r3, #0
10001864:	f000 ff98 	bl	10002798 <PWMSP001_lConfigureSecondSlice>
      HandlePtr->CC4yRegs1Ptr->INTE |= HandlePtr->InterruptControl;
10001868:	687b      	ldr	r3, [r7, #4]
1000186a:	69da      	ldr	r2, [r3, #28]
1000186c:	687b      	ldr	r3, [r7, #4]
1000186e:	69d9      	ldr	r1, [r3, #28]
10001870:	23a4      	movs	r3, #164	; 0xa4
10001872:	58c9      	ldr	r1, [r1, r3]
10001874:	687b      	ldr	r3, [r7, #4]
10001876:	6b1b      	ldr	r3, [r3, #48]	; 0x30
10001878:	4319      	orrs	r1, r3
1000187a:	23a4      	movs	r3, #164	; 0xa4
1000187c:	50d1      	str	r1, [r2, r3]
1000187e:	e00a      	b.n	10001896 <PWMSP001_lInit+0x276>

    } /*End of if (HandlePtr->kTimerConcatenation == SET)*/
    else
    {
      HandlePtr->CC4yRegsPtr->INTE |= HandlePtr->InterruptControl;
10001880:	687b      	ldr	r3, [r7, #4]
10001882:	699a      	ldr	r2, [r3, #24]
10001884:	687b      	ldr	r3, [r7, #4]
10001886:	6999      	ldr	r1, [r3, #24]
10001888:	23a4      	movs	r3, #164	; 0xa4
1000188a:	58c9      	ldr	r1, [r1, r3]
1000188c:	687b      	ldr	r3, [r7, #4]
1000188e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
10001890:	4319      	orrs	r1, r3
10001892:	23a4      	movs	r3, #164	; 0xa4
10001894:	50d1      	str	r1, [r2, r3]
    }
    
    
    /*Request SW shadow transfer for period, compare, dither and prescalar level*/
    HandlePtr->CC4yKernRegsPtr->GCSS |= (((uint32_t)1 << ((uint32_t)4 * \
10001896:	687b      	ldr	r3, [r7, #4]
10001898:	695b      	ldr	r3, [r3, #20]
1000189a:	687a      	ldr	r2, [r7, #4]
1000189c:	6952      	ldr	r2, [r2, #20]
1000189e:	6911      	ldr	r1, [r2, #16]
	  (uint32_t)HandlePtr->FirstSlice)) | ((uint32_t)1 <<(((uint32_t)4 * \
100018a0:	6878      	ldr	r0, [r7, #4]
100018a2:	2237      	movs	r2, #55	; 0x37
100018a4:	5c82      	ldrb	r2, [r0, r2]
      HandlePtr->CC4yRegsPtr->INTE |= HandlePtr->InterruptControl;
    }
    
    
    /*Request SW shadow transfer for period, compare, dither and prescalar level*/
    HandlePtr->CC4yKernRegsPtr->GCSS |= (((uint32_t)1 << ((uint32_t)4 * \
100018a6:	0092      	lsls	r2, r2, #2
100018a8:	2001      	movs	r0, #1
100018aa:	4090      	lsls	r0, r2
	  (uint32_t)HandlePtr->FirstSlice)) | ((uint32_t)1 <<(((uint32_t)4 * \
	    (uint32_t)HandlePtr->FirstSlice) + (uint32_t)1))| ((uint32_t)1 << \
100018ac:	687c      	ldr	r4, [r7, #4]
100018ae:	2237      	movs	r2, #55	; 0x37
100018b0:	5ca2      	ldrb	r2, [r4, r2]
    }
    
    
    /*Request SW shadow transfer for period, compare, dither and prescalar level*/
    HandlePtr->CC4yKernRegsPtr->GCSS |= (((uint32_t)1 << ((uint32_t)4 * \
	  (uint32_t)HandlePtr->FirstSlice)) | ((uint32_t)1 <<(((uint32_t)4 * \
100018b2:	0092      	lsls	r2, r2, #2
	    (uint32_t)HandlePtr->FirstSlice) + (uint32_t)1))| ((uint32_t)1 << \
100018b4:	3201      	adds	r2, #1
    }
    
    
    /*Request SW shadow transfer for period, compare, dither and prescalar level*/
    HandlePtr->CC4yKernRegsPtr->GCSS |= (((uint32_t)1 << ((uint32_t)4 * \
	  (uint32_t)HandlePtr->FirstSlice)) | ((uint32_t)1 <<(((uint32_t)4 * \
100018b6:	2401      	movs	r4, #1
100018b8:	1c25      	adds	r5, r4, #0
100018ba:	4095      	lsls	r5, r2
100018bc:	1c2a      	adds	r2, r5, #0
100018be:	4310      	orrs	r0, r2
	    (uint32_t)HandlePtr->FirstSlice) + (uint32_t)1))| ((uint32_t)1 << \
		  (((uint32_t)4 * (uint32_t)HandlePtr->FirstSlice) + (uint32_t)2)));
100018c0:	687c      	ldr	r4, [r7, #4]
100018c2:	2237      	movs	r2, #55	; 0x37
100018c4:	5ca2      	ldrb	r2, [r4, r2]
100018c6:	0092      	lsls	r2, r2, #2
100018c8:	3202      	adds	r2, #2
    
    
    /*Request SW shadow transfer for period, compare, dither and prescalar level*/
    HandlePtr->CC4yKernRegsPtr->GCSS |= (((uint32_t)1 << ((uint32_t)4 * \
	  (uint32_t)HandlePtr->FirstSlice)) | ((uint32_t)1 <<(((uint32_t)4 * \
	    (uint32_t)HandlePtr->FirstSlice) + (uint32_t)1))| ((uint32_t)1 << \
100018ca:	2401      	movs	r4, #1
100018cc:	1c25      	adds	r5, r4, #0
100018ce:	4095      	lsls	r5, r2
100018d0:	1c2a      	adds	r2, r5, #0
100018d2:	4302      	orrs	r2, r0
      HandlePtr->CC4yRegsPtr->INTE |= HandlePtr->InterruptControl;
    }
    
    
    /*Request SW shadow transfer for period, compare, dither and prescalar level*/
    HandlePtr->CC4yKernRegsPtr->GCSS |= (((uint32_t)1 << ((uint32_t)4 * \
100018d4:	430a      	orrs	r2, r1
100018d6:	611a      	str	r2, [r3, #16]
	  (uint32_t)HandlePtr->FirstSlice)) | ((uint32_t)1 <<(((uint32_t)4 * \
	    (uint32_t)HandlePtr->FirstSlice) + (uint32_t)1))| ((uint32_t)1 << \
		  (((uint32_t)4 * (uint32_t)HandlePtr->FirstSlice) + (uint32_t)2)));

    Status = (uint32_t)DAVEApp_SUCCESS;
100018d8:	2300      	movs	r3, #0
100018da:	60fb      	str	r3, [r7, #12]
    HandlePtr->DynamicDataType->StateType = PWMSP001_INITIALIZED;
100018dc:	687b      	ldr	r3, [r7, #4]
100018de:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100018e0:	2201      	movs	r2, #1
100018e2:	701a      	strb	r2, [r3, #0]
100018e4:	e000      	b.n	100018e8 <PWMSP001_lInit+0x2c8>
  do
  {
    /*<<<DD_PWMSP001_API_1_1>>>*/
    if (HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED)
    {
      break;
100018e6:	46c0      	nop			; (mov r8, r8)

  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  return Status;
100018e8:	68fb      	ldr	r3, [r7, #12]
}
100018ea:	1c18      	adds	r0, r3, #0
100018ec:	46bd      	mov	sp, r7
100018ee:	b004      	add	sp, #16
100018f0:	bdb0      	pop	{r4, r5, r7, pc}
100018f2:	46c0      	nop			; (mov r8, r8)
100018f4:	e7f3ffff 	.word	0xe7f3ffff
100018f8:	9ecfffff 	.word	0x9ecfffff
100018fc:	fffdffff 	.word	0xfffdffff
10001900:	ffff98f6 	.word	0xffff98f6
10001904:	ffdfffff 	.word	0xffdfffff
10001908:	ffbfffff 	.word	0xffbfffff
1000190c:	00000f0f 	.word	0x00000f0f

10001910 <PWMSP001_Deinit>:

/*<<<DD_PWMSP001_API_2>>>*/
/* This function de-initializes the app */
status_t PWMSP001_Deinit(const PWMSP001_HandleType* HandlePtr)
{
10001910:	b590      	push	{r4, r7, lr}
10001912:	b089      	sub	sp, #36	; 0x24
10001914:	af00      	add	r7, sp, #0
10001916:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
10001918:	2301      	movs	r3, #1
1000191a:	61fb      	str	r3, [r7, #28]
  uint32_t Temp2;
  uint32_t Temp3;
  uint32_t Temp4;

     /*<<<DD_PWMSP001_API_2_1>>>*/
    if (HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED)
1000191c:	687b      	ldr	r3, [r7, #4]
1000191e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10001920:	781b      	ldrb	r3, [r3, #0]
10001922:	2b00      	cmp	r3, #0
10001924:	d100      	bne.n	10001928 <PWMSP001_Deinit+0x18>
10001926:	e091      	b.n	10001a4c <PWMSP001_Deinit+0x13c>
    {
    /*<<<DD_PWMSP001_API_2_3>>>*/
    HandlePtr->CC4yRegsPtr->TCCLR = PWMSP001_SLICE_CLEAR;
10001928:	687b      	ldr	r3, [r7, #4]
1000192a:	699b      	ldr	r3, [r3, #24]
1000192c:	2207      	movs	r2, #7
1000192e:	611a      	str	r2, [r3, #16]
    HandlePtr->CC4yRegsPtr->SWR = PWMSP001_ALL_CCU4_INTR_CLEAR;
10001930:	687b      	ldr	r3, [r7, #4]
10001932:	699a      	ldr	r2, [r3, #24]
10001934:	23b0      	movs	r3, #176	; 0xb0
10001936:	4948      	ldr	r1, [pc, #288]	; (10001a58 <PWMSP001_Deinit+0x148>)
10001938:	50d1      	str	r1, [r2, r3]
    HandlePtr->CC4yRegsPtr->INTE = 0x00U;
1000193a:	687b      	ldr	r3, [r7, #4]
1000193c:	699a      	ldr	r2, [r3, #24]
1000193e:	23a4      	movs	r3, #164	; 0xa4
10001940:	2100      	movs	r1, #0
10001942:	50d1      	str	r1, [r2, r3]

    /*Set IDLE mode for selected slice*/
    HandlePtr->CC4yKernRegsPtr->GIDLS |= (((uint32_t)1<< ((uint32_t)CCU4_GIDLS_SS0I_Pos \
10001944:	687b      	ldr	r3, [r7, #4]
10001946:	695b      	ldr	r3, [r3, #20]
10001948:	687a      	ldr	r2, [r7, #4]
1000194a:	6952      	ldr	r2, [r2, #20]
1000194c:	6891      	ldr	r1, [r2, #8]
	  +(uint32_t)HandlePtr->FirstSlice)) | ((uint32_t)1 << (uint32_t)CCU4_GIDLS_CPRB_Pos)\
1000194e:	6878      	ldr	r0, [r7, #4]
10001950:	2237      	movs	r2, #55	; 0x37
10001952:	5c82      	ldrb	r2, [r0, r2]
    HandlePtr->CC4yRegsPtr->TCCLR = PWMSP001_SLICE_CLEAR;
    HandlePtr->CC4yRegsPtr->SWR = PWMSP001_ALL_CCU4_INTR_CLEAR;
    HandlePtr->CC4yRegsPtr->INTE = 0x00U;

    /*Set IDLE mode for selected slice*/
    HandlePtr->CC4yKernRegsPtr->GIDLS |= (((uint32_t)1<< ((uint32_t)CCU4_GIDLS_SS0I_Pos \
10001954:	2001      	movs	r0, #1
10001956:	1c04      	adds	r4, r0, #0
10001958:	4094      	lsls	r4, r2
1000195a:	1c22      	adds	r2, r4, #0
1000195c:	430a      	orrs	r2, r1
1000195e:	21c0      	movs	r1, #192	; 0xc0
10001960:	0089      	lsls	r1, r1, #2
10001962:	430a      	orrs	r2, r1
10001964:	609a      	str	r2, [r3, #8]
	  +(uint32_t)HandlePtr->FirstSlice)) | ((uint32_t)1 << (uint32_t)CCU4_GIDLS_CPRB_Pos)\
	    |((uint32_t)1 << (uint32_t)CCU4_GIDLS_PSIC_Pos));

    /*Clear all the registers*/
    HandlePtr->CC4yRegsPtr->INS = 0x00U;
10001966:	687b      	ldr	r3, [r7, #4]
10001968:	699b      	ldr	r3, [r3, #24]
1000196a:	2200      	movs	r2, #0
1000196c:	601a      	str	r2, [r3, #0]
    HandlePtr->CC4yRegsPtr->CMC = 0x00U;
1000196e:	687b      	ldr	r3, [r7, #4]
10001970:	699b      	ldr	r3, [r3, #24]
10001972:	2200      	movs	r2, #0
10001974:	605a      	str	r2, [r3, #4]
    HandlePtr->CC4yRegsPtr->TC = 0x00U;
10001976:	687b      	ldr	r3, [r7, #4]
10001978:	699b      	ldr	r3, [r3, #24]
1000197a:	2200      	movs	r2, #0
1000197c:	615a      	str	r2, [r3, #20]
    HandlePtr->CC4yRegsPtr->PSC = 0x00U;
1000197e:	687b      	ldr	r3, [r7, #4]
10001980:	699b      	ldr	r3, [r3, #24]
10001982:	2200      	movs	r2, #0
10001984:	625a      	str	r2, [r3, #36]	; 0x24
    HandlePtr->CC4yRegsPtr->PSL = 0x00U;
10001986:	687b      	ldr	r3, [r7, #4]
10001988:	699b      	ldr	r3, [r3, #24]
1000198a:	2200      	movs	r2, #0
1000198c:	619a      	str	r2, [r3, #24]
    HandlePtr->CC4yRegsPtr->DITS = 0x00U;
1000198e:	687b      	ldr	r3, [r7, #4]
10001990:	699b      	ldr	r3, [r3, #24]
10001992:	2200      	movs	r2, #0
10001994:	621a      	str	r2, [r3, #32]
    HandlePtr->CC4yRegsPtr->CRS = 0x00U;
10001996:	687b      	ldr	r3, [r7, #4]
10001998:	699b      	ldr	r3, [r3, #24]
1000199a:	2200      	movs	r2, #0
1000199c:	63da      	str	r2, [r3, #60]	; 0x3c
    HandlePtr->CC4yRegsPtr->PRS = 0x00U;
1000199e:	687b      	ldr	r3, [r7, #4]
100019a0:	699b      	ldr	r3, [r3, #24]
100019a2:	2200      	movs	r2, #0
100019a4:	635a      	str	r2, [r3, #52]	; 0x34

    /*<<<DD_PWMSP001_API_2_2>>>*/
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
100019a6:	687a      	ldr	r2, [r7, #4]
100019a8:	2320      	movs	r3, #32
100019aa:	5cd3      	ldrb	r3, [r2, r3]
100019ac:	2b01      	cmp	r3, #1
100019ae:	d147      	bne.n	10001a40 <PWMSP001_Deinit+0x130>
    {
      /*<<<DD_PWMSP001_API_2_3>>>*/
      HandlePtr->CC4yRegs1Ptr->TCCLR = PWMSP001_SLICE_CLEAR;
100019b0:	687b      	ldr	r3, [r7, #4]
100019b2:	69db      	ldr	r3, [r3, #28]
100019b4:	2207      	movs	r2, #7
100019b6:	611a      	str	r2, [r3, #16]
      HandlePtr->CC4yRegs1Ptr->SWR = PWMSP001_ALL_CCU4_INTR_CLEAR;
100019b8:	687b      	ldr	r3, [r7, #4]
100019ba:	69da      	ldr	r2, [r3, #28]
100019bc:	23b0      	movs	r3, #176	; 0xb0
100019be:	4926      	ldr	r1, [pc, #152]	; (10001a58 <PWMSP001_Deinit+0x148>)
100019c0:	50d1      	str	r1, [r2, r3]
      HandlePtr->CC4yRegs1Ptr->INTE = 0x00U;
100019c2:	687b      	ldr	r3, [r7, #4]
100019c4:	69da      	ldr	r2, [r3, #28]
100019c6:	23a4      	movs	r3, #164	; 0xa4
100019c8:	2100      	movs	r1, #0
100019ca:	50d1      	str	r1, [r2, r3]

      /*Set IDLE mode for selected slice*/
      Temp4 = ((uint32_t)0x01 << (uint32_t)CCU4_GIDLS_PSIC_Pos);
100019cc:	2380      	movs	r3, #128	; 0x80
100019ce:	009b      	lsls	r3, r3, #2
100019d0:	61bb      	str	r3, [r7, #24]
      Temp3 = ((uint32_t)0x01 << CCU4_GIDLS_CPRB_Pos);
100019d2:	2380      	movs	r3, #128	; 0x80
100019d4:	005b      	lsls	r3, r3, #1
100019d6:	617b      	str	r3, [r7, #20]
      Temp2 = ((uint32_t)CCU4_GIDLS_SS0I_Pos + (uint32_t)HandlePtr->SecondSlice);
100019d8:	687a      	ldr	r2, [r7, #4]
100019da:	2338      	movs	r3, #56	; 0x38
100019dc:	5cd3      	ldrb	r3, [r2, r3]
100019de:	613b      	str	r3, [r7, #16]
      Temp1 = Temp3 | Temp4;
100019e0:	697a      	ldr	r2, [r7, #20]
100019e2:	69bb      	ldr	r3, [r7, #24]
100019e4:	4313      	orrs	r3, r2
100019e6:	60fb      	str	r3, [r7, #12]
      HandlePtr->CC4yKernRegsPtr->GIDLS |= (uint32_t)(((uint32_t)0x01 << Temp2 ) | Temp1);
100019e8:	687b      	ldr	r3, [r7, #4]
100019ea:	695b      	ldr	r3, [r3, #20]
100019ec:	687a      	ldr	r2, [r7, #4]
100019ee:	6952      	ldr	r2, [r2, #20]
100019f0:	6891      	ldr	r1, [r2, #8]
100019f2:	693a      	ldr	r2, [r7, #16]
100019f4:	2001      	movs	r0, #1
100019f6:	4090      	lsls	r0, r2
100019f8:	68fa      	ldr	r2, [r7, #12]
100019fa:	4302      	orrs	r2, r0
100019fc:	430a      	orrs	r2, r1
100019fe:	609a      	str	r2, [r3, #8]
      /*   Temp3 | Temp4 ); */

      /*Clear all the registers*/
      HandlePtr->CC4yRegs1Ptr->INS = 0x00U;
10001a00:	687b      	ldr	r3, [r7, #4]
10001a02:	69db      	ldr	r3, [r3, #28]
10001a04:	2200      	movs	r2, #0
10001a06:	601a      	str	r2, [r3, #0]
      HandlePtr->CC4yRegs1Ptr->CMC = 0x00U;
10001a08:	687b      	ldr	r3, [r7, #4]
10001a0a:	69db      	ldr	r3, [r3, #28]
10001a0c:	2200      	movs	r2, #0
10001a0e:	605a      	str	r2, [r3, #4]
      HandlePtr->CC4yRegs1Ptr->TC = 0x00U;
10001a10:	687b      	ldr	r3, [r7, #4]
10001a12:	69db      	ldr	r3, [r3, #28]
10001a14:	2200      	movs	r2, #0
10001a16:	615a      	str	r2, [r3, #20]
      HandlePtr->CC4yRegs1Ptr->PSC = 0x00U;
10001a18:	687b      	ldr	r3, [r7, #4]
10001a1a:	69db      	ldr	r3, [r3, #28]
10001a1c:	2200      	movs	r2, #0
10001a1e:	625a      	str	r2, [r3, #36]	; 0x24
      HandlePtr->CC4yRegs1Ptr->PSL = 0x00U;
10001a20:	687b      	ldr	r3, [r7, #4]
10001a22:	69db      	ldr	r3, [r3, #28]
10001a24:	2200      	movs	r2, #0
10001a26:	619a      	str	r2, [r3, #24]
      HandlePtr->CC4yRegs1Ptr->DITS = 0x00U;
10001a28:	687b      	ldr	r3, [r7, #4]
10001a2a:	69db      	ldr	r3, [r3, #28]
10001a2c:	2200      	movs	r2, #0
10001a2e:	621a      	str	r2, [r3, #32]
      HandlePtr->CC4yRegs1Ptr->CRS = 0x00U;
10001a30:	687b      	ldr	r3, [r7, #4]
10001a32:	69db      	ldr	r3, [r3, #28]
10001a34:	2200      	movs	r2, #0
10001a36:	63da      	str	r2, [r3, #60]	; 0x3c
      HandlePtr->CC4yRegs1Ptr->PRS = 0x00U;
10001a38:	687b      	ldr	r3, [r7, #4]
10001a3a:	69db      	ldr	r3, [r3, #28]
10001a3c:	2200      	movs	r2, #0
10001a3e:	635a      	str	r2, [r3, #52]	; 0x34
    }/*End of if (HandlePtr->kTimerConcatenation == (uint8_t)SET)*/

    HandlePtr->DynamicDataType->StateType = PWMSP001_UNINITIALIZED;
10001a40:	687b      	ldr	r3, [r7, #4]
10001a42:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10001a44:	2200      	movs	r2, #0
10001a46:	701a      	strb	r2, [r3, #0]

    Status = (uint32_t)DAVEApp_SUCCESS;
10001a48:	2300      	movs	r3, #0
10001a4a:	61fb      	str	r3, [r7, #28]

  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  return Status;
10001a4c:	69fb      	ldr	r3, [r7, #28]
}
10001a4e:	1c18      	adds	r0, r3, #0
10001a50:	46bd      	mov	sp, r7
10001a52:	b009      	add	sp, #36	; 0x24
10001a54:	bd90      	pop	{r4, r7, pc}
10001a56:	46c0      	nop			; (mov r8, r8)
10001a58:	00000f0f 	.word	0x00000f0f

10001a5c <PWMSP001_Start>:

/*<<<DD_PWMSP001_API_3>>>*/
/* This function starts the app. 
 * This needs to be called even if external start is configured.*/
status_t PWMSP001_Start(const PWMSP001_HandleType* HandlePtr)
{
10001a5c:	b590      	push	{r4, r7, lr}
10001a5e:	b085      	sub	sp, #20
10001a60:	af00      	add	r7, sp, #0
10001a62:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
10001a64:	2301      	movs	r3, #1
10001a66:	60fb      	str	r3, [r7, #12]

  do
  {
    /*<<<DD_PWMSP001_API_3_1>>>*/
    if ((HandlePtr->DynamicDataType->StateType != PWMSP001_INITIALIZED) &&
10001a68:	687b      	ldr	r3, [r7, #4]
10001a6a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10001a6c:	781b      	ldrb	r3, [r3, #0]
10001a6e:	2b01      	cmp	r3, #1
10001a70:	d005      	beq.n	10001a7e <PWMSP001_Start+0x22>
        (HandlePtr->DynamicDataType->StateType != PWMSP001_STOPPED))
10001a72:	687b      	ldr	r3, [r7, #4]
10001a74:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10001a76:	781b      	ldrb	r3, [r3, #0]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;

  do
  {
    /*<<<DD_PWMSP001_API_3_1>>>*/
    if ((HandlePtr->DynamicDataType->StateType != PWMSP001_INITIALIZED) &&
10001a78:	2b03      	cmp	r3, #3
10001a7a:	d000      	beq.n	10001a7e <PWMSP001_Start+0x22>
10001a7c:	e09f      	b.n	10001bbe <PWMSP001_Start+0x162>
    {
      DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
      break;
    }

    HandlePtr->CC4yRegsPtr->SWR = PWMSP001_ALL_CCU4_INTR_CLEAR;
10001a7e:	687b      	ldr	r3, [r7, #4]
10001a80:	699a      	ldr	r2, [r3, #24]
10001a82:	23b0      	movs	r3, #176	; 0xb0
10001a84:	4951      	ldr	r1, [pc, #324]	; (10001bcc <PWMSP001_Start+0x170>)
10001a86:	50d1      	str	r1, [r2, r3]
    
    /*<<<DD_PWMSP001_API_3_2>>>*/
	HandlePtr->CC4yKernRegsPtr->GIDLC |=
10001a88:	687b      	ldr	r3, [r7, #4]
10001a8a:	695b      	ldr	r3, [r3, #20]
10001a8c:	687a      	ldr	r2, [r7, #4]
10001a8e:	6952      	ldr	r2, [r2, #20]
10001a90:	68d1      	ldr	r1, [r2, #12]
		(((uint32_t)1 << ((uint32_t)CCU4_GIDLC_CS0I_Pos + \
			(uint32_t)HandlePtr->FirstSlice)) );
10001a92:	6878      	ldr	r0, [r7, #4]
10001a94:	2237      	movs	r2, #55	; 0x37
10001a96:	5c82      	ldrb	r2, [r0, r2]

    HandlePtr->CC4yRegsPtr->SWR = PWMSP001_ALL_CCU4_INTR_CLEAR;
    
    /*<<<DD_PWMSP001_API_3_2>>>*/
	HandlePtr->CC4yKernRegsPtr->GIDLC |=
		(((uint32_t)1 << ((uint32_t)CCU4_GIDLC_CS0I_Pos + \
10001a98:	2001      	movs	r0, #1
10001a9a:	1c04      	adds	r4, r0, #0
10001a9c:	4094      	lsls	r4, r2
10001a9e:	1c22      	adds	r2, r4, #0
    }

    HandlePtr->CC4yRegsPtr->SWR = PWMSP001_ALL_CCU4_INTR_CLEAR;
    
    /*<<<DD_PWMSP001_API_3_2>>>*/
	HandlePtr->CC4yKernRegsPtr->GIDLC |=
10001aa0:	430a      	orrs	r2, r1
10001aa2:	60da      	str	r2, [r3, #12]
		(((uint32_t)1 << ((uint32_t)CCU4_GIDLC_CS0I_Pos + \
			(uint32_t)HandlePtr->FirstSlice)) );
	if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
10001aa4:	687a      	ldr	r2, [r7, #4]
10001aa6:	2320      	movs	r3, #32
10001aa8:	5cd3      	ldrb	r3, [r2, r3]
10001aaa:	2b01      	cmp	r3, #1
10001aac:	d10d      	bne.n	10001aca <PWMSP001_Start+0x6e>
	{
	  HandlePtr->CC4yKernRegsPtr->GIDLC |=
10001aae:	687b      	ldr	r3, [r7, #4]
10001ab0:	695b      	ldr	r3, [r3, #20]
10001ab2:	687a      	ldr	r2, [r7, #4]
10001ab4:	6952      	ldr	r2, [r2, #20]
10001ab6:	68d1      	ldr	r1, [r2, #12]
		  ((uint32_t)1 << ((uint32_t)CCU4_GIDLC_CS0I_Pos + \
			(uint32_t)HandlePtr->SecondSlice));
10001ab8:	6878      	ldr	r0, [r7, #4]
10001aba:	2238      	movs	r2, #56	; 0x38
10001abc:	5c82      	ldrb	r2, [r0, r2]
		(((uint32_t)1 << ((uint32_t)CCU4_GIDLC_CS0I_Pos + \
			(uint32_t)HandlePtr->FirstSlice)) );
	if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
	{
	  HandlePtr->CC4yKernRegsPtr->GIDLC |=
		  ((uint32_t)1 << ((uint32_t)CCU4_GIDLC_CS0I_Pos + \
10001abe:	2001      	movs	r0, #1
10001ac0:	1c04      	adds	r4, r0, #0
10001ac2:	4094      	lsls	r4, r2
10001ac4:	1c22      	adds	r2, r4, #0
	HandlePtr->CC4yKernRegsPtr->GIDLC |=
		(((uint32_t)1 << ((uint32_t)CCU4_GIDLC_CS0I_Pos + \
			(uint32_t)HandlePtr->FirstSlice)) );
	if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
	{
	  HandlePtr->CC4yKernRegsPtr->GIDLC |=
10001ac6:	430a      	orrs	r2, r1
10001ac8:	60da      	str	r2, [r3, #12]
		  ((uint32_t)1 << ((uint32_t)CCU4_GIDLC_CS0I_Pos + \
			(uint32_t)HandlePtr->SecondSlice));
	} /*End if (HandlePtr->kTimerConcatenation == SET)*/
	
    /*Set run bit of slices if external start is not configured*/
    if (HandlePtr->kExtStartTrig == (uint8_t)RESET)
10001aca:	687b      	ldr	r3, [r7, #4]
10001acc:	7b9b      	ldrb	r3, [r3, #14]
10001ace:	2b00      	cmp	r3, #0
10001ad0:	d115      	bne.n	10001afe <PWMSP001_Start+0xa2>
    {
      HandlePtr->CC4yRegsPtr->TCSET |= (uint32_t)1;
10001ad2:	687b      	ldr	r3, [r7, #4]
10001ad4:	699b      	ldr	r3, [r3, #24]
10001ad6:	687a      	ldr	r2, [r7, #4]
10001ad8:	6992      	ldr	r2, [r2, #24]
10001ada:	68d2      	ldr	r2, [r2, #12]
10001adc:	2101      	movs	r1, #1
10001ade:	430a      	orrs	r2, r1
10001ae0:	60da      	str	r2, [r3, #12]
      if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
10001ae2:	687a      	ldr	r2, [r7, #4]
10001ae4:	2320      	movs	r3, #32
10001ae6:	5cd3      	ldrb	r3, [r2, r3]
10001ae8:	2b01      	cmp	r3, #1
10001aea:	d161      	bne.n	10001bb0 <PWMSP001_Start+0x154>
      {
        HandlePtr->CC4yRegs1Ptr->TCSET |= (uint32_t)1;
10001aec:	687b      	ldr	r3, [r7, #4]
10001aee:	69db      	ldr	r3, [r3, #28]
10001af0:	687a      	ldr	r2, [r7, #4]
10001af2:	69d2      	ldr	r2, [r2, #28]
10001af4:	68d2      	ldr	r2, [r2, #12]
10001af6:	2101      	movs	r1, #1
10001af8:	430a      	orrs	r2, r1
10001afa:	60da      	str	r2, [r3, #12]
10001afc:	e058      	b.n	10001bb0 <PWMSP001_Start+0x154>
      }
    }/*End of  if (HandlePtr->kExtStartTrig == (uint8_t)RESET)*/
    else
    {
      /*<<<DD_PWMSP001_API_1_2>>>*/
      if (HandlePtr->kExtStartTrig == (uint8_t)SET)
10001afe:	687b      	ldr	r3, [r7, #4]
10001b00:	7b9b      	ldrb	r3, [r3, #14]
10001b02:	2b01      	cmp	r3, #1
10001b04:	d125      	bne.n	10001b52 <PWMSP001_Start+0xf6>
      {
        HandlePtr->CC4yRegsPtr->INS &= ~((uint32_t)CCU4_CC4_INS_EV0EM_Msk | \
10001b06:	687b      	ldr	r3, [r7, #4]
10001b08:	699b      	ldr	r3, [r3, #24]
10001b0a:	687a      	ldr	r2, [r7, #4]
10001b0c:	6992      	ldr	r2, [r2, #24]
10001b0e:	6811      	ldr	r1, [r2, #0]
10001b10:	4a2f      	ldr	r2, [pc, #188]	; (10001bd0 <PWMSP001_Start+0x174>)
10001b12:	400a      	ands	r2, r1
10001b14:	601a      	str	r2, [r3, #0]
		  (uint32_t)CCU4_CC4_INS_LPF0M_Msk);
        HandlePtr->CC4yRegsPtr->CMC &= ~(uint32_t)CCU4_CC4_CMC_STRTS_Msk;
10001b16:	687b      	ldr	r3, [r7, #4]
10001b18:	699b      	ldr	r3, [r3, #24]
10001b1a:	687a      	ldr	r2, [r7, #4]
10001b1c:	6992      	ldr	r2, [r2, #24]
10001b1e:	6852      	ldr	r2, [r2, #4]
10001b20:	2103      	movs	r1, #3
10001b22:	438a      	bics	r2, r1
10001b24:	605a      	str	r2, [r3, #4]
        HandlePtr->CC4yRegsPtr->INS |=
10001b26:	687b      	ldr	r3, [r7, #4]
10001b28:	699b      	ldr	r3, [r3, #24]
10001b2a:	687a      	ldr	r2, [r7, #4]
10001b2c:	6992      	ldr	r2, [r2, #24]
10001b2e:	6811      	ldr	r1, [r2, #0]
            ((((uint32_t)HandlePtr->kStartEdge  << (uint32_t)CCU4_CC4_INS_EV0EM_Pos)& \
10001b30:	6878      	ldr	r0, [r7, #4]
10001b32:	2223      	movs	r2, #35	; 0x23
10001b34:	5c82      	ldrb	r2, [r0, r2]
10001b36:	0410      	lsls	r0, r2, #16
			  (uint32_t)CCU4_CC4_INS_EV0EM_Msk) | (((uint32_t)PWMSP001_LPF   << \
10001b38:	22c0      	movs	r2, #192	; 0xc0
10001b3a:	0292      	lsls	r2, r2, #10
10001b3c:	4002      	ands	r2, r0
      if (HandlePtr->kExtStartTrig == (uint8_t)SET)
      {
        HandlePtr->CC4yRegsPtr->INS &= ~((uint32_t)CCU4_CC4_INS_EV0EM_Msk | \
		  (uint32_t)CCU4_CC4_INS_LPF0M_Msk);
        HandlePtr->CC4yRegsPtr->CMC &= ~(uint32_t)CCU4_CC4_CMC_STRTS_Msk;
        HandlePtr->CC4yRegsPtr->INS |=
10001b3e:	430a      	orrs	r2, r1
10001b40:	601a      	str	r2, [r3, #0]
            ((((uint32_t)HandlePtr->kStartEdge  << (uint32_t)CCU4_CC4_INS_EV0EM_Pos)& \
			  (uint32_t)CCU4_CC4_INS_EV0EM_Msk) | (((uint32_t)PWMSP001_LPF   << \
                (uint32_t)CCU4_CC4_INS_LPF0M_Pos)& (uint32_t)CCU4_CC4_INS_LPF0M_Msk));
        HandlePtr->CC4yRegsPtr->CMC |= (((uint32_t)PWMSP001_EVENT_0  <<
10001b42:	687b      	ldr	r3, [r7, #4]
10001b44:	699b      	ldr	r3, [r3, #24]
10001b46:	687a      	ldr	r2, [r7, #4]
10001b48:	6992      	ldr	r2, [r2, #24]
10001b4a:	6852      	ldr	r2, [r2, #4]
10001b4c:	2101      	movs	r1, #1
10001b4e:	430a      	orrs	r2, r1
10001b50:	605a      	str	r2, [r3, #4]
            (uint32_t)CCU4_CC4_CMC_STRTS_Pos)& (uint32_t)CCU4_CC4_CMC_STRTS_Msk);
      }/*End of if (HandlePtr->kExtStartTrig == (uint8_t)SET)*/
      /*<<<DD_PWMSP001_nonAPI_1_2>>>*/
      if ((HandlePtr->kExtStartTrig == (uint8_t)SET) &&\
10001b52:	687b      	ldr	r3, [r7, #4]
10001b54:	7b9b      	ldrb	r3, [r3, #14]
10001b56:	2b01      	cmp	r3, #1
10001b58:	d12a      	bne.n	10001bb0 <PWMSP001_Start+0x154>
          (HandlePtr->kTimerConcatenation == (uint8_t)SET)
10001b5a:	687a      	ldr	r2, [r7, #4]
10001b5c:	2320      	movs	r3, #32
10001b5e:	5cd3      	ldrb	r3, [r2, r3]
                (uint32_t)CCU4_CC4_INS_LPF0M_Pos)& (uint32_t)CCU4_CC4_INS_LPF0M_Msk));
        HandlePtr->CC4yRegsPtr->CMC |= (((uint32_t)PWMSP001_EVENT_0  <<
            (uint32_t)CCU4_CC4_CMC_STRTS_Pos)& (uint32_t)CCU4_CC4_CMC_STRTS_Msk);
      }/*End of if (HandlePtr->kExtStartTrig == (uint8_t)SET)*/
      /*<<<DD_PWMSP001_nonAPI_1_2>>>*/
      if ((HandlePtr->kExtStartTrig == (uint8_t)SET) &&\
10001b60:	2b01      	cmp	r3, #1
10001b62:	d125      	bne.n	10001bb0 <PWMSP001_Start+0x154>
          (HandlePtr->kTimerConcatenation == (uint8_t)SET)
      )
      {
        HandlePtr->CC4yRegs1Ptr->INS &= (uint32_t)~(CCU4_CC4_INS_EV0EM_Msk | CCU4_CC4_INS_LPF0M_Msk);
10001b64:	687b      	ldr	r3, [r7, #4]
10001b66:	69db      	ldr	r3, [r3, #28]
10001b68:	687a      	ldr	r2, [r7, #4]
10001b6a:	69d2      	ldr	r2, [r2, #28]
10001b6c:	6811      	ldr	r1, [r2, #0]
10001b6e:	4a18      	ldr	r2, [pc, #96]	; (10001bd0 <PWMSP001_Start+0x174>)
10001b70:	400a      	ands	r2, r1
10001b72:	601a      	str	r2, [r3, #0]
        HandlePtr->CC4yRegs1Ptr->CMC &= (uint32_t)~(CCU4_CC4_CMC_STRTS_Msk);
10001b74:	687b      	ldr	r3, [r7, #4]
10001b76:	69db      	ldr	r3, [r3, #28]
10001b78:	687a      	ldr	r2, [r7, #4]
10001b7a:	69d2      	ldr	r2, [r2, #28]
10001b7c:	6852      	ldr	r2, [r2, #4]
10001b7e:	2103      	movs	r1, #3
10001b80:	438a      	bics	r2, r1
10001b82:	605a      	str	r2, [r3, #4]
        HandlePtr->CC4yRegs1Ptr->INS |=
10001b84:	687b      	ldr	r3, [r7, #4]
10001b86:	69db      	ldr	r3, [r3, #28]
10001b88:	687a      	ldr	r2, [r7, #4]
10001b8a:	69d2      	ldr	r2, [r2, #28]
10001b8c:	6811      	ldr	r1, [r2, #0]
            ((((uint32_t)HandlePtr->kStartEdge  << (uint32_t)CCU4_CC4_INS_EV0EM_Pos)& \
10001b8e:	6878      	ldr	r0, [r7, #4]
10001b90:	2223      	movs	r2, #35	; 0x23
10001b92:	5c82      	ldrb	r2, [r0, r2]
10001b94:	0410      	lsls	r0, r2, #16
			  (uint32_t)CCU4_CC4_INS_EV0EM_Msk) | (((uint32_t)PWMSP001_LPF  <<
10001b96:	22c0      	movs	r2, #192	; 0xc0
10001b98:	0292      	lsls	r2, r2, #10
10001b9a:	4002      	ands	r2, r0
          (HandlePtr->kTimerConcatenation == (uint8_t)SET)
      )
      {
        HandlePtr->CC4yRegs1Ptr->INS &= (uint32_t)~(CCU4_CC4_INS_EV0EM_Msk | CCU4_CC4_INS_LPF0M_Msk);
        HandlePtr->CC4yRegs1Ptr->CMC &= (uint32_t)~(CCU4_CC4_CMC_STRTS_Msk);
        HandlePtr->CC4yRegs1Ptr->INS |=
10001b9c:	430a      	orrs	r2, r1
10001b9e:	601a      	str	r2, [r3, #0]
            ((((uint32_t)HandlePtr->kStartEdge  << (uint32_t)CCU4_CC4_INS_EV0EM_Pos)& \
			  (uint32_t)CCU4_CC4_INS_EV0EM_Msk) | (((uint32_t)PWMSP001_LPF  <<
                    (uint32_t)CCU4_CC4_INS_LPF0M_Pos)& (uint32_t)CCU4_CC4_INS_LPF0M_Msk));
        HandlePtr->CC4yRegs1Ptr->CMC |= (((uint32_t)PWMSP001_EVENT_0  << \
10001ba0:	687b      	ldr	r3, [r7, #4]
10001ba2:	69db      	ldr	r3, [r3, #28]
10001ba4:	687a      	ldr	r2, [r7, #4]
10001ba6:	69d2      	ldr	r2, [r2, #28]
10001ba8:	6852      	ldr	r2, [r2, #4]
10001baa:	2101      	movs	r1, #1
10001bac:	430a      	orrs	r2, r1
10001bae:	605a      	str	r2, [r3, #4]
		  (uint32_t)CCU4_CC4_CMC_STRTS_Pos) & (uint32_t)CCU4_CC4_CMC_STRTS_Msk);
      }/*End of if (HandlePtr->kExtStartTrig == SET)*/
    }

    HandlePtr->DynamicDataType->StateType = PWMSP001_RUNNING;
10001bb0:	687b      	ldr	r3, [r7, #4]
10001bb2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10001bb4:	2202      	movs	r2, #2
10001bb6:	701a      	strb	r2, [r3, #0]
    Status = (uint32_t)DAVEApp_SUCCESS;
10001bb8:	2300      	movs	r3, #0
10001bba:	60fb      	str	r3, [r7, #12]
10001bbc:	e000      	b.n	10001bc0 <PWMSP001_Start+0x164>
    /*<<<DD_PWMSP001_API_3_1>>>*/
    if ((HandlePtr->DynamicDataType->StateType != PWMSP001_INITIALIZED) &&
        (HandlePtr->DynamicDataType->StateType != PWMSP001_STOPPED))
    {
      DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
      break;
10001bbe:	46c0      	nop			; (mov r8, r8)
    }

    HandlePtr->DynamicDataType->StateType = PWMSP001_RUNNING;
    Status = (uint32_t)DAVEApp_SUCCESS;
  } while (0);
  return Status;
10001bc0:	68fb      	ldr	r3, [r7, #12]
}
10001bc2:	1c18      	adds	r0, r3, #0
10001bc4:	46bd      	mov	sp, r7
10001bc6:	b005      	add	sp, #20
10001bc8:	bd90      	pop	{r4, r7, pc}
10001bca:	46c0      	nop			; (mov r8, r8)
10001bcc:	00000f0f 	.word	0x00000f0f
10001bd0:	f9fcffff 	.word	0xf9fcffff

10001bd4 <PWMSP001_Stop>:

/*<<<DD_PWMSP001_API_4>>>*/
/* This function stops the app */
status_t PWMSP001_Stop(const PWMSP001_HandleType* HandlePtr)
{
10001bd4:	b580      	push	{r7, lr}
10001bd6:	b086      	sub	sp, #24
10001bd8:	af00      	add	r7, sp, #0
10001bda:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
10001bdc:	2301      	movs	r3, #1
10001bde:	617b      	str	r3, [r7, #20]
  uint32_t Temp2;
  
  do
  {
    /*<<<DD_PWMSP001_API_4_1>>>*/
    if (HandlePtr->DynamicDataType->StateType != PWMSP001_RUNNING)
10001be0:	687b      	ldr	r3, [r7, #4]
10001be2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10001be4:	781b      	ldrb	r3, [r3, #0]
10001be6:	2b02      	cmp	r3, #2
10001be8:	d139      	bne.n	10001c5e <PWMSP001_Stop+0x8a>
    {
      break;
    }
    else
    {
      Temp1 = ((uint32_t)CCU4_GIDLS_SS0I_Pos + (uint32_t)HandlePtr->FirstSlice);
10001bea:	687a      	ldr	r2, [r7, #4]
10001bec:	2337      	movs	r3, #55	; 0x37
10001bee:	5cd3      	ldrb	r3, [r2, r3]
10001bf0:	613b      	str	r3, [r7, #16]
      Temp2 = ((uint32_t)0x01 << CCU4_GIDLS_PSIC_Pos);
10001bf2:	2380      	movs	r3, #128	; 0x80
10001bf4:	009b      	lsls	r3, r3, #2
10001bf6:	60fb      	str	r3, [r7, #12]
      HandlePtr->CC4yRegsPtr->TCCLR = PWMSP001_SLICE_CLEAR;
10001bf8:	687b      	ldr	r3, [r7, #4]
10001bfa:	699b      	ldr	r3, [r3, #24]
10001bfc:	2207      	movs	r2, #7
10001bfe:	611a      	str	r2, [r3, #16]
      HandlePtr->CC4yKernRegsPtr->GIDLS |= (((uint32_t)0x01 << Temp1 ) | Temp2 );
10001c00:	687b      	ldr	r3, [r7, #4]
10001c02:	695b      	ldr	r3, [r3, #20]
10001c04:	687a      	ldr	r2, [r7, #4]
10001c06:	6952      	ldr	r2, [r2, #20]
10001c08:	6891      	ldr	r1, [r2, #8]
10001c0a:	693a      	ldr	r2, [r7, #16]
10001c0c:	2001      	movs	r0, #1
10001c0e:	4090      	lsls	r0, r2
10001c10:	68fa      	ldr	r2, [r7, #12]
10001c12:	4302      	orrs	r2, r0
10001c14:	430a      	orrs	r2, r1
10001c16:	609a      	str	r2, [r3, #8]

      if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
10001c18:	687a      	ldr	r2, [r7, #4]
10001c1a:	2320      	movs	r3, #32
10001c1c:	5cd3      	ldrb	r3, [r2, r3]
10001c1e:	2b01      	cmp	r3, #1
10001c20:	d116      	bne.n	10001c50 <PWMSP001_Stop+0x7c>
      {
        HandlePtr->CC4yRegs1Ptr->TCCLR = PWMSP001_SLICE_CLEAR;
10001c22:	687b      	ldr	r3, [r7, #4]
10001c24:	69db      	ldr	r3, [r3, #28]
10001c26:	2207      	movs	r2, #7
10001c28:	611a      	str	r2, [r3, #16]
        Temp1 = ((uint32_t)CCU4_GIDLS_SS0I_Pos + (uint32_t)HandlePtr->SecondSlice);
10001c2a:	687a      	ldr	r2, [r7, #4]
10001c2c:	2338      	movs	r3, #56	; 0x38
10001c2e:	5cd3      	ldrb	r3, [r2, r3]
10001c30:	613b      	str	r3, [r7, #16]
        Temp2 = ((uint32_t)0x01 << CCU4_GIDLS_PSIC_Pos);
10001c32:	2380      	movs	r3, #128	; 0x80
10001c34:	009b      	lsls	r3, r3, #2
10001c36:	60fb      	str	r3, [r7, #12]
        HandlePtr->CC4yKernRegsPtr->GIDLS |= (((uint32_t)0x01 << Temp1) | Temp2 );
10001c38:	687b      	ldr	r3, [r7, #4]
10001c3a:	695b      	ldr	r3, [r3, #20]
10001c3c:	687a      	ldr	r2, [r7, #4]
10001c3e:	6952      	ldr	r2, [r2, #20]
10001c40:	6891      	ldr	r1, [r2, #8]
10001c42:	693a      	ldr	r2, [r7, #16]
10001c44:	2001      	movs	r0, #1
10001c46:	4090      	lsls	r0, r2
10001c48:	68fa      	ldr	r2, [r7, #12]
10001c4a:	4302      	orrs	r2, r0
10001c4c:	430a      	orrs	r2, r1
10001c4e:	609a      	str	r2, [r3, #8]
      }/*End of  if (HandlePtr->kTimerConcatenation == (uint8_t)SET)*/

      HandlePtr->DynamicDataType->StateType = PWMSP001_STOPPED;
10001c50:	687b      	ldr	r3, [r7, #4]
10001c52:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10001c54:	2203      	movs	r2, #3
10001c56:	701a      	strb	r2, [r3, #0]
      Status = (uint32_t)DAVEApp_SUCCESS;
10001c58:	2300      	movs	r3, #0
10001c5a:	617b      	str	r3, [r7, #20]
10001c5c:	e000      	b.n	10001c60 <PWMSP001_Stop+0x8c>
  do
  {
    /*<<<DD_PWMSP001_API_4_1>>>*/
    if (HandlePtr->DynamicDataType->StateType != PWMSP001_RUNNING)
    {
      break;
10001c5e:	46c0      	nop			; (mov r8, r8)

  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  return Status;
10001c60:	697b      	ldr	r3, [r7, #20]
}
10001c62:	1c18      	adds	r0, r3, #0
10001c64:	46bd      	mov	sp, r7
10001c66:	b006      	add	sp, #24
10001c68:	bd80      	pop	{r7, pc}
10001c6a:	46c0      	nop			; (mov r8, r8)

10001c6c <PWMSP001_SetCompare>:
status_t PWMSP001_SetCompare
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t Compare
)
{
10001c6c:	b580      	push	{r7, lr}
10001c6e:	b084      	sub	sp, #16
10001c70:	af00      	add	r7, sp, #0
10001c72:	6078      	str	r0, [r7, #4]
10001c74:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
10001c76:	2301      	movs	r3, #1
10001c78:	60fb      	str	r3, [r7, #12]
  uint32_t period;

  if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
10001c7a:	687a      	ldr	r2, [r7, #4]
10001c7c:	2320      	movs	r3, #32
10001c7e:	5cd3      	ldrb	r3, [r2, r3]
10001c80:	2b01      	cmp	r3, #1
10001c82:	d109      	bne.n	10001c98 <PWMSP001_SetCompare+0x2c>
	  period=(uint32_t)(((uint32_t)HandlePtr->CC4yRegs1Ptr->PRS<<16U)|(uint32_t)HandlePtr->CC4yRegsPtr->PRS);
10001c84:	687b      	ldr	r3, [r7, #4]
10001c86:	69db      	ldr	r3, [r3, #28]
10001c88:	6b5b      	ldr	r3, [r3, #52]	; 0x34
10001c8a:	041a      	lsls	r2, r3, #16
10001c8c:	687b      	ldr	r3, [r7, #4]
10001c8e:	699b      	ldr	r3, [r3, #24]
10001c90:	6b5b      	ldr	r3, [r3, #52]	; 0x34
10001c92:	4313      	orrs	r3, r2
10001c94:	60bb      	str	r3, [r7, #8]
10001c96:	e003      	b.n	10001ca0 <PWMSP001_SetCompare+0x34>
  else
	  period=(uint32_t)HandlePtr->CC4yRegsPtr->PRS;
10001c98:	687b      	ldr	r3, [r7, #4]
10001c9a:	699b      	ldr	r3, [r3, #24]
10001c9c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
10001c9e:	60bb      	str	r3, [r7, #8]

  /*<<<DD_PWMSP001_API_5_1>>>*/
  if ( HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED)
10001ca0:	687b      	ldr	r3, [r7, #4]
10001ca2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10001ca4:	781b      	ldrb	r3, [r3, #0]
10001ca6:	2b00      	cmp	r3, #0
10001ca8:	d01c      	beq.n	10001ce4 <PWMSP001_SetCompare+0x78>
  {
    if ((Compare > (uint32_t)HandlePtr->kMaxPeriodVal) &&
10001caa:	687b      	ldr	r3, [r7, #4]
10001cac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10001cae:	683b      	ldr	r3, [r7, #0]
10001cb0:	429a      	cmp	r2, r3
10001cb2:	d207      	bcs.n	10001cc4 <PWMSP001_SetCompare+0x58>
        (HandlePtr->kTimerConcatenation == (uint8_t)RESET))
10001cb4:	687a      	ldr	r2, [r7, #4]
10001cb6:	2320      	movs	r3, #32
10001cb8:	5cd3      	ldrb	r3, [r2, r3]
	  period=(uint32_t)HandlePtr->CC4yRegsPtr->PRS;

  /*<<<DD_PWMSP001_API_5_1>>>*/
  if ( HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED)
  {
    if ((Compare > (uint32_t)HandlePtr->kMaxPeriodVal) &&
10001cba:	2b00      	cmp	r3, #0
10001cbc:	d102      	bne.n	10001cc4 <PWMSP001_SetCompare+0x58>
        (HandlePtr->kTimerConcatenation == (uint8_t)RESET))
    {
      Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
10001cbe:	2302      	movs	r3, #2
10001cc0:	60fb      	str	r3, [r7, #12]
10001cc2:	e00f      	b.n	10001ce4 <PWMSP001_SetCompare+0x78>
    }
    else
    {
      /*if compare value is greater or equal to the period value, output should be with 0% dutycycle.
	  Since setting exact period value will create the spikes,we are adding 1 and setting to the register*/
	  if (Compare >= (uint32_t)period)
10001cc4:	683a      	ldr	r2, [r7, #0]
10001cc6:	68bb      	ldr	r3, [r7, #8]
10001cc8:	429a      	cmp	r2, r3
10001cca:	d302      	bcc.n	10001cd2 <PWMSP001_SetCompare+0x66>
	  {
		  Compare = (uint32_t)period + 1U;
10001ccc:	68bb      	ldr	r3, [r7, #8]
10001cce:	3301      	adds	r3, #1
10001cd0:	603b      	str	r3, [r7, #0]
	  }
      /* Call function as per the configured mode */
      HandlePtr->SetCompareFuncPtr((const void*)HandlePtr, Compare);
10001cd2:	687b      	ldr	r3, [r7, #4]
10001cd4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10001cd6:	6879      	ldr	r1, [r7, #4]
10001cd8:	683a      	ldr	r2, [r7, #0]
10001cda:	1c08      	adds	r0, r1, #0
10001cdc:	1c11      	adds	r1, r2, #0
10001cde:	4798      	blx	r3
      Status = (uint32_t)DAVEApp_SUCCESS;
10001ce0:	2300      	movs	r3, #0
10001ce2:	60fb      	str	r3, [r7, #12]
    }
  }
  return Status;
10001ce4:	68fb      	ldr	r3, [r7, #12]
}
10001ce6:	1c18      	adds	r0, r3, #0
10001ce8:	46bd      	mov	sp, r7
10001cea:	b004      	add	sp, #16
10001cec:	bd80      	pop	{r7, pc}
10001cee:	46c0      	nop			; (mov r8, r8)

10001cf0 <PWMSP001_lSetCompareEdgeAlign>:
void PWMSP001_lSetCompareEdgeAlign
(
    void* Handle,
    uint32_t Compare
)
{
10001cf0:	b590      	push	{r4, r7, lr}
10001cf2:	b087      	sub	sp, #28
10001cf4:	af00      	add	r7, sp, #0
10001cf6:	6078      	str	r0, [r7, #4]
10001cf8:	6039      	str	r1, [r7, #0]
  uint32_t Temp1;
  uint32_t Temp2;
  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;
10001cfa:	687b      	ldr	r3, [r7, #4]
10001cfc:	617b      	str	r3, [r7, #20]
  HandlePtr->CC4yRegsPtr->CRS = (Compare & 0xFFFFU);
10001cfe:	697b      	ldr	r3, [r7, #20]
10001d00:	699b      	ldr	r3, [r3, #24]
10001d02:	683a      	ldr	r2, [r7, #0]
10001d04:	0412      	lsls	r2, r2, #16
10001d06:	0c12      	lsrs	r2, r2, #16
10001d08:	63da      	str	r2, [r3, #60]	; 0x3c
  
  /* Request shadow transfer */
  Temp2 = (4U*(uint32_t)HandlePtr->FirstSlice);
10001d0a:	697a      	ldr	r2, [r7, #20]
10001d0c:	2337      	movs	r3, #55	; 0x37
10001d0e:	5cd3      	ldrb	r3, [r2, r3]
10001d10:	009b      	lsls	r3, r3, #2
10001d12:	613b      	str	r3, [r7, #16]
  Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + Temp2;
10001d14:	693b      	ldr	r3, [r7, #16]
10001d16:	60fb      	str	r3, [r7, #12]
  HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1);
10001d18:	697b      	ldr	r3, [r7, #20]
10001d1a:	695b      	ldr	r3, [r3, #20]
10001d1c:	697a      	ldr	r2, [r7, #20]
10001d1e:	6952      	ldr	r2, [r2, #20]
10001d20:	6911      	ldr	r1, [r2, #16]
10001d22:	68fa      	ldr	r2, [r7, #12]
10001d24:	2001      	movs	r0, #1
10001d26:	1c04      	adds	r4, r0, #0
10001d28:	4094      	lsls	r4, r2
10001d2a:	1c22      	adds	r2, r4, #0
10001d2c:	430a      	orrs	r2, r1
10001d2e:	611a      	str	r2, [r3, #16]
}
10001d30:	46bd      	mov	sp, r7
10001d32:	b007      	add	sp, #28
10001d34:	bd90      	pop	{r4, r7, pc}
10001d36:	46c0      	nop			; (mov r8, r8)

10001d38 <PWMSP001_lSetCompareEdgeAlignTimerConcat>:
void PWMSP001_lSetCompareEdgeAlignTimerConcat
(
    void* Handle,
    uint32_t Compare
)
{
10001d38:	b5b0      	push	{r4, r5, r7, lr}
10001d3a:	b088      	sub	sp, #32
10001d3c:	af00      	add	r7, sp, #0
10001d3e:	6078      	str	r0, [r7, #4]
10001d40:	6039      	str	r1, [r7, #0]
  uint32_t FirstSliceCompareVal = 0x00U;
10001d42:	2300      	movs	r3, #0
10001d44:	61fb      	str	r3, [r7, #28]
  uint32_t SecondSliceCompareVal = 0x00U;
10001d46:	2300      	movs	r3, #0
10001d48:	61bb      	str	r3, [r7, #24]
  uint32_t Temp1;
  uint32_t Temp2;
  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;
10001d4a:	687b      	ldr	r3, [r7, #4]
10001d4c:	617b      	str	r3, [r7, #20]
   * register of second slice.
   * This is done to achieve compare register value of first slice
   * to be less than period register value.
   */
  FirstSliceCompareVal = (uint32_t)Compare % \
      (uint16_t)HandlePtr->CC4yRegsPtr->PRS;
10001d4e:	697b      	ldr	r3, [r7, #20]
10001d50:	699b      	ldr	r3, [r3, #24]
10001d52:	6b5b      	ldr	r3, [r3, #52]	; 0x34
10001d54:	b29b      	uxth	r3, r3
   * compare register of first slice and quotient is written in compare
   * register of second slice.
   * This is done to achieve compare register value of first slice
   * to be less than period register value.
   */
  FirstSliceCompareVal = (uint32_t)Compare % \
10001d56:	683a      	ldr	r2, [r7, #0]
10001d58:	1c10      	adds	r0, r2, #0
10001d5a:	1c19      	adds	r1, r3, #0
10001d5c:	f001 fa3c 	bl	100031d8 <__aeabi_uidivmod>
10001d60:	1c0b      	adds	r3, r1, #0
10001d62:	61fb      	str	r3, [r7, #28]
      (uint16_t)HandlePtr->CC4yRegsPtr->PRS;
  SecondSliceCompareVal = (uint32_t)Compare /
      (uint16_t)HandlePtr->CC4yRegsPtr->PRS;
10001d64:	697b      	ldr	r3, [r7, #20]
10001d66:	699b      	ldr	r3, [r3, #24]
10001d68:	6b5b      	ldr	r3, [r3, #52]	; 0x34
10001d6a:	b29b      	uxth	r3, r3
   * This is done to achieve compare register value of first slice
   * to be less than period register value.
   */
  FirstSliceCompareVal = (uint32_t)Compare % \
      (uint16_t)HandlePtr->CC4yRegsPtr->PRS;
  SecondSliceCompareVal = (uint32_t)Compare /
10001d6c:	6838      	ldr	r0, [r7, #0]
10001d6e:	1c19      	adds	r1, r3, #0
10001d70:	f001 f9ee 	bl	10003150 <__aeabi_uidiv>
10001d74:	1c03      	adds	r3, r0, #0
10001d76:	61bb      	str	r3, [r7, #24]
      (uint16_t)HandlePtr->CC4yRegsPtr->PRS;
  
  HandlePtr->CC4yRegsPtr->CRS = (FirstSliceCompareVal & 0xFFFFU);
10001d78:	697b      	ldr	r3, [r7, #20]
10001d7a:	699b      	ldr	r3, [r3, #24]
10001d7c:	69fa      	ldr	r2, [r7, #28]
10001d7e:	0412      	lsls	r2, r2, #16
10001d80:	0c12      	lsrs	r2, r2, #16
10001d82:	63da      	str	r2, [r3, #60]	; 0x3c
  HandlePtr->CC4yRegs1Ptr->CRS = (SecondSliceCompareVal & 0xFFFFU);
10001d84:	697b      	ldr	r3, [r7, #20]
10001d86:	69db      	ldr	r3, [r3, #28]
10001d88:	69ba      	ldr	r2, [r7, #24]
10001d8a:	0412      	lsls	r2, r2, #16
10001d8c:	0c12      	lsrs	r2, r2, #16
10001d8e:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Request shadow transfer */
  Temp1 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->SecondSlice));
10001d90:	697a      	ldr	r2, [r7, #20]
10001d92:	2338      	movs	r3, #56	; 0x38
10001d94:	5cd3      	ldrb	r3, [r2, r3]
10001d96:	009b      	lsls	r3, r3, #2
10001d98:	613b      	str	r3, [r7, #16]
  Temp2 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice));
10001d9a:	697a      	ldr	r2, [r7, #20]
10001d9c:	2337      	movs	r3, #55	; 0x37
10001d9e:	5cd3      	ldrb	r3, [r2, r3]
10001da0:	009b      	lsls	r3, r3, #2
10001da2:	60fb      	str	r3, [r7, #12]
  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)0x01 << Temp2 ) | ((uint32_t)0x01 << Temp1));
10001da4:	697b      	ldr	r3, [r7, #20]
10001da6:	695b      	ldr	r3, [r3, #20]
10001da8:	697a      	ldr	r2, [r7, #20]
10001daa:	6952      	ldr	r2, [r2, #20]
10001dac:	6911      	ldr	r1, [r2, #16]
10001dae:	68fa      	ldr	r2, [r7, #12]
10001db0:	2001      	movs	r0, #1
10001db2:	4090      	lsls	r0, r2
10001db4:	693a      	ldr	r2, [r7, #16]
10001db6:	2401      	movs	r4, #1
10001db8:	1c25      	adds	r5, r4, #0
10001dba:	4095      	lsls	r5, r2
10001dbc:	1c2a      	adds	r2, r5, #0
10001dbe:	4302      	orrs	r2, r0
10001dc0:	430a      	orrs	r2, r1
10001dc2:	611a      	str	r2, [r3, #16]
}
10001dc4:	46bd      	mov	sp, r7
10001dc6:	b008      	add	sp, #32
10001dc8:	bdb0      	pop	{r4, r5, r7, pc}
10001dca:	46c0      	nop			; (mov r8, r8)

10001dcc <PWMSP001_lSetCompareCenterAlign>:
void PWMSP001_lSetCompareCenterAlign
(
    void* Handle,
    uint32_t Compare
)
{
10001dcc:	b590      	push	{r4, r7, lr}
10001dce:	b085      	sub	sp, #20
10001dd0:	af00      	add	r7, sp, #0
10001dd2:	6078      	str	r0, [r7, #4]
10001dd4:	6039      	str	r1, [r7, #0]
  uint32_t Temp1;
  /*<<<DD_PWMSP001_API_5_3>>>*/
  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;
10001dd6:	687b      	ldr	r3, [r7, #4]
10001dd8:	60fb      	str	r3, [r7, #12]
  HandlePtr->CC4yRegsPtr->CRS = (Compare & 0xFFFFU);
10001dda:	68fb      	ldr	r3, [r7, #12]
10001ddc:	699b      	ldr	r3, [r3, #24]
10001dde:	683a      	ldr	r2, [r7, #0]
10001de0:	0412      	lsls	r2, r2, #16
10001de2:	0c12      	lsrs	r2, r2, #16
10001de4:	63da      	str	r2, [r3, #60]	; 0x3c
  
  /* Request shadow transfer */
  Temp1 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U*(uint32_t)HandlePtr->FirstSlice));
10001de6:	68fa      	ldr	r2, [r7, #12]
10001de8:	2337      	movs	r3, #55	; 0x37
10001dea:	5cd3      	ldrb	r3, [r2, r3]
10001dec:	009b      	lsls	r3, r3, #2
10001dee:	60bb      	str	r3, [r7, #8]
  HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1);
10001df0:	68fb      	ldr	r3, [r7, #12]
10001df2:	695b      	ldr	r3, [r3, #20]
10001df4:	68fa      	ldr	r2, [r7, #12]
10001df6:	6952      	ldr	r2, [r2, #20]
10001df8:	6911      	ldr	r1, [r2, #16]
10001dfa:	68ba      	ldr	r2, [r7, #8]
10001dfc:	2001      	movs	r0, #1
10001dfe:	1c04      	adds	r4, r0, #0
10001e00:	4094      	lsls	r4, r2
10001e02:	1c22      	adds	r2, r4, #0
10001e04:	430a      	orrs	r2, r1
10001e06:	611a      	str	r2, [r3, #16]
}
10001e08:	46bd      	mov	sp, r7
10001e0a:	b005      	add	sp, #20
10001e0c:	bd90      	pop	{r4, r7, pc}
10001e0e:	46c0      	nop			; (mov r8, r8)

10001e10 <PWMSP001_SetDutyCycle>:
status_t PWMSP001_SetDutyCycle
(
    const PWMSP001_HandleType* HandlePtr,
    float Duty
)
{
10001e10:	b580      	push	{r7, lr}
10001e12:	b084      	sub	sp, #16
10001e14:	af00      	add	r7, sp, #0
10001e16:	6078      	str	r0, [r7, #4]
10001e18:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
10001e1a:	2301      	movs	r3, #1
10001e1c:	60fb      	str	r3, [r7, #12]

  if ( HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED)
10001e1e:	687b      	ldr	r3, [r7, #4]
10001e20:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10001e22:	781b      	ldrb	r3, [r3, #0]
10001e24:	2b00      	cmp	r3, #0
10001e26:	d019      	beq.n	10001e5c <PWMSP001_SetDutyCycle+0x4c>
  {
  if((Duty > (float)100) || ((float)Duty < (float)0))
10001e28:	6838      	ldr	r0, [r7, #0]
10001e2a:	490f      	ldr	r1, [pc, #60]	; (10001e68 <PWMSP001_SetDutyCycle+0x58>)
10001e2c:	f001 fa66 	bl	100032fc <__aeabi_fcmpgt>
10001e30:	1c03      	adds	r3, r0, #0
10001e32:	2b00      	cmp	r3, #0
10001e34:	d106      	bne.n	10001e44 <PWMSP001_SetDutyCycle+0x34>
10001e36:	6838      	ldr	r0, [r7, #0]
10001e38:	2100      	movs	r1, #0
10001e3a:	f001 fa4b 	bl	100032d4 <__aeabi_fcmplt>
10001e3e:	1c03      	adds	r3, r0, #0
10001e40:	2b00      	cmp	r3, #0
10001e42:	d002      	beq.n	10001e4a <PWMSP001_SetDutyCycle+0x3a>
  {
    Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
10001e44:	2302      	movs	r3, #2
10001e46:	60fb      	str	r3, [r7, #12]
10001e48:	e008      	b.n	10001e5c <PWMSP001_SetDutyCycle+0x4c>
  }
  else
  {
    /* Call the function as per configured mode */
    HandlePtr->SetDutyFuncPtr((const void*)HandlePtr, Duty);
10001e4a:	687b      	ldr	r3, [r7, #4]
10001e4c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
10001e4e:	6879      	ldr	r1, [r7, #4]
10001e50:	683a      	ldr	r2, [r7, #0]
10001e52:	1c08      	adds	r0, r1, #0
10001e54:	1c11      	adds	r1, r2, #0
10001e56:	4798      	blx	r3
    Status = (uint32_t)DAVEApp_SUCCESS;
10001e58:	2300      	movs	r3, #0
10001e5a:	60fb      	str	r3, [r7, #12]
  }
  }
  return (Status);
10001e5c:	68fb      	ldr	r3, [r7, #12]
}
10001e5e:	1c18      	adds	r0, r3, #0
10001e60:	46bd      	mov	sp, r7
10001e62:	b004      	add	sp, #16
10001e64:	bd80      	pop	{r7, pc}
10001e66:	46c0      	nop			; (mov r8, r8)
10001e68:	42c80000 	.word	0x42c80000

10001e6c <PWMSP001_lSetDutyEdgeAlign>:
void PWMSP001_lSetDutyEdgeAlign
(
    void* Handle,
    float Duty
)
{
10001e6c:	b590      	push	{r4, r7, lr}
10001e6e:	b089      	sub	sp, #36	; 0x24
10001e70:	af00      	add	r7, sp, #0
10001e72:	6078      	str	r0, [r7, #4]
10001e74:	6039      	str	r1, [r7, #0]
  uint32_t FirstSliceCompareVal = (uint32_t)0;
10001e76:	2300      	movs	r3, #0
10001e78:	61fb      	str	r3, [r7, #28]
  uint32_t Temp1;
  float fDuty, fPRS ;
  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;
10001e7a:	687b      	ldr	r3, [r7, #4]
10001e7c:	61bb      	str	r3, [r7, #24]
  fDuty = Duty;
10001e7e:	683b      	ldr	r3, [r7, #0]
10001e80:	617b      	str	r3, [r7, #20]
  
  /*<<<DD_PWMSP001_API_15_3>>>*/
  
  fDuty = (float)((float)100.00 - (float)fDuty)/(float)100.00;
10001e82:	481c      	ldr	r0, [pc, #112]	; (10001ef4 <PWMSP001_lSetDutyEdgeAlign+0x88>)
10001e84:	6979      	ldr	r1, [r7, #20]
10001e86:	f001 fd87 	bl	10003998 <__aeabi_fsub>
10001e8a:	1c03      	adds	r3, r0, #0
10001e8c:	1c18      	adds	r0, r3, #0
10001e8e:	4919      	ldr	r1, [pc, #100]	; (10001ef4 <PWMSP001_lSetDutyEdgeAlign+0x88>)
10001e90:	f001 fa60 	bl	10003354 <__aeabi_fdiv>
10001e94:	1c03      	adds	r3, r0, #0
10001e96:	617b      	str	r3, [r7, #20]
  fPRS = (float)((uint32_t)HandlePtr->CC4yRegsPtr->PRS + 1U);
10001e98:	69bb      	ldr	r3, [r7, #24]
10001e9a:	699b      	ldr	r3, [r3, #24]
10001e9c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
10001e9e:	3301      	adds	r3, #1
10001ea0:	1c18      	adds	r0, r3, #0
10001ea2:	f001 ff73 	bl	10003d8c <__aeabi_ui2f>
10001ea6:	1c03      	adds	r3, r0, #0
10001ea8:	613b      	str	r3, [r7, #16]
  FirstSliceCompareVal = (uint32_t)( fPRS * fDuty);
10001eaa:	6938      	ldr	r0, [r7, #16]
10001eac:	6979      	ldr	r1, [r7, #20]
10001eae:	f001 fc43 	bl	10003738 <__aeabi_fmul>
10001eb2:	1c03      	adds	r3, r0, #0
10001eb4:	1c18      	adds	r0, r3, #0
10001eb6:	f001 fa35 	bl	10003324 <__aeabi_f2uiz>
10001eba:	1c03      	adds	r3, r0, #0
10001ebc:	61fb      	str	r3, [r7, #28]
  HandlePtr->CC4yRegsPtr->CRS = FirstSliceCompareVal  & 0xFFFFU;
10001ebe:	69bb      	ldr	r3, [r7, #24]
10001ec0:	699b      	ldr	r3, [r3, #24]
10001ec2:	69fa      	ldr	r2, [r7, #28]
10001ec4:	0412      	lsls	r2, r2, #16
10001ec6:	0c12      	lsrs	r2, r2, #16
10001ec8:	63da      	str	r2, [r3, #60]	; 0x3c
  
  /*Shadow transfer */
  Temp1 =  ((uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4 *(uint32_t)HandlePtr->FirstSlice));
10001eca:	69ba      	ldr	r2, [r7, #24]
10001ecc:	2337      	movs	r3, #55	; 0x37
10001ece:	5cd3      	ldrb	r3, [r2, r3]
10001ed0:	009b      	lsls	r3, r3, #2
10001ed2:	60fb      	str	r3, [r7, #12]
  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)((uint32_t)0x01 << (uint32_t)Temp1);
10001ed4:	69bb      	ldr	r3, [r7, #24]
10001ed6:	695b      	ldr	r3, [r3, #20]
10001ed8:	69ba      	ldr	r2, [r7, #24]
10001eda:	6952      	ldr	r2, [r2, #20]
10001edc:	6911      	ldr	r1, [r2, #16]
10001ede:	68fa      	ldr	r2, [r7, #12]
10001ee0:	2001      	movs	r0, #1
10001ee2:	1c04      	adds	r4, r0, #0
10001ee4:	4094      	lsls	r4, r2
10001ee6:	1c22      	adds	r2, r4, #0
10001ee8:	430a      	orrs	r2, r1
10001eea:	611a      	str	r2, [r3, #16]
  /*Update dynamic handle */
}
10001eec:	46bd      	mov	sp, r7
10001eee:	b009      	add	sp, #36	; 0x24
10001ef0:	bd90      	pop	{r4, r7, pc}
10001ef2:	46c0      	nop			; (mov r8, r8)
10001ef4:	42c80000 	.word	0x42c80000

10001ef8 <PWMSP001_lSetDutyEdgeAlignTimerConcat>:
void PWMSP001_lSetDutyEdgeAlignTimerConcat
(
    void* Handle,
    float Duty
)
{
10001ef8:	b5b0      	push	{r4, r5, r7, lr}
10001efa:	b08a      	sub	sp, #40	; 0x28
10001efc:	af00      	add	r7, sp, #0
10001efe:	6078      	str	r0, [r7, #4]
10001f00:	6039      	str	r1, [r7, #0]
  uint32_t Compare = (uint32_t)0;
10001f02:	2300      	movs	r3, #0
10001f04:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t FirstSliceCompareVal = (uint32_t)0;
10001f06:	2300      	movs	r3, #0
10001f08:	623b      	str	r3, [r7, #32]
  uint32_t SecondSliceCompareVal = (uint32_t)0;
10001f0a:	2300      	movs	r3, #0
10001f0c:	61fb      	str	r3, [r7, #28]
  uint32_t Temp2;
  uint32_t Temp3;
  float fDuty, fPRS ;
  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;
10001f0e:	687b      	ldr	r3, [r7, #4]
10001f10:	61bb      	str	r3, [r7, #24]
  
  fDuty = Duty;
10001f12:	683b      	ldr	r3, [r7, #0]
10001f14:	617b      	str	r3, [r7, #20]
  /*<<<DD_PWMSP001_API_15_4>>>*/
  /* Find the compare register value from the duty cycle and period register value */
  Compare =(uint32_t)HandlePtr->CC4yRegs1Ptr->PRS + 1U;
10001f16:	69bb      	ldr	r3, [r7, #24]
10001f18:	69db      	ldr	r3, [r3, #28]
10001f1a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
10001f1c:	3301      	adds	r3, #1
10001f1e:	627b      	str	r3, [r7, #36]	; 0x24
  Compare *= ((uint32_t)((uint32_t)HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU) +1U); 
10001f20:	69bb      	ldr	r3, [r7, #24]
10001f22:	699b      	ldr	r3, [r3, #24]
10001f24:	6b5b      	ldr	r3, [r3, #52]	; 0x34
10001f26:	041b      	lsls	r3, r3, #16
10001f28:	0c1b      	lsrs	r3, r3, #16
10001f2a:	1c5a      	adds	r2, r3, #1
10001f2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10001f2e:	4353      	muls	r3, r2
10001f30:	627b      	str	r3, [r7, #36]	; 0x24
  Compare +=  (uint32_t)1;
10001f32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10001f34:	3301      	adds	r3, #1
10001f36:	627b      	str	r3, [r7, #36]	; 0x24
  
  fDuty = ((float)100.00 - (float)fDuty)/(float)100.00;
10001f38:	482c      	ldr	r0, [pc, #176]	; (10001fec <PWMSP001_lSetDutyEdgeAlignTimerConcat+0xf4>)
10001f3a:	6979      	ldr	r1, [r7, #20]
10001f3c:	f001 fd2c 	bl	10003998 <__aeabi_fsub>
10001f40:	1c03      	adds	r3, r0, #0
10001f42:	1c18      	adds	r0, r3, #0
10001f44:	4929      	ldr	r1, [pc, #164]	; (10001fec <PWMSP001_lSetDutyEdgeAlignTimerConcat+0xf4>)
10001f46:	f001 fa05 	bl	10003354 <__aeabi_fdiv>
10001f4a:	1c03      	adds	r3, r0, #0
10001f4c:	617b      	str	r3, [r7, #20]
  fPRS = (float)(Compare);
10001f4e:	6a78      	ldr	r0, [r7, #36]	; 0x24
10001f50:	f001 ff1c 	bl	10003d8c <__aeabi_ui2f>
10001f54:	1c03      	adds	r3, r0, #0
10001f56:	613b      	str	r3, [r7, #16]
  Compare = (uint32_t)( fPRS * fDuty);
10001f58:	6938      	ldr	r0, [r7, #16]
10001f5a:	6979      	ldr	r1, [r7, #20]
10001f5c:	f001 fbec 	bl	10003738 <__aeabi_fmul>
10001f60:	1c03      	adds	r3, r0, #0
10001f62:	1c18      	adds	r0, r3, #0
10001f64:	f001 f9de 	bl	10003324 <__aeabi_f2uiz>
10001f68:	1c03      	adds	r3, r0, #0
10001f6a:	627b      	str	r3, [r7, #36]	; 0x24

  FirstSliceCompareVal =(uint32_t)
                    ((uint32_t)Compare % ((uint32_t)((uint32_t)HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU)));
10001f6c:	69bb      	ldr	r3, [r7, #24]
10001f6e:	699b      	ldr	r3, [r3, #24]
10001f70:	6b5b      	ldr	r3, [r3, #52]	; 0x34
10001f72:	041b      	lsls	r3, r3, #16
10001f74:	0c1b      	lsrs	r3, r3, #16
  
  fDuty = ((float)100.00 - (float)fDuty)/(float)100.00;
  fPRS = (float)(Compare);
  Compare = (uint32_t)( fPRS * fDuty);

  FirstSliceCompareVal =(uint32_t)
10001f76:	6a7a      	ldr	r2, [r7, #36]	; 0x24
10001f78:	1c10      	adds	r0, r2, #0
10001f7a:	1c19      	adds	r1, r3, #0
10001f7c:	f001 f92c 	bl	100031d8 <__aeabi_uidivmod>
10001f80:	1c0b      	adds	r3, r1, #0
10001f82:	623b      	str	r3, [r7, #32]
                    ((uint32_t)Compare % ((uint32_t)((uint32_t)HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU)));
  HandlePtr->CC4yRegsPtr->CRS = (uint32_t)FirstSliceCompareVal  & 0xFFFFU;
10001f84:	69bb      	ldr	r3, [r7, #24]
10001f86:	699b      	ldr	r3, [r3, #24]
10001f88:	6a3a      	ldr	r2, [r7, #32]
10001f8a:	0412      	lsls	r2, r2, #16
10001f8c:	0c12      	lsrs	r2, r2, #16
10001f8e:	63da      	str	r2, [r3, #60]	; 0x3c
  SecondSliceCompareVal = (uint32_t)
                    ((uint32_t)Compare / ((uint32_t)((uint32_t)HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU)));
10001f90:	69bb      	ldr	r3, [r7, #24]
10001f92:	699b      	ldr	r3, [r3, #24]
10001f94:	6b5b      	ldr	r3, [r3, #52]	; 0x34
10001f96:	041b      	lsls	r3, r3, #16
10001f98:	0c1b      	lsrs	r3, r3, #16
  Compare = (uint32_t)( fPRS * fDuty);

  FirstSliceCompareVal =(uint32_t)
                    ((uint32_t)Compare % ((uint32_t)((uint32_t)HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU)));
  HandlePtr->CC4yRegsPtr->CRS = (uint32_t)FirstSliceCompareVal  & 0xFFFFU;
  SecondSliceCompareVal = (uint32_t)
10001f9a:	6a78      	ldr	r0, [r7, #36]	; 0x24
10001f9c:	1c19      	adds	r1, r3, #0
10001f9e:	f001 f8d7 	bl	10003150 <__aeabi_uidiv>
10001fa2:	1c03      	adds	r3, r0, #0
10001fa4:	61fb      	str	r3, [r7, #28]
                    ((uint32_t)Compare / ((uint32_t)((uint32_t)HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU)));
  HandlePtr->CC4yRegs1Ptr->CRS = (uint32_t)SecondSliceCompareVal  & 0xFFFFU;
10001fa6:	69bb      	ldr	r3, [r7, #24]
10001fa8:	69db      	ldr	r3, [r3, #28]
10001faa:	69fa      	ldr	r2, [r7, #28]
10001fac:	0412      	lsls	r2, r2, #16
10001fae:	0c12      	lsrs	r2, r2, #16
10001fb0:	63da      	str	r2, [r3, #60]	; 0x3c

  /** shadow transfer */
  Temp2 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice));
10001fb2:	69ba      	ldr	r2, [r7, #24]
10001fb4:	2337      	movs	r3, #55	; 0x37
10001fb6:	5cd3      	ldrb	r3, [r2, r3]
10001fb8:	009b      	lsls	r3, r3, #2
10001fba:	60fb      	str	r3, [r7, #12]
  Temp3 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->SecondSlice));
10001fbc:	69ba      	ldr	r2, [r7, #24]
10001fbe:	2338      	movs	r3, #56	; 0x38
10001fc0:	5cd3      	ldrb	r3, [r2, r3]
10001fc2:	009b      	lsls	r3, r3, #2
10001fc4:	60bb      	str	r3, [r7, #8]
  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)1 << (uint32_t)Temp2 ) | ((uint32_t)1 << (uint32_t)Temp3));
10001fc6:	69bb      	ldr	r3, [r7, #24]
10001fc8:	695b      	ldr	r3, [r3, #20]
10001fca:	69ba      	ldr	r2, [r7, #24]
10001fcc:	6952      	ldr	r2, [r2, #20]
10001fce:	6911      	ldr	r1, [r2, #16]
10001fd0:	68fa      	ldr	r2, [r7, #12]
10001fd2:	2001      	movs	r0, #1
10001fd4:	4090      	lsls	r0, r2
10001fd6:	68ba      	ldr	r2, [r7, #8]
10001fd8:	2401      	movs	r4, #1
10001fda:	1c25      	adds	r5, r4, #0
10001fdc:	4095      	lsls	r5, r2
10001fde:	1c2a      	adds	r2, r5, #0
10001fe0:	4302      	orrs	r2, r0
10001fe2:	430a      	orrs	r2, r1
10001fe4:	611a      	str	r2, [r3, #16]
}
10001fe6:	46bd      	mov	sp, r7
10001fe8:	b00a      	add	sp, #40	; 0x28
10001fea:	bdb0      	pop	{r4, r5, r7, pc}
10001fec:	42c80000 	.word	0x42c80000

10001ff0 <PWMSP001_lSetDutyCenterAlign>:
void PWMSP001_lSetDutyCenterAlign
(
    void* Handle,
    float Duty
)
{
10001ff0:	b590      	push	{r4, r7, lr}
10001ff2:	b089      	sub	sp, #36	; 0x24
10001ff4:	af00      	add	r7, sp, #0
10001ff6:	6078      	str	r0, [r7, #4]
10001ff8:	6039      	str	r1, [r7, #0]
  /*<<<DD_PWMSP001_API_15_5>>>*/
  uint32_t FirstSliceCompareVal = (uint32_t)0x00;
10001ffa:	2300      	movs	r3, #0
10001ffc:	61fb      	str	r3, [r7, #28]
  uint32_t Temp1;
  float fDuty, fPRS ;
  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;
10001ffe:	687b      	ldr	r3, [r7, #4]
10002000:	61bb      	str	r3, [r7, #24]
  fDuty = Duty;
10002002:	683b      	ldr	r3, [r7, #0]
10002004:	617b      	str	r3, [r7, #20]

  fDuty = (float)((float)100.00 - (float)fDuty)/(float)100.00;
10002006:	481b      	ldr	r0, [pc, #108]	; (10002074 <PWMSP001_lSetDutyCenterAlign+0x84>)
10002008:	6979      	ldr	r1, [r7, #20]
1000200a:	f001 fcc5 	bl	10003998 <__aeabi_fsub>
1000200e:	1c03      	adds	r3, r0, #0
10002010:	1c18      	adds	r0, r3, #0
10002012:	4918      	ldr	r1, [pc, #96]	; (10002074 <PWMSP001_lSetDutyCenterAlign+0x84>)
10002014:	f001 f99e 	bl	10003354 <__aeabi_fdiv>
10002018:	1c03      	adds	r3, r0, #0
1000201a:	617b      	str	r3, [r7, #20]
  fPRS = (float)HandlePtr->CC4yRegsPtr->PRS;
1000201c:	69bb      	ldr	r3, [r7, #24]
1000201e:	699b      	ldr	r3, [r3, #24]
10002020:	6b5b      	ldr	r3, [r3, #52]	; 0x34
10002022:	1c18      	adds	r0, r3, #0
10002024:	f001 feb2 	bl	10003d8c <__aeabi_ui2f>
10002028:	1c03      	adds	r3, r0, #0
1000202a:	613b      	str	r3, [r7, #16]
  FirstSliceCompareVal = (uint32_t)( fPRS * fDuty);
1000202c:	6938      	ldr	r0, [r7, #16]
1000202e:	6979      	ldr	r1, [r7, #20]
10002030:	f001 fb82 	bl	10003738 <__aeabi_fmul>
10002034:	1c03      	adds	r3, r0, #0
10002036:	1c18      	adds	r0, r3, #0
10002038:	f001 f974 	bl	10003324 <__aeabi_f2uiz>
1000203c:	1c03      	adds	r3, r0, #0
1000203e:	61fb      	str	r3, [r7, #28]
  HandlePtr->CC4yRegsPtr->CRS = (uint32_t)FirstSliceCompareVal  & 0xFFFFU;
10002040:	69bb      	ldr	r3, [r7, #24]
10002042:	699b      	ldr	r3, [r3, #24]
10002044:	69fa      	ldr	r2, [r7, #28]
10002046:	0412      	lsls	r2, r2, #16
10002048:	0c12      	lsrs	r2, r2, #16
1000204a:	63da      	str	r2, [r3, #60]	; 0x3c

  /*shadow transfer */
  Temp1 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice));
1000204c:	69ba      	ldr	r2, [r7, #24]
1000204e:	2337      	movs	r3, #55	; 0x37
10002050:	5cd3      	ldrb	r3, [r2, r3]
10002052:	009b      	lsls	r3, r3, #2
10002054:	60fb      	str	r3, [r7, #12]
  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)((uint32_t)0x01 << (uint32_t)Temp1);
10002056:	69bb      	ldr	r3, [r7, #24]
10002058:	695b      	ldr	r3, [r3, #20]
1000205a:	69ba      	ldr	r2, [r7, #24]
1000205c:	6952      	ldr	r2, [r2, #20]
1000205e:	6911      	ldr	r1, [r2, #16]
10002060:	68fa      	ldr	r2, [r7, #12]
10002062:	2001      	movs	r0, #1
10002064:	1c04      	adds	r4, r0, #0
10002066:	4094      	lsls	r4, r2
10002068:	1c22      	adds	r2, r4, #0
1000206a:	430a      	orrs	r2, r1
1000206c:	611a      	str	r2, [r3, #16]
}
1000206e:	46bd      	mov	sp, r7
10002070:	b009      	add	sp, #36	; 0x24
10002072:	bd90      	pop	{r4, r7, pc}
10002074:	42c80000 	.word	0x42c80000

10002078 <PWMSP001_SetPeriodAndCompare>:
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t Period,
    uint32_t Compare
)
{
10002078:	b580      	push	{r7, lr}
1000207a:	b086      	sub	sp, #24
1000207c:	af00      	add	r7, sp, #0
1000207e:	60f8      	str	r0, [r7, #12]
10002080:	60b9      	str	r1, [r7, #8]
10002082:	607a      	str	r2, [r7, #4]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
10002084:	2301      	movs	r3, #1
10002086:	617b      	str	r3, [r7, #20]
  uint32_t PeriodVal = 0UL;
10002088:	2300      	movs	r3, #0
1000208a:	613b      	str	r3, [r7, #16]
  /*<<<DD_PWMSP001_API_6_1>>>*/
  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED))
1000208c:	68fb      	ldr	r3, [r7, #12]
1000208e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10002090:	781b      	ldrb	r3, [r3, #0]
10002092:	2b00      	cmp	r3, #0
10002094:	d037      	beq.n	10002106 <PWMSP001_SetPeriodAndCompare+0x8e>
  {
   if((Period == (uint32_t)0) || (((uint32_t)Compare > (uint32_t)HandlePtr->kMaxPeriodVal) &&
10002096:	68bb      	ldr	r3, [r7, #8]
10002098:	2b00      	cmp	r3, #0
1000209a:	d009      	beq.n	100020b0 <PWMSP001_SetPeriodAndCompare+0x38>
1000209c:	68fb      	ldr	r3, [r7, #12]
1000209e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100020a0:	687b      	ldr	r3, [r7, #4]
100020a2:	429a      	cmp	r2, r3
100020a4:	d207      	bcs.n	100020b6 <PWMSP001_SetPeriodAndCompare+0x3e>
       (HandlePtr->kTimerConcatenation == (uint8_t)RESET)))
100020a6:	68fa      	ldr	r2, [r7, #12]
100020a8:	2320      	movs	r3, #32
100020aa:	5cd3      	ldrb	r3, [r2, r3]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
  uint32_t PeriodVal = 0UL;
  /*<<<DD_PWMSP001_API_6_1>>>*/
  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED))
  {
   if((Period == (uint32_t)0) || (((uint32_t)Compare > (uint32_t)HandlePtr->kMaxPeriodVal) &&
100020ac:	2b00      	cmp	r3, #0
100020ae:	d102      	bne.n	100020b6 <PWMSP001_SetPeriodAndCompare+0x3e>
       (HandlePtr->kTimerConcatenation == (uint8_t)RESET)))
    {
      Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
100020b0:	2302      	movs	r3, #2
100020b2:	617b      	str	r3, [r7, #20]
100020b4:	e027      	b.n	10002106 <PWMSP001_SetPeriodAndCompare+0x8e>
    }
    else
    {
      if ((Period > (uint32_t)HandlePtr->kMaxPeriodVal)&&\
100020b6:	68fb      	ldr	r3, [r7, #12]
100020b8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100020ba:	68bb      	ldr	r3, [r7, #8]
100020bc:	429a      	cmp	r2, r3
100020be:	d207      	bcs.n	100020d0 <PWMSP001_SetPeriodAndCompare+0x58>
          ((HandlePtr->kTimerConcatenation != (uint8_t)SET))
100020c0:	68fa      	ldr	r2, [r7, #12]
100020c2:	2320      	movs	r3, #32
100020c4:	5cd3      	ldrb	r3, [r2, r3]
    {
      Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
    }
    else
    {
      if ((Period > (uint32_t)HandlePtr->kMaxPeriodVal)&&\
100020c6:	2b01      	cmp	r3, #1
100020c8:	d002      	beq.n	100020d0 <PWMSP001_SetPeriodAndCompare+0x58>
          ((HandlePtr->kTimerConcatenation != (uint8_t)SET))
          )
      {
        Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
100020ca:	2302      	movs	r3, #2
100020cc:	617b      	str	r3, [r7, #20]
100020ce:	e01a      	b.n	10002106 <PWMSP001_SetPeriodAndCompare+0x8e>
      }
      else
      {
        PeriodVal = Period;
100020d0:	68bb      	ldr	r3, [r7, #8]
100020d2:	613b      	str	r3, [r7, #16]
        if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
100020d4:	68fa      	ldr	r2, [r7, #12]
100020d6:	2320      	movs	r3, #32
100020d8:	5cd3      	ldrb	r3, [r2, r3]
100020da:	2b01      	cmp	r3, #1
100020dc:	d104      	bne.n	100020e8 <PWMSP001_SetPeriodAndCompare+0x70>
        {
          HandlePtr->CC4yRegs1Ptr->PRS = ((PeriodVal & 0xFFFF0000U) >> 16U);
100020de:	68fb      	ldr	r3, [r7, #12]
100020e0:	69db      	ldr	r3, [r3, #28]
100020e2:	693a      	ldr	r2, [r7, #16]
100020e4:	0c12      	lsrs	r2, r2, #16
100020e6:	635a      	str	r2, [r3, #52]	; 0x34
        }
        /*<<<DD_PWMSP001_API_6_3>>>*/
        HandlePtr->CC4yRegsPtr->PRS = (PeriodVal & 0xFFFFU);
100020e8:	68fb      	ldr	r3, [r7, #12]
100020ea:	699b      	ldr	r3, [r3, #24]
100020ec:	693a      	ldr	r2, [r7, #16]
100020ee:	0412      	lsls	r2, r2, #16
100020f0:	0c12      	lsrs	r2, r2, #16
100020f2:	635a      	str	r2, [r3, #52]	; 0x34
        /* Call function as per the configured mode */
        HandlePtr->SetCompareFuncPtr((const void*)HandlePtr, Compare);
100020f4:	68fb      	ldr	r3, [r7, #12]
100020f6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100020f8:	68f9      	ldr	r1, [r7, #12]
100020fa:	687a      	ldr	r2, [r7, #4]
100020fc:	1c08      	adds	r0, r1, #0
100020fe:	1c11      	adds	r1, r2, #0
10002100:	4798      	blx	r3
        Status = (uint32_t)DAVEApp_SUCCESS;
10002102:	2300      	movs	r3, #0
10002104:	617b      	str	r3, [r7, #20]
      }
    }
  }
  return Status;
10002106:	697b      	ldr	r3, [r7, #20]
}
10002108:	1c18      	adds	r0, r3, #0
1000210a:	46bd      	mov	sp, r7
1000210c:	b006      	add	sp, #24
1000210e:	bd80      	pop	{r7, pc}

10002110 <PWMSP001_SetPeriod>:
status_t PWMSP001_SetPeriod
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t Period
)
{
10002110:	b590      	push	{r4, r7, lr}
10002112:	b087      	sub	sp, #28
10002114:	af00      	add	r7, sp, #0
10002116:	6078      	str	r0, [r7, #4]
10002118:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
1000211a:	2301      	movs	r3, #1
1000211c:	617b      	str	r3, [r7, #20]
  uint32_t PeriodVal = 0X00U;
1000211e:	2300      	movs	r3, #0
10002120:	613b      	str	r3, [r7, #16]
  uint32_t Temp1;
  
  /*<<<DD_PWMSP001_API_6_1>>>*/
  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED))
10002122:	687b      	ldr	r3, [r7, #4]
10002124:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10002126:	781b      	ldrb	r3, [r3, #0]
10002128:	2b00      	cmp	r3, #0
1000212a:	d04d      	beq.n	100021c8 <PWMSP001_SetPeriod+0xb8>
  {
    if(Period == (uint32_t)0)
1000212c:	683b      	ldr	r3, [r7, #0]
1000212e:	2b00      	cmp	r3, #0
10002130:	d102      	bne.n	10002138 <PWMSP001_SetPeriod+0x28>
    {
      Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
10002132:	2302      	movs	r3, #2
10002134:	617b      	str	r3, [r7, #20]
10002136:	e047      	b.n	100021c8 <PWMSP001_SetPeriod+0xb8>
    }
    else
    {
      if((Period > (uint32_t)HandlePtr->kMaxPeriodVal) &&\
10002138:	687b      	ldr	r3, [r7, #4]
1000213a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000213c:	683b      	ldr	r3, [r7, #0]
1000213e:	429a      	cmp	r2, r3
10002140:	d207      	bcs.n	10002152 <PWMSP001_SetPeriod+0x42>
         (HandlePtr->kTimerConcatenation != (uint8_t)SET))
10002142:	687a      	ldr	r2, [r7, #4]
10002144:	2320      	movs	r3, #32
10002146:	5cd3      	ldrb	r3, [r2, r3]
    {
      Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
    }
    else
    {
      if((Period > (uint32_t)HandlePtr->kMaxPeriodVal) &&\
10002148:	2b01      	cmp	r3, #1
1000214a:	d002      	beq.n	10002152 <PWMSP001_SetPeriod+0x42>
         (HandlePtr->kTimerConcatenation != (uint8_t)SET))
      {
        Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
1000214c:	2302      	movs	r3, #2
1000214e:	617b      	str	r3, [r7, #20]
10002150:	e03a      	b.n	100021c8 <PWMSP001_SetPeriod+0xb8>
      }
      else
      {
        PeriodVal = Period;
10002152:	683b      	ldr	r3, [r7, #0]
10002154:	613b      	str	r3, [r7, #16]
        if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
10002156:	687a      	ldr	r2, [r7, #4]
10002158:	2320      	movs	r3, #32
1000215a:	5cd3      	ldrb	r3, [r2, r3]
1000215c:	2b01      	cmp	r3, #1
1000215e:	d104      	bne.n	1000216a <PWMSP001_SetPeriod+0x5a>
        {
          HandlePtr->CC4yRegs1Ptr->PRS = ((PeriodVal & 0xFFFF0000U) >> 16U);
10002160:	687b      	ldr	r3, [r7, #4]
10002162:	69db      	ldr	r3, [r3, #28]
10002164:	693a      	ldr	r2, [r7, #16]
10002166:	0c12      	lsrs	r2, r2, #16
10002168:	635a      	str	r2, [r3, #52]	; 0x34
        }
        HandlePtr->CC4yRegsPtr->PRS = (PeriodVal & 0xFFFFU);
1000216a:	687b      	ldr	r3, [r7, #4]
1000216c:	699b      	ldr	r3, [r3, #24]
1000216e:	693a      	ldr	r2, [r7, #16]
10002170:	0412      	lsls	r2, r2, #16
10002172:	0c12      	lsrs	r2, r2, #16
10002174:	635a      	str	r2, [r3, #52]	; 0x34
        /*Request shadow transfer for the First slice*/
        Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4 * (uint32_t)HandlePtr->FirstSlice);
10002176:	687a      	ldr	r2, [r7, #4]
10002178:	2337      	movs	r3, #55	; 0x37
1000217a:	5cd3      	ldrb	r3, [r2, r3]
1000217c:	009b      	lsls	r3, r3, #2
1000217e:	60fb      	str	r3, [r7, #12]
        HandlePtr->CC4yKernRegsPtr->GCSS |=	((uint32_t)0x01 << Temp1);
10002180:	687b      	ldr	r3, [r7, #4]
10002182:	695b      	ldr	r3, [r3, #20]
10002184:	687a      	ldr	r2, [r7, #4]
10002186:	6952      	ldr	r2, [r2, #20]
10002188:	6911      	ldr	r1, [r2, #16]
1000218a:	68fa      	ldr	r2, [r7, #12]
1000218c:	2001      	movs	r0, #1
1000218e:	1c04      	adds	r4, r0, #0
10002190:	4094      	lsls	r4, r2
10002192:	1c22      	adds	r2, r4, #0
10002194:	430a      	orrs	r2, r1
10002196:	611a      	str	r2, [r3, #16]
        if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
10002198:	687a      	ldr	r2, [r7, #4]
1000219a:	2320      	movs	r3, #32
1000219c:	5cd3      	ldrb	r3, [r2, r3]
1000219e:	2b01      	cmp	r3, #1
100021a0:	d110      	bne.n	100021c4 <PWMSP001_SetPeriod+0xb4>
        {
          /*Request shadow transfer for the First slice*/
          Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->SecondSlice);
100021a2:	687a      	ldr	r2, [r7, #4]
100021a4:	2338      	movs	r3, #56	; 0x38
100021a6:	5cd3      	ldrb	r3, [r2, r3]
100021a8:	009b      	lsls	r3, r3, #2
100021aa:	60fb      	str	r3, [r7, #12]
          HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1);
100021ac:	687b      	ldr	r3, [r7, #4]
100021ae:	695b      	ldr	r3, [r3, #20]
100021b0:	687a      	ldr	r2, [r7, #4]
100021b2:	6952      	ldr	r2, [r2, #20]
100021b4:	6911      	ldr	r1, [r2, #16]
100021b6:	68fa      	ldr	r2, [r7, #12]
100021b8:	2001      	movs	r0, #1
100021ba:	1c04      	adds	r4, r0, #0
100021bc:	4094      	lsls	r4, r2
100021be:	1c22      	adds	r2, r4, #0
100021c0:	430a      	orrs	r2, r1
100021c2:	611a      	str	r2, [r3, #16]
        }/*End Of if (HandlePtr->kTimerConcatenation == (uint8_t)SET)*/
        Status = (uint32_t)DAVEApp_SUCCESS;
100021c4:	2300      	movs	r3, #0
100021c6:	617b      	str	r3, [r7, #20]
      }
    }
  }
  return Status;
100021c8:	697b      	ldr	r3, [r7, #20]
}
100021ca:	1c18      	adds	r0, r3, #0
100021cc:	46bd      	mov	sp, r7
100021ce:	b007      	add	sp, #28
100021d0:	bd90      	pop	{r4, r7, pc}
100021d2:	46c0      	nop			; (mov r8, r8)

100021d4 <PWMSP001_SetPwmFreqAndDutyCycle>:
(
    const PWMSP001_HandleType* HandlePtr,
    float PwmFreq,
    float Duty
)
{
100021d4:	b580      	push	{r7, lr}
100021d6:	b088      	sub	sp, #32
100021d8:	af00      	add	r7, sp, #0
100021da:	60f8      	str	r0, [r7, #12]
100021dc:	60b9      	str	r1, [r7, #8]
100021de:	607a      	str	r2, [r7, #4]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
100021e0:	2301      	movs	r3, #1
100021e2:	61fb      	str	r3, [r7, #28]
  uint32_t PwmTime = 0UL;
100021e4:	2300      	movs	r3, #0
100021e6:	61bb      	str	r3, [r7, #24]
  float fPwmFreq ;
  /*<<<DD_PWMSP001_API_16_1>>>*/
  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED))
100021e8:	68fb      	ldr	r3, [r7, #12]
100021ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100021ec:	781b      	ldrb	r3, [r3, #0]
100021ee:	2b00      	cmp	r3, #0
100021f0:	d068      	beq.n	100022c4 <PWMSP001_SetPwmFreqAndDutyCycle+0xf0>
  {
  if((PwmFreq == (float)0) || (Duty > (float)100) || (Duty < (float)0))
100021f2:	68b8      	ldr	r0, [r7, #8]
100021f4:	2100      	movs	r1, #0
100021f6:	f001 f867 	bl	100032c8 <__aeabi_fcmpeq>
100021fa:	1c03      	adds	r3, r0, #0
100021fc:	2b00      	cmp	r3, #0
100021fe:	d10d      	bne.n	1000221c <PWMSP001_SetPwmFreqAndDutyCycle+0x48>
10002200:	6878      	ldr	r0, [r7, #4]
10002202:	4933      	ldr	r1, [pc, #204]	; (100022d0 <PWMSP001_SetPwmFreqAndDutyCycle+0xfc>)
10002204:	f001 f87a 	bl	100032fc <__aeabi_fcmpgt>
10002208:	1c03      	adds	r3, r0, #0
1000220a:	2b00      	cmp	r3, #0
1000220c:	d106      	bne.n	1000221c <PWMSP001_SetPwmFreqAndDutyCycle+0x48>
1000220e:	6878      	ldr	r0, [r7, #4]
10002210:	2100      	movs	r1, #0
10002212:	f001 f85f 	bl	100032d4 <__aeabi_fcmplt>
10002216:	1c03      	adds	r3, r0, #0
10002218:	2b00      	cmp	r3, #0
1000221a:	d002      	beq.n	10002222 <PWMSP001_SetPwmFreqAndDutyCycle+0x4e>
  {
    Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
1000221c:	2302      	movs	r3, #2
1000221e:	61fb      	str	r3, [r7, #28]
10002220:	e050      	b.n	100022c4 <PWMSP001_SetPwmFreqAndDutyCycle+0xf0>
  }
  else
  {
      fPwmFreq=(float)HandlePtr->kResolution;
10002222:	68fb      	ldr	r3, [r7, #12]
10002224:	685b      	ldr	r3, [r3, #4]
10002226:	617b      	str	r3, [r7, #20]
	  fPwmFreq=(float)fPwmFreq*PwmFreq;
10002228:	6978      	ldr	r0, [r7, #20]
1000222a:	68b9      	ldr	r1, [r7, #8]
1000222c:	f001 fa84 	bl	10003738 <__aeabi_fmul>
10002230:	1c03      	adds	r3, r0, #0
10002232:	617b      	str	r3, [r7, #20]
	  PwmTime = (uint32_t)((float)1000000000.00 / fPwmFreq);
10002234:	4827      	ldr	r0, [pc, #156]	; (100022d4 <PWMSP001_SetPwmFreqAndDutyCycle+0x100>)
10002236:	6979      	ldr	r1, [r7, #20]
10002238:	f001 f88c 	bl	10003354 <__aeabi_fdiv>
1000223c:	1c03      	adds	r3, r0, #0
1000223e:	1c18      	adds	r0, r3, #0
10002240:	f001 f870 	bl	10003324 <__aeabi_f2uiz>
10002244:	1c03      	adds	r3, r0, #0
10002246:	61bb      	str	r3, [r7, #24]
    /*<<<DD_PWMSP001_API_16_2>>>*/
    if(HandlePtr->kTimerConcatenation == (uint8_t)RESET)
10002248:	68fa      	ldr	r2, [r7, #12]
1000224a:	2320      	movs	r3, #32
1000224c:	5cd3      	ldrb	r3, [r2, r3]
1000224e:	2b00      	cmp	r3, #0
10002250:	d11a      	bne.n	10002288 <PWMSP001_SetPwmFreqAndDutyCycle+0xb4>
    {
      if(PwmTime > PWMSP001_MAX_VALUE)
10002252:	69ba      	ldr	r2, [r7, #24]
10002254:	4b20      	ldr	r3, [pc, #128]	; (100022d8 <PWMSP001_SetPwmFreqAndDutyCycle+0x104>)
10002256:	429a      	cmp	r2, r3
10002258:	d902      	bls.n	10002260 <PWMSP001_SetPwmFreqAndDutyCycle+0x8c>
      {
        Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
1000225a:	2302      	movs	r3, #2
1000225c:	61fb      	str	r3, [r7, #28]
1000225e:	e027      	b.n	100022b0 <PWMSP001_SetPwmFreqAndDutyCycle+0xdc>
      }
      else
      {
        if(HandlePtr->CountingModeType == PWMSP001_EDGE_ALIGNED)
10002260:	68fa      	ldr	r2, [r7, #12]
10002262:	2336      	movs	r3, #54	; 0x36
10002264:	5cd3      	ldrb	r3, [r2, r3]
10002266:	2b00      	cmp	r3, #0
10002268:	d105      	bne.n	10002276 <PWMSP001_SetPwmFreqAndDutyCycle+0xa2>
        {
          HandlePtr->CC4yRegsPtr->PRS = PwmTime -(uint32_t)1;
1000226a:	68fb      	ldr	r3, [r7, #12]
1000226c:	699b      	ldr	r3, [r3, #24]
1000226e:	69ba      	ldr	r2, [r7, #24]
10002270:	3a01      	subs	r2, #1
10002272:	635a      	str	r2, [r3, #52]	; 0x34
10002274:	e005      	b.n	10002282 <PWMSP001_SetPwmFreqAndDutyCycle+0xae>
        }
        else
        {
          HandlePtr->CC4yRegsPtr->PRS = (PwmTime - (uint32_t)1) >> (uint32_t)1;
10002276:	68fb      	ldr	r3, [r7, #12]
10002278:	699b      	ldr	r3, [r3, #24]
1000227a:	69ba      	ldr	r2, [r7, #24]
1000227c:	3a01      	subs	r2, #1
1000227e:	0852      	lsrs	r2, r2, #1
10002280:	635a      	str	r2, [r3, #52]	; 0x34
        }
        Status = (uint32_t)DAVEApp_SUCCESS;
10002282:	2300      	movs	r3, #0
10002284:	61fb      	str	r3, [r7, #28]
10002286:	e013      	b.n	100022b0 <PWMSP001_SetPwmFreqAndDutyCycle+0xdc>
      }
    }
    else if((HandlePtr->kTimerConcatenation == (uint8_t)SET) &&\
10002288:	68fa      	ldr	r2, [r7, #12]
1000228a:	2320      	movs	r3, #32
1000228c:	5cd3      	ldrb	r3, [r2, r3]
1000228e:	2b01      	cmp	r3, #1
10002290:	d106      	bne.n	100022a0 <PWMSP001_SetPwmFreqAndDutyCycle+0xcc>
10002292:	69ba      	ldr	r2, [r7, #24]
10002294:	4b10      	ldr	r3, [pc, #64]	; (100022d8 <PWMSP001_SetPwmFreqAndDutyCycle+0x104>)
10002296:	429a      	cmp	r2, r3
10002298:	d802      	bhi.n	100022a0 <PWMSP001_SetPwmFreqAndDutyCycle+0xcc>
    		                                   (PwmTime <= PWMSP001_MAX_VALUE))
    {
    	Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
1000229a:	2302      	movs	r3, #2
1000229c:	61fb      	str	r3, [r7, #28]
1000229e:	e007      	b.n	100022b0 <PWMSP001_SetPwmFreqAndDutyCycle+0xdc>
    }
    /*<<<DD_PWMSP001_API_16_3>>>*/
    else
    {
      Status = PWMSP001_lSetPwmFreqTimerConcat(HandlePtr, PwmTime);
100022a0:	68fa      	ldr	r2, [r7, #12]
100022a2:	69bb      	ldr	r3, [r7, #24]
100022a4:	1c10      	adds	r0, r2, #0
100022a6:	1c19      	adds	r1, r3, #0
100022a8:	f000 f8a4 	bl	100023f4 <PWMSP001_lSetPwmFreqTimerConcat>
100022ac:	1c03      	adds	r3, r0, #0
100022ae:	61fb      	str	r3, [r7, #28]
    }
    if(Status == (uint32_t)DAVEApp_SUCCESS)
100022b0:	69fb      	ldr	r3, [r7, #28]
100022b2:	2b00      	cmp	r3, #0
100022b4:	d106      	bne.n	100022c4 <PWMSP001_SetPwmFreqAndDutyCycle+0xf0>
    {
     /* Call the function as per configured mode */
     HandlePtr->SetDutyFuncPtr((const void*)HandlePtr, Duty);
100022b6:	68fb      	ldr	r3, [r7, #12]
100022b8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
100022ba:	68f9      	ldr	r1, [r7, #12]
100022bc:	687a      	ldr	r2, [r7, #4]
100022be:	1c08      	adds	r0, r1, #0
100022c0:	1c11      	adds	r1, r2, #0
100022c2:	4798      	blx	r3
    }
   }
  }
  return (Status);
100022c4:	69fb      	ldr	r3, [r7, #28]
}
100022c6:	1c18      	adds	r0, r3, #0
100022c8:	46bd      	mov	sp, r7
100022ca:	b008      	add	sp, #32
100022cc:	bd80      	pop	{r7, pc}
100022ce:	46c0      	nop			; (mov r8, r8)
100022d0:	42c80000 	.word	0x42c80000
100022d4:	4e6e6b28 	.word	0x4e6e6b28
100022d8:	0000ffff 	.word	0x0000ffff

100022dc <PWMSP001_SetPwmFreq>:
status_t PWMSP001_SetPwmFreq
(
    const PWMSP001_HandleType* HandlePtr,
    float PwmFreq
)
{
100022dc:	b5b0      	push	{r4, r5, r7, lr}
100022de:	b088      	sub	sp, #32
100022e0:	af00      	add	r7, sp, #0
100022e2:	6078      	str	r0, [r7, #4]
100022e4:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
100022e6:	2301      	movs	r3, #1
100022e8:	61fb      	str	r3, [r7, #28]
  uint32_t PwmTime = 0x00U;
100022ea:	2300      	movs	r3, #0
100022ec:	61bb      	str	r3, [r7, #24]
  uint32_t Temp1;
  uint32_t Temp2;
  uint32_t Temp3;
  float fPwmFreq ;
  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED))
100022ee:	687b      	ldr	r3, [r7, #4]
100022f0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100022f2:	781b      	ldrb	r3, [r3, #0]
100022f4:	2b00      	cmp	r3, #0
100022f6:	d100      	bne.n	100022fa <PWMSP001_SetPwmFreq+0x1e>
100022f8:	e072      	b.n	100023e0 <PWMSP001_SetPwmFreq+0x104>
  {
  if(PwmFreq == (float)0)
100022fa:	6838      	ldr	r0, [r7, #0]
100022fc:	2100      	movs	r1, #0
100022fe:	f000 ffe3 	bl	100032c8 <__aeabi_fcmpeq>
10002302:	1c03      	adds	r3, r0, #0
10002304:	2b00      	cmp	r3, #0
10002306:	d002      	beq.n	1000230e <PWMSP001_SetPwmFreq+0x32>
  {
    Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
10002308:	2302      	movs	r3, #2
1000230a:	61fb      	str	r3, [r7, #28]
1000230c:	e068      	b.n	100023e0 <PWMSP001_SetPwmFreq+0x104>
  }
  else
  {
	  fPwmFreq=(float)HandlePtr->kResolution;
1000230e:	687b      	ldr	r3, [r7, #4]
10002310:	685b      	ldr	r3, [r3, #4]
10002312:	617b      	str	r3, [r7, #20]
	  fPwmFreq=(float)fPwmFreq*PwmFreq;
10002314:	6978      	ldr	r0, [r7, #20]
10002316:	6839      	ldr	r1, [r7, #0]
10002318:	f001 fa0e 	bl	10003738 <__aeabi_fmul>
1000231c:	1c03      	adds	r3, r0, #0
1000231e:	617b      	str	r3, [r7, #20]
	  PwmTime = (uint32_t)((float)1000000000.00 / fPwmFreq);
10002320:	4832      	ldr	r0, [pc, #200]	; (100023ec <PWMSP001_SetPwmFreq+0x110>)
10002322:	6979      	ldr	r1, [r7, #20]
10002324:	f001 f816 	bl	10003354 <__aeabi_fdiv>
10002328:	1c03      	adds	r3, r0, #0
1000232a:	1c18      	adds	r0, r3, #0
1000232c:	f000 fffa 	bl	10003324 <__aeabi_f2uiz>
10002330:	1c03      	adds	r3, r0, #0
10002332:	61bb      	str	r3, [r7, #24]
    /*<<<DD_PWMSP001_API_16_2>>>*/
    if(HandlePtr->kTimerConcatenation == (uint8_t)RESET)
10002334:	687a      	ldr	r2, [r7, #4]
10002336:	2320      	movs	r3, #32
10002338:	5cd3      	ldrb	r3, [r2, r3]
1000233a:	2b00      	cmp	r3, #0
1000233c:	d12b      	bne.n	10002396 <PWMSP001_SetPwmFreq+0xba>
    {
      if(PwmTime > PWMSP001_MAX_VALUE)
1000233e:	69ba      	ldr	r2, [r7, #24]
10002340:	4b2b      	ldr	r3, [pc, #172]	; (100023f0 <PWMSP001_SetPwmFreq+0x114>)
10002342:	429a      	cmp	r2, r3
10002344:	d902      	bls.n	1000234c <PWMSP001_SetPwmFreq+0x70>
      {
        Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
10002346:	2302      	movs	r3, #2
10002348:	61fb      	str	r3, [r7, #28]
1000234a:	e049      	b.n	100023e0 <PWMSP001_SetPwmFreq+0x104>
      }
      else
      {
        if(HandlePtr->CountingModeType == PWMSP001_EDGE_ALIGNED)
1000234c:	687a      	ldr	r2, [r7, #4]
1000234e:	2336      	movs	r3, #54	; 0x36
10002350:	5cd3      	ldrb	r3, [r2, r3]
10002352:	2b00      	cmp	r3, #0
10002354:	d105      	bne.n	10002362 <PWMSP001_SetPwmFreq+0x86>
        {
          HandlePtr->CC4yRegsPtr->PRS = PwmTime -(uint32_t)1;
10002356:	687b      	ldr	r3, [r7, #4]
10002358:	699b      	ldr	r3, [r3, #24]
1000235a:	69ba      	ldr	r2, [r7, #24]
1000235c:	3a01      	subs	r2, #1
1000235e:	635a      	str	r2, [r3, #52]	; 0x34
10002360:	e005      	b.n	1000236e <PWMSP001_SetPwmFreq+0x92>
        }
        else
        {
          HandlePtr->CC4yRegsPtr->PRS = (PwmTime - (uint32_t)1) >> (uint32_t)1;
10002362:	687b      	ldr	r3, [r7, #4]
10002364:	699b      	ldr	r3, [r3, #24]
10002366:	69ba      	ldr	r2, [r7, #24]
10002368:	3a01      	subs	r2, #1
1000236a:	0852      	lsrs	r2, r2, #1
1000236c:	635a      	str	r2, [r3, #52]	; 0x34
        }
        /** Update dynamic handle*/
        Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4*(uint32_t)HandlePtr->FirstSlice); 
1000236e:	687a      	ldr	r2, [r7, #4]
10002370:	2337      	movs	r3, #55	; 0x37
10002372:	5cd3      	ldrb	r3, [r2, r3]
10002374:	009b      	lsls	r3, r3, #2
10002376:	613b      	str	r3, [r7, #16]
        HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1 );
10002378:	687b      	ldr	r3, [r7, #4]
1000237a:	695b      	ldr	r3, [r3, #20]
1000237c:	687a      	ldr	r2, [r7, #4]
1000237e:	6952      	ldr	r2, [r2, #20]
10002380:	6911      	ldr	r1, [r2, #16]
10002382:	693a      	ldr	r2, [r7, #16]
10002384:	2001      	movs	r0, #1
10002386:	1c04      	adds	r4, r0, #0
10002388:	4094      	lsls	r4, r2
1000238a:	1c22      	adds	r2, r4, #0
1000238c:	430a      	orrs	r2, r1
1000238e:	611a      	str	r2, [r3, #16]
        Status = (uint32_t)DAVEApp_SUCCESS;
10002390:	2300      	movs	r3, #0
10002392:	61fb      	str	r3, [r7, #28]
10002394:	e024      	b.n	100023e0 <PWMSP001_SetPwmFreq+0x104>
      }
    }
    /*<<<DD_PWMSP001_API_16_3>>>*/
    else
    {
      Status = PWMSP001_lSetPwmFreqTimerConcat(HandlePtr, PwmTime);
10002396:	687a      	ldr	r2, [r7, #4]
10002398:	69bb      	ldr	r3, [r7, #24]
1000239a:	1c10      	adds	r0, r2, #0
1000239c:	1c19      	adds	r1, r3, #0
1000239e:	f000 f829 	bl	100023f4 <PWMSP001_lSetPwmFreqTimerConcat>
100023a2:	1c03      	adds	r3, r0, #0
100023a4:	61fb      	str	r3, [r7, #28]
      if(Status == (uint32_t)DAVEApp_SUCCESS)
100023a6:	69fb      	ldr	r3, [r7, #28]
100023a8:	2b00      	cmp	r3, #0
100023aa:	d119      	bne.n	100023e0 <PWMSP001_SetPwmFreq+0x104>
      {
        Temp2 = (uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice);
100023ac:	687a      	ldr	r2, [r7, #4]
100023ae:	2337      	movs	r3, #55	; 0x37
100023b0:	5cd3      	ldrb	r3, [r2, r3]
100023b2:	009b      	lsls	r3, r3, #2
100023b4:	60fb      	str	r3, [r7, #12]
        Temp3 = (uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->SecondSlice);
100023b6:	687a      	ldr	r2, [r7, #4]
100023b8:	2338      	movs	r3, #56	; 0x38
100023ba:	5cd3      	ldrb	r3, [r2, r3]
100023bc:	009b      	lsls	r3, r3, #2
100023be:	60bb      	str	r3, [r7, #8]
        HandlePtr->CC4yKernRegsPtr->GCSS |= (((uint32_t)0x01 << Temp2) | \
100023c0:	687b      	ldr	r3, [r7, #4]
100023c2:	695b      	ldr	r3, [r3, #20]
100023c4:	687a      	ldr	r2, [r7, #4]
100023c6:	6952      	ldr	r2, [r2, #20]
100023c8:	6911      	ldr	r1, [r2, #16]
100023ca:	68fa      	ldr	r2, [r7, #12]
100023cc:	2001      	movs	r0, #1
100023ce:	4090      	lsls	r0, r2
            ((uint32_t)0x01 << Temp3));
100023d0:	68ba      	ldr	r2, [r7, #8]
100023d2:	2401      	movs	r4, #1
100023d4:	1c25      	adds	r5, r4, #0
100023d6:	4095      	lsls	r5, r2
100023d8:	1c2a      	adds	r2, r5, #0
      Status = PWMSP001_lSetPwmFreqTimerConcat(HandlePtr, PwmTime);
      if(Status == (uint32_t)DAVEApp_SUCCESS)
      {
        Temp2 = (uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice);
        Temp3 = (uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->SecondSlice);
        HandlePtr->CC4yKernRegsPtr->GCSS |= (((uint32_t)0x01 << Temp2) | \
100023da:	4302      	orrs	r2, r0
100023dc:	430a      	orrs	r2, r1
100023de:	611a      	str	r2, [r3, #16]
            ((uint32_t)0x01 << Temp3));
      }
    }
  }
 }
  return (Status);
100023e0:	69fb      	ldr	r3, [r7, #28]
}
100023e2:	1c18      	adds	r0, r3, #0
100023e4:	46bd      	mov	sp, r7
100023e6:	b008      	add	sp, #32
100023e8:	bdb0      	pop	{r4, r5, r7, pc}
100023ea:	46c0      	nop			; (mov r8, r8)
100023ec:	4e6e6b28 	.word	0x4e6e6b28
100023f0:	0000ffff 	.word	0x0000ffff

100023f4 <PWMSP001_lSetPwmFreqTimerConcat>:
status_t PWMSP001_lSetPwmFreqTimerConcat
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t PwmTime
)
{
100023f4:	b580      	push	{r7, lr}
100023f6:	b088      	sub	sp, #32
100023f8:	af00      	add	r7, sp, #0
100023fa:	6078      	str	r0, [r7, #4]
100023fc:	6039      	str	r1, [r7, #0]
  uint32_t PeriodVal = PwmTime;
100023fe:	683b      	ldr	r3, [r7, #0]
10002400:	61fb      	str	r3, [r7, #28]
  uint32_t MsbPeriodVal, LsbPeriodVal;
  uint8_t Count = 0x00U;
10002402:	1c3b      	adds	r3, r7, #0
10002404:	3313      	adds	r3, #19
10002406:	2200      	movs	r2, #0
10002408:	701a      	strb	r2, [r3, #0]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
1000240a:	2301      	movs	r3, #1
1000240c:	60fb      	str	r3, [r7, #12]

  if(PwmTime >= PWMSP001_TC_MAX_VALUE)
1000240e:	683b      	ldr	r3, [r7, #0]
10002410:	3301      	adds	r3, #1
10002412:	d102      	bne.n	1000241a <PWMSP001_lSetPwmFreqTimerConcat+0x26>
  {
    Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
10002414:	2302      	movs	r3, #2
10002416:	60fb      	str	r3, [r7, #12]
10002418:	e03a      	b.n	10002490 <PWMSP001_lSetPwmFreqTimerConcat+0x9c>
  }

  else
  {

    if(PwmTime > PWMSP001_MAX_VALUE)
1000241a:	683a      	ldr	r2, [r7, #0]
1000241c:	4b1f      	ldr	r3, [pc, #124]	; (1000249c <PWMSP001_lSetPwmFreqTimerConcat+0xa8>)
1000241e:	429a      	cmp	r2, r3
10002420:	d919      	bls.n	10002456 <PWMSP001_lSetPwmFreqTimerConcat+0x62>
    {
      do
      {
        PeriodVal = PeriodVal >> 1;
10002422:	69fb      	ldr	r3, [r7, #28]
10002424:	085b      	lsrs	r3, r3, #1
10002426:	61fb      	str	r3, [r7, #28]
        Count++;
10002428:	1c3b      	adds	r3, r7, #0
1000242a:	3313      	adds	r3, #19
1000242c:	1c3a      	adds	r2, r7, #0
1000242e:	3213      	adds	r2, #19
10002430:	7812      	ldrb	r2, [r2, #0]
10002432:	3201      	adds	r2, #1
10002434:	701a      	strb	r2, [r3, #0]
      }while(PeriodVal >= PWMSP001_MAX_VALUE);
10002436:	69fa      	ldr	r2, [r7, #28]
10002438:	4b19      	ldr	r3, [pc, #100]	; (100024a0 <PWMSP001_lSetPwmFreqTimerConcat+0xac>)
1000243a:	429a      	cmp	r2, r3
1000243c:	d8f1      	bhi.n	10002422 <PWMSP001_lSetPwmFreqTimerConcat+0x2e>

      MsbPeriodVal = ((uint32_t)1 << Count) -(uint32_t)1;
1000243e:	1c3b      	adds	r3, r7, #0
10002440:	3313      	adds	r3, #19
10002442:	781b      	ldrb	r3, [r3, #0]
10002444:	2201      	movs	r2, #1
10002446:	1c11      	adds	r1, r2, #0
10002448:	4099      	lsls	r1, r3
1000244a:	1c0b      	adds	r3, r1, #0
1000244c:	3b01      	subs	r3, #1
1000244e:	61bb      	str	r3, [r7, #24]
      LsbPeriodVal = PeriodVal;
10002450:	69fb      	ldr	r3, [r7, #28]
10002452:	617b      	str	r3, [r7, #20]
10002454:	e003      	b.n	1000245e <PWMSP001_lSetPwmFreqTimerConcat+0x6a>
    }
    else
    {
      LsbPeriodVal = PwmTime;
10002456:	683b      	ldr	r3, [r7, #0]
10002458:	617b      	str	r3, [r7, #20]
      MsbPeriodVal = (uint32_t)0x00;
1000245a:	2300      	movs	r3, #0
1000245c:	61bb      	str	r3, [r7, #24]
    }

    /*<<<DD_PWMSP001_API_16_4>>>*/
    if(HandlePtr->CountingModeType == PWMSP001_CENTER_ALIGNED)
1000245e:	687a      	ldr	r2, [r7, #4]
10002460:	2336      	movs	r3, #54	; 0x36
10002462:	5cd3      	ldrb	r3, [r2, r3]
10002464:	2b01      	cmp	r3, #1
10002466:	d105      	bne.n	10002474 <PWMSP001_lSetPwmFreqTimerConcat+0x80>
    {
      MsbPeriodVal = MsbPeriodVal >> (uint32_t)1;
10002468:	69bb      	ldr	r3, [r7, #24]
1000246a:	085b      	lsrs	r3, r3, #1
1000246c:	61bb      	str	r3, [r7, #24]
      LsbPeriodVal = LsbPeriodVal >> (uint32_t)1;
1000246e:	697b      	ldr	r3, [r7, #20]
10002470:	085b      	lsrs	r3, r3, #1
10002472:	617b      	str	r3, [r7, #20]
    }

    HandlePtr->CC4yRegsPtr->PRS = LsbPeriodVal & 0xFFFFU;
10002474:	687b      	ldr	r3, [r7, #4]
10002476:	699b      	ldr	r3, [r3, #24]
10002478:	697a      	ldr	r2, [r7, #20]
1000247a:	0412      	lsls	r2, r2, #16
1000247c:	0c12      	lsrs	r2, r2, #16
1000247e:	635a      	str	r2, [r3, #52]	; 0x34
    HandlePtr->CC4yRegs1Ptr->PRS =MsbPeriodVal & 0xFFFFU;
10002480:	687b      	ldr	r3, [r7, #4]
10002482:	69db      	ldr	r3, [r3, #28]
10002484:	69ba      	ldr	r2, [r7, #24]
10002486:	0412      	lsls	r2, r2, #16
10002488:	0c12      	lsrs	r2, r2, #16
1000248a:	635a      	str	r2, [r3, #52]	; 0x34

    /*<<<DD_PWMSP001_API_16_5>>>*/
    Status = (uint32_t)DAVEApp_SUCCESS;
1000248c:	2300      	movs	r3, #0
1000248e:	60fb      	str	r3, [r7, #12]
  }
  return (Status);
10002490:	68fb      	ldr	r3, [r7, #12]
}
10002492:	1c18      	adds	r0, r3, #0
10002494:	46bd      	mov	sp, r7
10002496:	b008      	add	sp, #32
10002498:	bd80      	pop	{r7, pc}
1000249a:	46c0      	nop			; (mov r8, r8)
1000249c:	0000ffff 	.word	0x0000ffff
100024a0:	0000fffe 	.word	0x0000fffe

100024a4 <PWMSP001_SetTimerVal>:
status_t PWMSP001_SetTimerVal
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t TimerVal
)
{
100024a4:	b580      	push	{r7, lr}
100024a6:	b084      	sub	sp, #16
100024a8:	af00      	add	r7, sp, #0
100024aa:	6078      	str	r0, [r7, #4]
100024ac:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
100024ae:	2301      	movs	r3, #1
100024b0:	60fb      	str	r3, [r7, #12]
  /*<<<DD_PWMSP001_API_7_1>>>*/
  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_INITIALIZED) &&
100024b2:	687b      	ldr	r3, [r7, #4]
100024b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100024b6:	781b      	ldrb	r3, [r3, #0]
100024b8:	2b01      	cmp	r3, #1
100024ba:	d004      	beq.n	100024c6 <PWMSP001_SetTimerVal+0x22>
      (HandlePtr->DynamicDataType->StateType != PWMSP001_STOPPED))
100024bc:	687b      	ldr	r3, [r7, #4]
100024be:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100024c0:	781b      	ldrb	r3, [r3, #0]
    uint32_t TimerVal
)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
  /*<<<DD_PWMSP001_API_7_1>>>*/
  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_INITIALIZED) &&
100024c2:	2b03      	cmp	r3, #3
100024c4:	d111      	bne.n	100024ea <PWMSP001_SetTimerVal+0x46>
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  /*<<<DD_PWMSP001_API_7_1>>>*/
  else
  {
    HandlePtr->CC4yRegsPtr->TIMER = (uint32_t)TimerVal&0xFFFFU;
100024c6:	687b      	ldr	r3, [r7, #4]
100024c8:	699b      	ldr	r3, [r3, #24]
100024ca:	683a      	ldr	r2, [r7, #0]
100024cc:	0412      	lsls	r2, r2, #16
100024ce:	0c12      	lsrs	r2, r2, #16
100024d0:	671a      	str	r2, [r3, #112]	; 0x70
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
100024d2:	687a      	ldr	r2, [r7, #4]
100024d4:	2320      	movs	r3, #32
100024d6:	5cd3      	ldrb	r3, [r2, r3]
100024d8:	2b01      	cmp	r3, #1
100024da:	d104      	bne.n	100024e6 <PWMSP001_SetTimerVal+0x42>
    {
      HandlePtr->CC4yRegs1Ptr->TIMER = (uint32_t)((uint32_t)TimerVal>>16U)&0xFFFFU;
100024dc:	687b      	ldr	r3, [r7, #4]
100024de:	69db      	ldr	r3, [r3, #28]
100024e0:	683a      	ldr	r2, [r7, #0]
100024e2:	0c12      	lsrs	r2, r2, #16
100024e4:	671a      	str	r2, [r3, #112]	; 0x70
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
100024e6:	2300      	movs	r3, #0
100024e8:	60fb      	str	r3, [r7, #12]
  }
  return Status;
100024ea:	68fb      	ldr	r3, [r7, #12]
}
100024ec:	1c18      	adds	r0, r3, #0
100024ee:	46bd      	mov	sp, r7
100024f0:	b004      	add	sp, #16
100024f2:	bd80      	pop	{r7, pc}

100024f4 <PWMSP001_GetTimerStatus>:
status_t PWMSP001_GetTimerStatus
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t* TimerStatus
)
{
100024f4:	b580      	push	{r7, lr}
100024f6:	b084      	sub	sp, #16
100024f8:	af00      	add	r7, sp, #0
100024fa:	6078      	str	r0, [r7, #4]
100024fc:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
100024fe:	2301      	movs	r3, #1
10002500:	60fb      	str	r3, [r7, #12]
  uint32_t SecondTimerStatus = (uint32_t)0;
10002502:	2300      	movs	r3, #0
10002504:	60bb      	str	r3, [r7, #8]
  /*<<<DD_PWMSP001_API_8_1>>>*/
  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
10002506:	687b      	ldr	r3, [r7, #4]
10002508:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
1000250a:	781b      	ldrb	r3, [r3, #0]
1000250c:	2b00      	cmp	r3, #0
1000250e:	d01d      	beq.n	1000254c <PWMSP001_GetTimerStatus+0x58>
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  /*<<<DD_PWMSP001_API_8_2>>>*/
  else
  {
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
10002510:	687a      	ldr	r2, [r7, #4]
10002512:	2320      	movs	r3, #32
10002514:	5cd3      	ldrb	r3, [r2, r3]
10002516:	2b01      	cmp	r3, #1
10002518:	d10f      	bne.n	1000253a <PWMSP001_GetTimerStatus+0x46>
    {
      SecondTimerStatus = (uint32_t)(RD_REG(HandlePtr->CC4yRegs1Ptr->TCST,
1000251a:	687b      	ldr	r3, [r7, #4]
1000251c:	69db      	ldr	r3, [r3, #28]
1000251e:	689a      	ldr	r2, [r3, #8]
10002520:	2301      	movs	r3, #1
10002522:	4013      	ands	r3, r2
10002524:	60bb      	str	r3, [r7, #8]
          CCU4_CC4_TCST_TRB_Msk, CCU4_CC4_TCST_TRB_Pos));
      *TimerStatus = (uint32_t)((RD_REG(HandlePtr->CC4yRegsPtr->TCST,
10002526:	687b      	ldr	r3, [r7, #4]
10002528:	699b      	ldr	r3, [r3, #24]
1000252a:	689b      	ldr	r3, [r3, #8]
1000252c:	68ba      	ldr	r2, [r7, #8]
1000252e:	401a      	ands	r2, r3
10002530:	2301      	movs	r3, #1
10002532:	401a      	ands	r2, r3
10002534:	683b      	ldr	r3, [r7, #0]
10002536:	601a      	str	r2, [r3, #0]
10002538:	e006      	b.n	10002548 <PWMSP001_GetTimerStatus+0x54>
          SecondTimerStatus
      );
    }
    else
    {
      *TimerStatus = (uint32_t) RD_REG(HandlePtr->CC4yRegsPtr->TCST,
1000253a:	687b      	ldr	r3, [r7, #4]
1000253c:	699b      	ldr	r3, [r3, #24]
1000253e:	689a      	ldr	r2, [r3, #8]
10002540:	2301      	movs	r3, #1
10002542:	401a      	ands	r2, r3
10002544:	683b      	ldr	r3, [r7, #0]
10002546:	601a      	str	r2, [r3, #0]
          CCU4_CC4_TCST_TRB_Msk, CCU4_CC4_TCST_TRB_Pos);
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
10002548:	2300      	movs	r3, #0
1000254a:	60fb      	str	r3, [r7, #12]
  }
  return Status; 
1000254c:	68fb      	ldr	r3, [r7, #12]
}
1000254e:	1c18      	adds	r0, r3, #0
10002550:	46bd      	mov	sp, r7
10002552:	b004      	add	sp, #16
10002554:	bd80      	pop	{r7, pc}
10002556:	46c0      	nop			; (mov r8, r8)

10002558 <PWMSP001_GetTimerRegsVal>:
status_t PWMSP001_GetTimerRegsVal
(
    const PWMSP001_HandleType* HandlePtr,
    PWMSP001_TimerRegsType* TimerRegs
)
{
10002558:	b580      	push	{r7, lr}
1000255a:	b084      	sub	sp, #16
1000255c:	af00      	add	r7, sp, #0
1000255e:	6078      	str	r0, [r7, #4]
10002560:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
10002562:	2301      	movs	r3, #1
10002564:	60fb      	str	r3, [r7, #12]
  uint32_t ScndSlTMRVal = 0UL;
10002566:	2300      	movs	r3, #0
10002568:	60bb      	str	r3, [r7, #8]

  /*<<<DD_PWMSP001_API_9_1>>>*/
  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
1000256a:	687b      	ldr	r3, [r7, #4]
1000256c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
1000256e:	781b      	ldrb	r3, [r3, #0]
10002570:	2b00      	cmp	r3, #0
10002572:	d051      	beq.n	10002618 <PWMSP001_GetTimerRegsVal+0xc0>
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  /*<<<DD_PWMSP001_API_9_2>>>*/
  else
  {
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
10002574:	687a      	ldr	r2, [r7, #4]
10002576:	2320      	movs	r3, #32
10002578:	5cd3      	ldrb	r3, [r2, r3]
1000257a:	2b01      	cmp	r3, #1
1000257c:	d139      	bne.n	100025f2 <PWMSP001_GetTimerRegsVal+0x9a>
    {
      ScndSlTMRVal = (RD_REG(HandlePtr->CC4yRegs1Ptr->TIMER,
1000257e:	687b      	ldr	r3, [r7, #4]
10002580:	69db      	ldr	r3, [r3, #28]
10002582:	6f1b      	ldr	r3, [r3, #112]	; 0x70
10002584:	041b      	lsls	r3, r3, #16
10002586:	60bb      	str	r3, [r7, #8]
          CCU4_CC4_TIMER_TVAL_Msk, CCU4_CC4_TIMER_TVAL_Pos) << 16UL);

      TimerRegs->TimerReg = (uint32_t)(ScndSlTMRVal |
          (RD_REG(HandlePtr->CC4yRegsPtr->TIMER,
10002588:	687b      	ldr	r3, [r7, #4]
1000258a:	699b      	ldr	r3, [r3, #24]
1000258c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
1000258e:	041b      	lsls	r3, r3, #16
10002590:	0c1a      	lsrs	r2, r3, #16
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
    {
      ScndSlTMRVal = (RD_REG(HandlePtr->CC4yRegs1Ptr->TIMER,
          CCU4_CC4_TIMER_TVAL_Msk, CCU4_CC4_TIMER_TVAL_Pos) << 16UL);

      TimerRegs->TimerReg = (uint32_t)(ScndSlTMRVal |
10002592:	68bb      	ldr	r3, [r7, #8]
10002594:	431a      	orrs	r2, r3
10002596:	683b      	ldr	r3, [r7, #0]
10002598:	609a      	str	r2, [r3, #8]
          (RD_REG(HandlePtr->CC4yRegsPtr->TIMER,
              CCU4_CC4_TIMER_TVAL_Msk, CCU4_CC4_TIMER_TVAL_Pos)));

      TimerRegs->CompReg = HandlePtr->CC4yRegs1Ptr->CRS; 
1000259a:	687b      	ldr	r3, [r7, #4]
1000259c:	69db      	ldr	r3, [r3, #28]
1000259e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
100025a0:	683b      	ldr	r3, [r7, #0]
100025a2:	601a      	str	r2, [r3, #0]
      TimerRegs->CompReg*= HandlePtr->CC4yRegsPtr->PRS;
100025a4:	683b      	ldr	r3, [r7, #0]
100025a6:	681a      	ldr	r2, [r3, #0]
100025a8:	687b      	ldr	r3, [r7, #4]
100025aa:	699b      	ldr	r3, [r3, #24]
100025ac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
100025ae:	435a      	muls	r2, r3
100025b0:	683b      	ldr	r3, [r7, #0]
100025b2:	601a      	str	r2, [r3, #0]
      TimerRegs->CompReg += HandlePtr->CC4yRegsPtr->CRS;
100025b4:	683b      	ldr	r3, [r7, #0]
100025b6:	681a      	ldr	r2, [r3, #0]
100025b8:	687b      	ldr	r3, [r7, #4]
100025ba:	699b      	ldr	r3, [r3, #24]
100025bc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100025be:	18d2      	adds	r2, r2, r3
100025c0:	683b      	ldr	r3, [r7, #0]
100025c2:	601a      	str	r2, [r3, #0]
      TimerRegs->PeriodReg = HandlePtr->CC4yRegs1Ptr->PRS+ 1U;
100025c4:	687b      	ldr	r3, [r7, #4]
100025c6:	69db      	ldr	r3, [r3, #28]
100025c8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
100025ca:	1c5a      	adds	r2, r3, #1
100025cc:	683b      	ldr	r3, [r7, #0]
100025ce:	605a      	str	r2, [r3, #4]
      TimerRegs->PeriodReg *= (uint32_t)((HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU) +1U);
100025d0:	683b      	ldr	r3, [r7, #0]
100025d2:	685a      	ldr	r2, [r3, #4]
100025d4:	687b      	ldr	r3, [r7, #4]
100025d6:	699b      	ldr	r3, [r3, #24]
100025d8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
100025da:	041b      	lsls	r3, r3, #16
100025dc:	0c1b      	lsrs	r3, r3, #16
100025de:	3301      	adds	r3, #1
100025e0:	435a      	muls	r2, r3
100025e2:	683b      	ldr	r3, [r7, #0]
100025e4:	605a      	str	r2, [r3, #4]
      TimerRegs->PeriodReg += 1U ;
100025e6:	683b      	ldr	r3, [r7, #0]
100025e8:	685b      	ldr	r3, [r3, #4]
100025ea:	1c5a      	adds	r2, r3, #1
100025ec:	683b      	ldr	r3, [r7, #0]
100025ee:	605a      	str	r2, [r3, #4]
100025f0:	e010      	b.n	10002614 <PWMSP001_GetTimerRegsVal+0xbc>
    }

    else
    {
      TimerRegs->TimerReg = (uint32_t)RD_REG(HandlePtr->CC4yRegsPtr->TIMER,
100025f2:	687b      	ldr	r3, [r7, #4]
100025f4:	699b      	ldr	r3, [r3, #24]
100025f6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
100025f8:	041b      	lsls	r3, r3, #16
100025fa:	0c1a      	lsrs	r2, r3, #16
100025fc:	683b      	ldr	r3, [r7, #0]
100025fe:	609a      	str	r2, [r3, #8]
          CCU4_CC4_TIMER_TVAL_Msk, CCU4_CC4_TIMER_TVAL_Pos);

      TimerRegs->CompReg = HandlePtr->CC4yRegsPtr->CRS;
10002600:	687b      	ldr	r3, [r7, #4]
10002602:	699b      	ldr	r3, [r3, #24]
10002604:	6bda      	ldr	r2, [r3, #60]	; 0x3c
10002606:	683b      	ldr	r3, [r7, #0]
10002608:	601a      	str	r2, [r3, #0]
      TimerRegs->PeriodReg = HandlePtr->CC4yRegsPtr->PRS;
1000260a:	687b      	ldr	r3, [r7, #4]
1000260c:	699b      	ldr	r3, [r3, #24]
1000260e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
10002610:	683b      	ldr	r3, [r7, #0]
10002612:	605a      	str	r2, [r3, #4]

    }
    Status = (uint32_t)DAVEApp_SUCCESS;
10002614:	2300      	movs	r3, #0
10002616:	60fb      	str	r3, [r7, #12]
  }
  return Status;
10002618:	68fb      	ldr	r3, [r7, #12]
}
1000261a:	1c18      	adds	r0, r3, #0
1000261c:	46bd      	mov	sp, r7
1000261e:	b004      	add	sp, #16
10002620:	bd80      	pop	{r7, pc}
10002622:	46c0      	nop			; (mov r8, r8)

10002624 <PWMSP001_GetPeriodReg>:
status_t PWMSP001_GetPeriodReg
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t* PeriodReg
)
{
10002624:	b580      	push	{r7, lr}
10002626:	b084      	sub	sp, #16
10002628:	af00      	add	r7, sp, #0
1000262a:	6078      	str	r0, [r7, #4]
1000262c:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
1000262e:	2301      	movs	r3, #1
10002630:	60fb      	str	r3, [r7, #12]

  /*<<<DD_PWMSP001_API_15_1>>>*/
  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
10002632:	687b      	ldr	r3, [r7, #4]
10002634:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10002636:	781b      	ldrb	r3, [r3, #0]
10002638:	2b00      	cmp	r3, #0
1000263a:	d022      	beq.n	10002682 <PWMSP001_GetPeriodReg+0x5e>
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  else
  {
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
1000263c:	687a      	ldr	r2, [r7, #4]
1000263e:	2320      	movs	r3, #32
10002640:	5cd3      	ldrb	r3, [r2, r3]
10002642:	2b01      	cmp	r3, #1
10002644:	d116      	bne.n	10002674 <PWMSP001_GetPeriodReg+0x50>
    {
      *PeriodReg = (HandlePtr->CC4yRegs1Ptr->PRS + 1U);
10002646:	687b      	ldr	r3, [r7, #4]
10002648:	69db      	ldr	r3, [r3, #28]
1000264a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
1000264c:	1c5a      	adds	r2, r3, #1
1000264e:	683b      	ldr	r3, [r7, #0]
10002650:	601a      	str	r2, [r3, #0]
      *PeriodReg  *=(uint32_t)((HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU) +1U);
10002652:	683b      	ldr	r3, [r7, #0]
10002654:	681a      	ldr	r2, [r3, #0]
10002656:	687b      	ldr	r3, [r7, #4]
10002658:	699b      	ldr	r3, [r3, #24]
1000265a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
1000265c:	041b      	lsls	r3, r3, #16
1000265e:	0c1b      	lsrs	r3, r3, #16
10002660:	3301      	adds	r3, #1
10002662:	435a      	muls	r2, r3
10002664:	683b      	ldr	r3, [r7, #0]
10002666:	601a      	str	r2, [r3, #0]
      *PeriodReg  += 1U;
10002668:	683b      	ldr	r3, [r7, #0]
1000266a:	681b      	ldr	r3, [r3, #0]
1000266c:	1c5a      	adds	r2, r3, #1
1000266e:	683b      	ldr	r3, [r7, #0]
10002670:	601a      	str	r2, [r3, #0]
10002672:	e004      	b.n	1000267e <PWMSP001_GetPeriodReg+0x5a>
    }
    else
    {
      *PeriodReg = HandlePtr->CC4yRegsPtr->PRS;
10002674:	687b      	ldr	r3, [r7, #4]
10002676:	699b      	ldr	r3, [r3, #24]
10002678:	6b5a      	ldr	r2, [r3, #52]	; 0x34
1000267a:	683b      	ldr	r3, [r7, #0]
1000267c:	601a      	str	r2, [r3, #0]
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
1000267e:	2300      	movs	r3, #0
10002680:	60fb      	str	r3, [r7, #12]
  }
  return Status;
10002682:	68fb      	ldr	r3, [r7, #12]
}
10002684:	1c18      	adds	r0, r3, #0
10002686:	46bd      	mov	sp, r7
10002688:	b004      	add	sp, #16
1000268a:	bd80      	pop	{r7, pc}

1000268c <PWMSP001_SWRequestShadowTransfer>:
 */
status_t PWMSP001_SWRequestShadowTransfer
(
    const PWMSP001_HandleType* HandlePtr
)
{
1000268c:	b5b0      	push	{r4, r5, r7, lr}
1000268e:	b086      	sub	sp, #24
10002690:	af00      	add	r7, sp, #0
10002692:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
10002694:	2301      	movs	r3, #1
10002696:	617b      	str	r3, [r7, #20]
  uint32_t Temp1;
  uint32_t Temp2;
  uint32_t Temp3;

  /*<<<DD_PWMSP001_API_10_1>>>*/
  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
10002698:	687b      	ldr	r3, [r7, #4]
1000269a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
1000269c:	781b      	ldrb	r3, [r3, #0]
1000269e:	2b00      	cmp	r3, #0
100026a0:	d032      	beq.n	10002708 <PWMSP001_SWRequestShadowTransfer+0x7c>
  }
  /*<<<DD_PWMSP001_API_10_2>>>*/
  else
  {
    /*Request shadow transfer for the First Slice*/
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
100026a2:	687a      	ldr	r2, [r7, #4]
100026a4:	2320      	movs	r3, #32
100026a6:	5cd3      	ldrb	r3, [r2, r3]
100026a8:	2b01      	cmp	r3, #1
100026aa:	d11a      	bne.n	100026e2 <PWMSP001_SWRequestShadowTransfer+0x56>
    {
      /*Request shadow transfer for the Second Slice*/
      Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4 * (uint32_t)HandlePtr->FirstSlice);
100026ac:	687a      	ldr	r2, [r7, #4]
100026ae:	2337      	movs	r3, #55	; 0x37
100026b0:	5cd3      	ldrb	r3, [r2, r3]
100026b2:	009b      	lsls	r3, r3, #2
100026b4:	613b      	str	r3, [r7, #16]
      Temp2 = (uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4*(uint32_t)HandlePtr->SecondSlice);
100026b6:	687a      	ldr	r2, [r7, #4]
100026b8:	2338      	movs	r3, #56	; 0x38
100026ba:	5cd3      	ldrb	r3, [r2, r3]
100026bc:	009b      	lsls	r3, r3, #2
100026be:	60fb      	str	r3, [r7, #12]
      HandlePtr->CC4yKernRegsPtr->GCSS |=  ((uint32_t)0x01 << Temp1) | ((uint32_t)0x01 << Temp2);
100026c0:	687b      	ldr	r3, [r7, #4]
100026c2:	695b      	ldr	r3, [r3, #20]
100026c4:	687a      	ldr	r2, [r7, #4]
100026c6:	6952      	ldr	r2, [r2, #20]
100026c8:	6911      	ldr	r1, [r2, #16]
100026ca:	693a      	ldr	r2, [r7, #16]
100026cc:	2001      	movs	r0, #1
100026ce:	4090      	lsls	r0, r2
100026d0:	68fa      	ldr	r2, [r7, #12]
100026d2:	2401      	movs	r4, #1
100026d4:	1c25      	adds	r5, r4, #0
100026d6:	4095      	lsls	r5, r2
100026d8:	1c2a      	adds	r2, r5, #0
100026da:	4302      	orrs	r2, r0
100026dc:	430a      	orrs	r2, r1
100026de:	611a      	str	r2, [r3, #16]
100026e0:	e010      	b.n	10002704 <PWMSP001_SWRequestShadowTransfer+0x78>
    }
    else
    {
      Temp3 =  (uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice);
100026e2:	687a      	ldr	r2, [r7, #4]
100026e4:	2337      	movs	r3, #55	; 0x37
100026e6:	5cd3      	ldrb	r3, [r2, r3]
100026e8:	009b      	lsls	r3, r3, #2
100026ea:	60bb      	str	r3, [r7, #8]
      HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp3);
100026ec:	687b      	ldr	r3, [r7, #4]
100026ee:	695b      	ldr	r3, [r3, #20]
100026f0:	687a      	ldr	r2, [r7, #4]
100026f2:	6952      	ldr	r2, [r2, #20]
100026f4:	6911      	ldr	r1, [r2, #16]
100026f6:	68ba      	ldr	r2, [r7, #8]
100026f8:	2001      	movs	r0, #1
100026fa:	1c04      	adds	r4, r0, #0
100026fc:	4094      	lsls	r4, r2
100026fe:	1c22      	adds	r2, r4, #0
10002700:	430a      	orrs	r2, r1
10002702:	611a      	str	r2, [r3, #16]
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
10002704:	2300      	movs	r3, #0
10002706:	617b      	str	r3, [r7, #20]
  }
  return Status;
10002708:	697b      	ldr	r3, [r7, #20]
}
1000270a:	1c18      	adds	r0, r3, #0
1000270c:	46bd      	mov	sp, r7
1000270e:	b006      	add	sp, #24
10002710:	bdb0      	pop	{r4, r5, r7, pc}
10002712:	46c0      	nop			; (mov r8, r8)

10002714 <PWMSP001_ResetTrapFlag>:
/*<<<DD_PWMSP001_API_13>>>*/
/*
 * This function resets the trap flag if trap condition is inactive
 */
void PWMSP001_ResetTrapFlag(const PWMSP001_HandleType* HandlePtr)
{
10002714:	b580      	push	{r7, lr}
10002716:	b082      	sub	sp, #8
10002718:	af00      	add	r7, sp, #0
1000271a:	6078      	str	r0, [r7, #4]
   if (HandlePtr->kTrapExitControl == (uint8_t)SET)
1000271c:	687b      	ldr	r3, [r7, #4]
1000271e:	7cdb      	ldrb	r3, [r3, #19]
10002720:	2b01      	cmp	r3, #1
10002722:	d11a      	bne.n	1000275a <PWMSP001_ResetTrapFlag+0x46>
    {
      SET_BIT(HandlePtr->CC4yRegsPtr->SWR, PWMSP001_EVENT2_INTERRUPT);
10002724:	687b      	ldr	r3, [r7, #4]
10002726:	699a      	ldr	r2, [r3, #24]
10002728:	687b      	ldr	r3, [r7, #4]
1000272a:	6999      	ldr	r1, [r3, #24]
1000272c:	23b0      	movs	r3, #176	; 0xb0
1000272e:	58cb      	ldr	r3, [r1, r3]
10002730:	2180      	movs	r1, #128	; 0x80
10002732:	00c9      	lsls	r1, r1, #3
10002734:	4319      	orrs	r1, r3
10002736:	23b0      	movs	r3, #176	; 0xb0
10002738:	50d1      	str	r1, [r2, r3]
      if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
1000273a:	687a      	ldr	r2, [r7, #4]
1000273c:	2320      	movs	r3, #32
1000273e:	5cd3      	ldrb	r3, [r2, r3]
10002740:	2b01      	cmp	r3, #1
10002742:	d10a      	bne.n	1000275a <PWMSP001_ResetTrapFlag+0x46>
      {
        SET_BIT(HandlePtr->CC4yRegs1Ptr->SWR, PWMSP001_EVENT2_INTERRUPT);
10002744:	687b      	ldr	r3, [r7, #4]
10002746:	69da      	ldr	r2, [r3, #28]
10002748:	687b      	ldr	r3, [r7, #4]
1000274a:	69d9      	ldr	r1, [r3, #28]
1000274c:	23b0      	movs	r3, #176	; 0xb0
1000274e:	58cb      	ldr	r3, [r1, r3]
10002750:	2180      	movs	r1, #128	; 0x80
10002752:	00c9      	lsls	r1, r1, #3
10002754:	4319      	orrs	r1, r3
10002756:	23b0      	movs	r3, #176	; 0xb0
10002758:	50d1      	str	r1, [r2, r3]
      }
    }
    SET_BIT(HandlePtr->CC4yRegsPtr->SWR, PWMSP001_TRAP_FLAG_CLEAR);
1000275a:	687b      	ldr	r3, [r7, #4]
1000275c:	699a      	ldr	r2, [r3, #24]
1000275e:	687b      	ldr	r3, [r7, #4]
10002760:	6999      	ldr	r1, [r3, #24]
10002762:	23b0      	movs	r3, #176	; 0xb0
10002764:	58cb      	ldr	r3, [r1, r3]
10002766:	2180      	movs	r1, #128	; 0x80
10002768:	0109      	lsls	r1, r1, #4
1000276a:	4319      	orrs	r1, r3
1000276c:	23b0      	movs	r3, #176	; 0xb0
1000276e:	50d1      	str	r1, [r2, r3]
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
10002770:	687a      	ldr	r2, [r7, #4]
10002772:	2320      	movs	r3, #32
10002774:	5cd3      	ldrb	r3, [r2, r3]
10002776:	2b01      	cmp	r3, #1
10002778:	d10a      	bne.n	10002790 <PWMSP001_ResetTrapFlag+0x7c>
    {
      SET_BIT(HandlePtr->CC4yRegs1Ptr->SWR, PWMSP001_TRAP_FLAG_CLEAR);
1000277a:	687b      	ldr	r3, [r7, #4]
1000277c:	69da      	ldr	r2, [r3, #28]
1000277e:	687b      	ldr	r3, [r7, #4]
10002780:	69d9      	ldr	r1, [r3, #28]
10002782:	23b0      	movs	r3, #176	; 0xb0
10002784:	58cb      	ldr	r3, [r1, r3]
10002786:	2180      	movs	r1, #128	; 0x80
10002788:	0109      	lsls	r1, r1, #4
1000278a:	4319      	orrs	r1, r3
1000278c:	23b0      	movs	r3, #176	; 0xb0
1000278e:	50d1      	str	r1, [r2, r3]
    }
}
10002790:	46bd      	mov	sp, r7
10002792:	b002      	add	sp, #8
10002794:	bd80      	pop	{r7, pc}
10002796:	46c0      	nop			; (mov r8, r8)

10002798 <PWMSP001_lConfigureSecondSlice>:
/*
 * This function configures second slice.
 */

void PWMSP001_lConfigureSecondSlice(const PWMSP001_HandleType* HandlePtr)
{
10002798:	b5b0      	push	{r4, r5, r7, lr}
1000279a:	b082      	sub	sp, #8
1000279c:	af00      	add	r7, sp, #0
1000279e:	6078      	str	r0, [r7, #4]
  HandlePtr->CC4yRegs1Ptr->TCCLR = PWMSP001_SLICE_CLEAR;
100027a0:	687b      	ldr	r3, [r7, #4]
100027a2:	69db      	ldr	r3, [r3, #28]
100027a4:	2207      	movs	r2, #7
100027a6:	611a      	str	r2, [r3, #16]

  /*Set period and compare values for second slice*/
  HandlePtr->CC4yRegs1Ptr->PRS = (uint32_t)((HandlePtr->kPeriodVal & 0xFFFF0000U)
100027a8:	687b      	ldr	r3, [r7, #4]
100027aa:	69db      	ldr	r3, [r3, #28]
100027ac:	687a      	ldr	r2, [r7, #4]
100027ae:	6a92      	ldr	r2, [r2, #40]	; 0x28
100027b0:	0c12      	lsrs	r2, r2, #16
100027b2:	635a      	str	r2, [r3, #52]	; 0x34
      >> 16U);
  HandlePtr->CC4yRegs1Ptr->CRS =(uint32_t)((HandlePtr->kCompareValue & 0xFFFF0000U)
100027b4:	687b      	ldr	r3, [r7, #4]
100027b6:	69db      	ldr	r3, [r3, #28]
100027b8:	687a      	ldr	r2, [r7, #4]
100027ba:	6892      	ldr	r2, [r2, #8]
100027bc:	0c12      	lsrs	r2, r2, #16
100027be:	63da      	str	r2, [r3, #60]	; 0x3c
      >> 16U);

  HandlePtr->CC4yRegs1Ptr->CMC |= ((uint32_t)0x01 << (uint32_t)CCU4_CC4_CMC_TCE_Pos);
100027c0:	687b      	ldr	r3, [r7, #4]
100027c2:	69db      	ldr	r3, [r3, #28]
100027c4:	687a      	ldr	r2, [r7, #4]
100027c6:	69d2      	ldr	r2, [r2, #28]
100027c8:	6852      	ldr	r2, [r2, #4]
100027ca:	2180      	movs	r1, #128	; 0x80
100027cc:	0349      	lsls	r1, r1, #13
100027ce:	430a      	orrs	r2, r1
100027d0:	605a      	str	r2, [r3, #4]

  /*<<<DD_PWMSP001_nonAPI_1_3>>>*/
  if (HandlePtr->kExtStopTrig == (uint8_t)SET)
100027d2:	687b      	ldr	r3, [r7, #4]
100027d4:	7bdb      	ldrb	r3, [r3, #15]
100027d6:	2b01      	cmp	r3, #1
100027d8:	d125      	bne.n	10002826 <PWMSP001_lConfigureSecondSlice+0x8e>
  {
    HandlePtr->CC4yRegs1Ptr->INS &=(uint32_t) ~(CCU4_CC4_INS_EV1EM_Msk | (uint32_t)CCU4_CC4_INS_LPF1M_Msk);
100027da:	687b      	ldr	r3, [r7, #4]
100027dc:	69db      	ldr	r3, [r3, #28]
100027de:	687a      	ldr	r2, [r7, #4]
100027e0:	69d2      	ldr	r2, [r2, #28]
100027e2:	6811      	ldr	r1, [r2, #0]
100027e4:	4a79      	ldr	r2, [pc, #484]	; (100029cc <PWMSP001_lConfigureSecondSlice+0x234>)
100027e6:	400a      	ands	r2, r1
100027e8:	601a      	str	r2, [r3, #0]
    HandlePtr->CC4yRegs1Ptr->CMC &=(uint32_t) ~(CCU4_CC4_CMC_ENDS_Msk);
100027ea:	687b      	ldr	r3, [r7, #4]
100027ec:	69db      	ldr	r3, [r3, #28]
100027ee:	687a      	ldr	r2, [r7, #4]
100027f0:	69d2      	ldr	r2, [r2, #28]
100027f2:	6852      	ldr	r2, [r2, #4]
100027f4:	210c      	movs	r1, #12
100027f6:	438a      	bics	r2, r1
100027f8:	605a      	str	r2, [r3, #4]
    HandlePtr->CC4yRegs1Ptr->INS |=(uint32_t)((((uint32_t)HandlePtr->kStopEdge  <<   \
100027fa:	687b      	ldr	r3, [r7, #4]
100027fc:	69db      	ldr	r3, [r3, #28]
100027fe:	687a      	ldr	r2, [r7, #4]
10002800:	69d2      	ldr	r2, [r2, #28]
10002802:	6811      	ldr	r1, [r2, #0]
10002804:	6878      	ldr	r0, [r7, #4]
10002806:	2224      	movs	r2, #36	; 0x24
10002808:	5c82      	ldrb	r2, [r0, r2]
1000280a:	0490      	lsls	r0, r2, #18
1000280c:	22c0      	movs	r2, #192	; 0xc0
1000280e:	0312      	lsls	r2, r2, #12
10002810:	4002      	ands	r2, r0
10002812:	430a      	orrs	r2, r1
10002814:	601a      	str	r2, [r3, #0]
      (uint32_t)CCU4_CC4_INS_EV1EM_Pos)& (uint32_t)CCU4_CC4_INS_EV1EM_Msk) | \
	    (((uint32_t)PWMSP001_LPF << (uint32_t)CCU4_CC4_INS_LPF1M_Pos)& \
		  (uint32_t)CCU4_CC4_INS_LPF1M_Msk));
    HandlePtr->CC4yRegs1Ptr->CMC |= (((uint32_t)PWMSP001_EVENT_1  <<  \
10002816:	687b      	ldr	r3, [r7, #4]
10002818:	69db      	ldr	r3, [r3, #28]
1000281a:	687a      	ldr	r2, [r7, #4]
1000281c:	69d2      	ldr	r2, [r2, #28]
1000281e:	6852      	ldr	r2, [r2, #4]
10002820:	2108      	movs	r1, #8
10002822:	430a      	orrs	r2, r1
10002824:	605a      	str	r2, [r3, #4]
      (uint32_t)CCU4_CC4_CMC_ENDS_Pos)& (uint32_t)CCU4_CC4_CMC_ENDS_Msk);
  }/*End of if (HandlePtr->kExtStopTrig == SET)*/

  /*<<<DD_PWMSP001_nonAPI_1_4>>>*/
  if (HandlePtr->kTrapEnable == (uint8_t)SET)
10002826:	687b      	ldr	r3, [r7, #4]
10002828:	7c5b      	ldrb	r3, [r3, #17]
1000282a:	2b01      	cmp	r3, #1
1000282c:	d125      	bne.n	1000287a <PWMSP001_lConfigureSecondSlice+0xe2>
  {
    HandlePtr->CC4yRegs1Ptr -> INS &=(uint32_t) ~(CCU4_CC4_INS_EV2EM_Msk | CCU4_CC4_INS_EV2LM_Msk 
1000282e:	687b      	ldr	r3, [r7, #4]
10002830:	69db      	ldr	r3, [r3, #28]
10002832:	687a      	ldr	r2, [r7, #4]
10002834:	69d2      	ldr	r2, [r2, #28]
10002836:	6811      	ldr	r1, [r2, #0]
10002838:	4a65      	ldr	r2, [pc, #404]	; (100029d0 <PWMSP001_lConfigureSecondSlice+0x238>)
1000283a:	400a      	ands	r2, r1
1000283c:	601a      	str	r2, [r3, #0]
        | CCU4_CC4_INS_LPF2M_Msk);
    HandlePtr->CC4yRegs1Ptr->CMC &= (uint32_t)~(CCU4_CC4_CMC_TS_Msk);
1000283e:	687b      	ldr	r3, [r7, #4]
10002840:	69db      	ldr	r3, [r3, #28]
10002842:	687a      	ldr	r2, [r7, #4]
10002844:	69d2      	ldr	r2, [r2, #28]
10002846:	6851      	ldr	r1, [r2, #4]
10002848:	4a62      	ldr	r2, [pc, #392]	; (100029d4 <PWMSP001_lConfigureSecondSlice+0x23c>)
1000284a:	400a      	ands	r2, r1
1000284c:	605a      	str	r2, [r3, #4]
    HandlePtr->CC4yRegs1Ptr -> INS |= (uint32_t) \
1000284e:	687b      	ldr	r3, [r7, #4]
10002850:	69db      	ldr	r3, [r3, #28]
10002852:	687a      	ldr	r2, [r7, #4]
10002854:	69d2      	ldr	r2, [r2, #28]
10002856:	6811      	ldr	r1, [r2, #0]
        ((((uint32_t)0x00 << CCU4_CC4_INS_EV2EM_Pos)& (uint32_t)CCU4_CC4_INS_EV2EM_Msk) | \
            ((((uint32_t)HandlePtr->kTrapLevel  <<	\
10002858:	687a      	ldr	r2, [r7, #4]
1000285a:	7812      	ldrb	r2, [r2, #0]
1000285c:	0610      	lsls	r0, r2, #24
  if (HandlePtr->kTrapEnable == (uint8_t)SET)
  {
    HandlePtr->CC4yRegs1Ptr -> INS &=(uint32_t) ~(CCU4_CC4_INS_EV2EM_Msk | CCU4_CC4_INS_EV2LM_Msk 
        | CCU4_CC4_INS_LPF2M_Msk);
    HandlePtr->CC4yRegs1Ptr->CMC &= (uint32_t)~(CCU4_CC4_CMC_TS_Msk);
    HandlePtr->CC4yRegs1Ptr -> INS |= (uint32_t) \
1000285e:	2280      	movs	r2, #128	; 0x80
10002860:	0452      	lsls	r2, r2, #17
10002862:	4002      	ands	r2, r0
10002864:	430a      	orrs	r2, r1
10002866:	601a      	str	r2, [r3, #0]
        ((((uint32_t)0x00 << CCU4_CC4_INS_EV2EM_Pos)& (uint32_t)CCU4_CC4_INS_EV2EM_Msk) | \
            ((((uint32_t)HandlePtr->kTrapLevel  <<	\
                CCU4_CC4_INS_EV2LM_Pos)& (uint32_t)CCU4_CC4_INS_EV2LM_Msk) | (((uint32_t)0x00  << \
                    CCU4_CC4_INS_LPF2M_Pos)& (uint32_t)CCU4_CC4_INS_LPF2M_Msk)));
    HandlePtr->CC4yRegs1Ptr->CMC |= ((uint32_t)0x01 << (uint32_t)CCU4_CC4_CMC_TS_Pos);
10002868:	687b      	ldr	r3, [r7, #4]
1000286a:	69db      	ldr	r3, [r3, #28]
1000286c:	687a      	ldr	r2, [r7, #4]
1000286e:	69d2      	ldr	r2, [r2, #28]
10002870:	6852      	ldr	r2, [r2, #4]
10002872:	2180      	movs	r1, #128	; 0x80
10002874:	0289      	lsls	r1, r1, #10
10002876:	430a      	orrs	r2, r1
10002878:	605a      	str	r2, [r3, #4]
  }/*End of if (HandlePtr->kTrapEnable == SET)*/

  HandlePtr->CC4yRegs1Ptr->TC &=(uint32_t) ~(CCU4_CC4_TC_TCM_Msk | CCU4_CC4_TC_TSSM_Msk
1000287a:	687b      	ldr	r3, [r7, #4]
1000287c:	69db      	ldr	r3, [r3, #28]
1000287e:	687a      	ldr	r2, [r7, #4]
10002880:	69d2      	ldr	r2, [r2, #28]
10002882:	6951      	ldr	r1, [r2, #20]
10002884:	4a54      	ldr	r2, [pc, #336]	; (100029d8 <PWMSP001_lConfigureSecondSlice+0x240>)
10002886:	400a      	ands	r2, r1
10002888:	615a      	str	r2, [r3, #20]
      | CCU4_CC4_TC_CMOD_Msk | CCU4_CC4_TC_STRM_Msk | CCU4_CC4_TC_ENDM_Msk
      | CCU4_CC4_TC_DITHE_Msk);
  HandlePtr->CC4yRegs1Ptr->TC =	(((uint32_t)HandlePtr->CountingModeType  << \
1000288a:	687b      	ldr	r3, [r7, #4]
1000288c:	69db      	ldr	r3, [r3, #28]
1000288e:	6879      	ldr	r1, [r7, #4]
10002890:	2236      	movs	r2, #54	; 0x36
10002892:	5c8a      	ldrb	r2, [r1, r2]
10002894:	1c11      	adds	r1, r2, #0
    (uint32_t)CCU4_CC4_TC_TCM_Pos)& (uint32_t)CCU4_CC4_TC_TCM_Msk)|	\
10002896:	2201      	movs	r2, #1
10002898:	4011      	ands	r1, r2
      (((uint32_t)HandlePtr->kTimerMode  << (uint32_t)CCU4_CC4_TC_TSSM_Pos)& \
1000289a:	687a      	ldr	r2, [r7, #4]
1000289c:	7b12      	ldrb	r2, [r2, #12]
1000289e:	0050      	lsls	r0, r2, #1
100028a0:	2202      	movs	r2, #2
100028a2:	4002      	ands	r2, r0
	    (uint32_t)CCU4_CC4_TC_TSSM_Msk)|(((uint32_t)PWMSP001_COMPARE_MODE  << \
100028a4:	4311      	orrs	r1, r2
		  (uint32_t)CCU4_CC4_TC_CMOD_Pos)& (uint32_t)CCU4_CC4_TC_CMOD_Msk)| \
            (((uint32_t)HandlePtr->ExtStartConfigType << (uint32_t)CCU4_CC4_TC_STRM_Pos)\
100028a6:	6878      	ldr	r0, [r7, #4]
100028a8:	2234      	movs	r2, #52	; 0x34
100028aa:	5c82      	ldrb	r2, [r0, r2]
100028ac:	0290      	lsls	r0, r2, #10
			  &(uint32_t)CCU4_CC4_TC_STRM_Msk)| (((uint32_t)HandlePtr->ExtStopConfigType <<	\
100028ae:	2280      	movs	r2, #128	; 0x80
100028b0:	00d2      	lsls	r2, r2, #3
100028b2:	4002      	ands	r2, r0
      | CCU4_CC4_TC_DITHE_Msk);
  HandlePtr->CC4yRegs1Ptr->TC =	(((uint32_t)HandlePtr->CountingModeType  << \
    (uint32_t)CCU4_CC4_TC_TCM_Pos)& (uint32_t)CCU4_CC4_TC_TCM_Msk)|	\
      (((uint32_t)HandlePtr->kTimerMode  << (uint32_t)CCU4_CC4_TC_TSSM_Pos)& \
	    (uint32_t)CCU4_CC4_TC_TSSM_Msk)|(((uint32_t)PWMSP001_COMPARE_MODE  << \
		  (uint32_t)CCU4_CC4_TC_CMOD_Pos)& (uint32_t)CCU4_CC4_TC_CMOD_Msk)| \
100028b4:	4311      	orrs	r1, r2
            (((uint32_t)HandlePtr->ExtStartConfigType << (uint32_t)CCU4_CC4_TC_STRM_Pos)\
			  &(uint32_t)CCU4_CC4_TC_STRM_Msk)| (((uint32_t)HandlePtr->ExtStopConfigType <<	\
100028b6:	6878      	ldr	r0, [r7, #4]
100028b8:	2235      	movs	r2, #53	; 0x35
100028ba:	5c82      	ldrb	r2, [r0, r2]
100028bc:	0210      	lsls	r0, r2, #8
                (uint32_t)CCU4_CC4_TC_ENDM_Pos)& (uint32_t)CCU4_CC4_TC_ENDM_Msk);
100028be:	22c0      	movs	r2, #192	; 0xc0
100028c0:	0092      	lsls	r2, r2, #2
100028c2:	4002      	ands	r2, r0
    (uint32_t)CCU4_CC4_TC_TCM_Pos)& (uint32_t)CCU4_CC4_TC_TCM_Msk)|	\
      (((uint32_t)HandlePtr->kTimerMode  << (uint32_t)CCU4_CC4_TC_TSSM_Pos)& \
	    (uint32_t)CCU4_CC4_TC_TSSM_Msk)|(((uint32_t)PWMSP001_COMPARE_MODE  << \
		  (uint32_t)CCU4_CC4_TC_CMOD_Pos)& (uint32_t)CCU4_CC4_TC_CMOD_Msk)| \
            (((uint32_t)HandlePtr->ExtStartConfigType << (uint32_t)CCU4_CC4_TC_STRM_Pos)\
			  &(uint32_t)CCU4_CC4_TC_STRM_Msk)| (((uint32_t)HandlePtr->ExtStopConfigType <<	\
100028c4:	430a      	orrs	r2, r1
  }/*End of if (HandlePtr->kTrapEnable == SET)*/

  HandlePtr->CC4yRegs1Ptr->TC &=(uint32_t) ~(CCU4_CC4_TC_TCM_Msk | CCU4_CC4_TC_TSSM_Msk
      | CCU4_CC4_TC_CMOD_Msk | CCU4_CC4_TC_STRM_Msk | CCU4_CC4_TC_ENDM_Msk
      | CCU4_CC4_TC_DITHE_Msk);
  HandlePtr->CC4yRegs1Ptr->TC =	(((uint32_t)HandlePtr->CountingModeType  << \
100028c6:	615a      	str	r2, [r3, #20]
            (((uint32_t)HandlePtr->ExtStartConfigType << (uint32_t)CCU4_CC4_TC_STRM_Pos)\
			  &(uint32_t)CCU4_CC4_TC_STRM_Msk)| (((uint32_t)HandlePtr->ExtStopConfigType <<	\
                (uint32_t)CCU4_CC4_TC_ENDM_Pos)& (uint32_t)CCU4_CC4_TC_ENDM_Msk);

  /*<<<DD_PWMSP001_API_non1_5>>>*/
  HandlePtr->CC4yRegs1Ptr->TC |= ((uint32_t)HandlePtr->kDitherSetting << (uint32_t)CCU4_CC4_TC_DITHE_Pos)\
100028c8:	687b      	ldr	r3, [r7, #4]
100028ca:	69db      	ldr	r3, [r3, #28]
100028cc:	687a      	ldr	r2, [r7, #4]
100028ce:	69d2      	ldr	r2, [r2, #28]
100028d0:	6951      	ldr	r1, [r2, #20]
100028d2:	6878      	ldr	r0, [r7, #4]
100028d4:	2221      	movs	r2, #33	; 0x21
100028d6:	5c82      	ldrb	r2, [r0, r2]
100028d8:	0350      	lsls	r0, r2, #13
    &(uint32_t)CCU4_CC4_TC_DITHE_Msk;
100028da:	22c0      	movs	r2, #192	; 0xc0
100028dc:	01d2      	lsls	r2, r2, #7
100028de:	4002      	ands	r2, r0
            (((uint32_t)HandlePtr->ExtStartConfigType << (uint32_t)CCU4_CC4_TC_STRM_Pos)\
			  &(uint32_t)CCU4_CC4_TC_STRM_Msk)| (((uint32_t)HandlePtr->ExtStopConfigType <<	\
                (uint32_t)CCU4_CC4_TC_ENDM_Pos)& (uint32_t)CCU4_CC4_TC_ENDM_Msk);

  /*<<<DD_PWMSP001_API_non1_5>>>*/
  HandlePtr->CC4yRegs1Ptr->TC |= ((uint32_t)HandlePtr->kDitherSetting << (uint32_t)CCU4_CC4_TC_DITHE_Pos)\
100028e0:	430a      	orrs	r2, r1
100028e2:	615a      	str	r2, [r3, #20]
    &(uint32_t)CCU4_CC4_TC_DITHE_Msk;
  WR_REG(HandlePtr->CC4yRegs1Ptr->DITS, (uint32_t)CCU4_CC4_DITS_DCVS_Msk, \
100028e4:	687b      	ldr	r3, [r7, #4]
100028e6:	69db      	ldr	r3, [r3, #28]
100028e8:	687a      	ldr	r2, [r7, #4]
100028ea:	7b52      	ldrb	r2, [r2, #13]
100028ec:	1c11      	adds	r1, r2, #0
100028ee:	220f      	movs	r2, #15
100028f0:	4011      	ands	r1, r2
100028f2:	687a      	ldr	r2, [r7, #4]
100028f4:	69d2      	ldr	r2, [r2, #28]
100028f6:	6a12      	ldr	r2, [r2, #32]
100028f8:	200f      	movs	r0, #15
100028fa:	4382      	bics	r2, r0
100028fc:	430a      	orrs	r2, r1
100028fe:	621a      	str	r2, [r3, #32]
    (uint32_t)CCU4_CC4_DITS_DCVS_Pos, HandlePtr->kDitherCompare);

  /*<<<DD_PWMSP001_API_non1_6>>>*/
  WR_REG(HandlePtr->CC4yRegs1Ptr->TC, (uint32_t)CCU4_CC4_TC_TRPSE_Msk,
10002900:	687b      	ldr	r3, [r7, #4]
10002902:	69db      	ldr	r3, [r3, #28]
10002904:	687a      	ldr	r2, [r7, #4]
10002906:	7c92      	ldrb	r2, [r2, #18]
10002908:	0551      	lsls	r1, r2, #21
1000290a:	2280      	movs	r2, #128	; 0x80
1000290c:	0392      	lsls	r2, r2, #14
1000290e:	4011      	ands	r1, r2
10002910:	687a      	ldr	r2, [r7, #4]
10002912:	69d2      	ldr	r2, [r2, #28]
10002914:	6950      	ldr	r0, [r2, #20]
10002916:	4a31      	ldr	r2, [pc, #196]	; (100029dc <PWMSP001_lConfigureSecondSlice+0x244>)
10002918:	4002      	ands	r2, r0
1000291a:	430a      	orrs	r2, r1
1000291c:	615a      	str	r2, [r3, #20]
      (uint32_t)CCU4_CC4_TC_TRPSE_Pos, HandlePtr->kTrapSync);

  WR_REG(HandlePtr->CC4yRegs1Ptr->TC, (uint32_t)CCU4_CC4_TC_TRPSW_Msk,
1000291e:	687b      	ldr	r3, [r7, #4]
10002920:	69db      	ldr	r3, [r3, #28]
10002922:	687a      	ldr	r2, [r7, #4]
10002924:	7cd2      	ldrb	r2, [r2, #19]
10002926:	0591      	lsls	r1, r2, #22
10002928:	2280      	movs	r2, #128	; 0x80
1000292a:	03d2      	lsls	r2, r2, #15
1000292c:	4011      	ands	r1, r2
1000292e:	687a      	ldr	r2, [r7, #4]
10002930:	69d2      	ldr	r2, [r2, #28]
10002932:	6950      	ldr	r0, [r2, #20]
10002934:	4a2a      	ldr	r2, [pc, #168]	; (100029e0 <PWMSP001_lConfigureSecondSlice+0x248>)
10002936:	4002      	ands	r2, r0
10002938:	430a      	orrs	r2, r1
1000293a:	615a      	str	r2, [r3, #20]
      (uint32_t)CCU4_CC4_TC_TRPSW_Pos, HandlePtr->kTrapExitControl);

  WR_REG(HandlePtr->CC4yRegs1Ptr->TC, (uint32_t)CCU4_CC4_TC_TRAPE_Msk,\
1000293c:	687b      	ldr	r3, [r7, #4]
1000293e:	69db      	ldr	r3, [r3, #28]
10002940:	687a      	ldr	r2, [r7, #4]
10002942:	7c52      	ldrb	r2, [r2, #17]
10002944:	0451      	lsls	r1, r2, #17
10002946:	2280      	movs	r2, #128	; 0x80
10002948:	0292      	lsls	r2, r2, #10
1000294a:	4011      	ands	r1, r2
1000294c:	687a      	ldr	r2, [r7, #4]
1000294e:	69d2      	ldr	r2, [r2, #28]
10002950:	6950      	ldr	r0, [r2, #20]
10002952:	4a20      	ldr	r2, [pc, #128]	; (100029d4 <PWMSP001_lConfigureSecondSlice+0x23c>)
10002954:	4002      	ands	r2, r0
10002956:	430a      	orrs	r2, r1
10002958:	615a      	str	r2, [r3, #20]
	  (uint32_t)CCU4_CC4_TC_TRAPE_Pos, HandlePtr->kTrapEnable);
  
  WR_REG(HandlePtr->CC4yRegs1Ptr->PSC, (uint32_t)CCU4_CC4_PSC_PSIV_Msk, 
1000295a:	687b      	ldr	r3, [r7, #4]
1000295c:	69db      	ldr	r3, [r3, #28]
1000295e:	6879      	ldr	r1, [r7, #4]
10002960:	2222      	movs	r2, #34	; 0x22
10002962:	5c8a      	ldrb	r2, [r1, r2]
10002964:	1c11      	adds	r1, r2, #0
10002966:	220f      	movs	r2, #15
10002968:	4011      	ands	r1, r2
1000296a:	687a      	ldr	r2, [r7, #4]
1000296c:	69d2      	ldr	r2, [r2, #28]
1000296e:	6a52      	ldr	r2, [r2, #36]	; 0x24
10002970:	200f      	movs	r0, #15
10002972:	4382      	bics	r2, r0
10002974:	430a      	orrs	r2, r1
10002976:	625a      	str	r2, [r3, #36]	; 0x24
      (uint32_t)CCU4_CC4_PSC_PSIV_Pos, HandlePtr->kCCUPrescalar);

  HandlePtr->CC4yRegs1Ptr->PSL = HandlePtr->kPassiveLevel;
10002978:	687b      	ldr	r3, [r7, #4]
1000297a:	69db      	ldr	r3, [r3, #28]
1000297c:	687a      	ldr	r2, [r7, #4]
1000297e:	7c12      	ldrb	r2, [r2, #16]
10002980:	619a      	str	r2, [r3, #24]

  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)0x01 <<	\
10002982:	687b      	ldr	r3, [r7, #4]
10002984:	695b      	ldr	r3, [r3, #20]
10002986:	687a      	ldr	r2, [r7, #4]
10002988:	6952      	ldr	r2, [r2, #20]
1000298a:	6911      	ldr	r1, [r2, #16]
      ((uint32_t)4 * (uint32_t)HandlePtr->SecondSlice)) |	\
1000298c:	6878      	ldr	r0, [r7, #4]
1000298e:	2238      	movs	r2, #56	; 0x38
10002990:	5c82      	ldrb	r2, [r0, r2]
10002992:	0092      	lsls	r2, r2, #2
  WR_REG(HandlePtr->CC4yRegs1Ptr->PSC, (uint32_t)CCU4_CC4_PSC_PSIV_Msk, 
      (uint32_t)CCU4_CC4_PSC_PSIV_Pos, HandlePtr->kCCUPrescalar);

  HandlePtr->CC4yRegs1Ptr->PSL = HandlePtr->kPassiveLevel;

  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)0x01 <<	\
10002994:	2001      	movs	r0, #1
10002996:	4090      	lsls	r0, r2
      ((uint32_t)4 * (uint32_t)HandlePtr->SecondSlice)) |	\
      ((uint32_t)0x01 << (((uint32_t)4 * \
	    (uint32_t)HandlePtr->SecondSlice) + (uint32_t)1)) |\
10002998:	687c      	ldr	r4, [r7, #4]
1000299a:	2238      	movs	r2, #56	; 0x38
1000299c:	5ca2      	ldrb	r2, [r4, r2]

  HandlePtr->CC4yRegs1Ptr->PSL = HandlePtr->kPassiveLevel;

  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)0x01 <<	\
      ((uint32_t)4 * (uint32_t)HandlePtr->SecondSlice)) |	\
      ((uint32_t)0x01 << (((uint32_t)4 * \
1000299e:	0092      	lsls	r2, r2, #2
	    (uint32_t)HandlePtr->SecondSlice) + (uint32_t)1)) |\
100029a0:	3201      	adds	r2, #1

  HandlePtr->CC4yRegs1Ptr->PSL = HandlePtr->kPassiveLevel;

  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)0x01 <<	\
      ((uint32_t)4 * (uint32_t)HandlePtr->SecondSlice)) |	\
      ((uint32_t)0x01 << (((uint32_t)4 * \
100029a2:	2401      	movs	r4, #1
100029a4:	1c25      	adds	r5, r4, #0
100029a6:	4095      	lsls	r5, r2
100029a8:	1c2a      	adds	r2, r5, #0
      (uint32_t)CCU4_CC4_PSC_PSIV_Pos, HandlePtr->kCCUPrescalar);

  HandlePtr->CC4yRegs1Ptr->PSL = HandlePtr->kPassiveLevel;

  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)0x01 <<	\
      ((uint32_t)4 * (uint32_t)HandlePtr->SecondSlice)) |	\
100029aa:	4310      	orrs	r0, r2
      ((uint32_t)0x01 << (((uint32_t)4 * \
	    (uint32_t)HandlePtr->SecondSlice) + (uint32_t)1)) |\
          (uint32_t)((uint32_t)0x01 << (((uint32_t)4 * \
		    (uint32_t)HandlePtr->SecondSlice) + (uint32_t)2)));
100029ac:	687c      	ldr	r4, [r7, #4]
100029ae:	2238      	movs	r2, #56	; 0x38
100029b0:	5ca2      	ldrb	r2, [r4, r2]

  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)0x01 <<	\
      ((uint32_t)4 * (uint32_t)HandlePtr->SecondSlice)) |	\
      ((uint32_t)0x01 << (((uint32_t)4 * \
	    (uint32_t)HandlePtr->SecondSlice) + (uint32_t)1)) |\
          (uint32_t)((uint32_t)0x01 << (((uint32_t)4 * \
100029b2:	0092      	lsls	r2, r2, #2
		    (uint32_t)HandlePtr->SecondSlice) + (uint32_t)2)));
100029b4:	3202      	adds	r2, #2

  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)0x01 <<	\
      ((uint32_t)4 * (uint32_t)HandlePtr->SecondSlice)) |	\
      ((uint32_t)0x01 << (((uint32_t)4 * \
	    (uint32_t)HandlePtr->SecondSlice) + (uint32_t)1)) |\
          (uint32_t)((uint32_t)0x01 << (((uint32_t)4 * \
100029b6:	2401      	movs	r4, #1
100029b8:	1c25      	adds	r5, r4, #0
100029ba:	4095      	lsls	r5, r2
100029bc:	1c2a      	adds	r2, r5, #0
  WR_REG(HandlePtr->CC4yRegs1Ptr->PSC, (uint32_t)CCU4_CC4_PSC_PSIV_Msk, 
      (uint32_t)CCU4_CC4_PSC_PSIV_Pos, HandlePtr->kCCUPrescalar);

  HandlePtr->CC4yRegs1Ptr->PSL = HandlePtr->kPassiveLevel;

  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)0x01 <<	\
100029be:	4302      	orrs	r2, r0
100029c0:	430a      	orrs	r2, r1
100029c2:	611a      	str	r2, [r3, #16]
      ((uint32_t)4 * (uint32_t)HandlePtr->SecondSlice)) |	\
      ((uint32_t)0x01 << (((uint32_t)4 * \
	    (uint32_t)HandlePtr->SecondSlice) + (uint32_t)1)) |\
          (uint32_t)((uint32_t)0x01 << (((uint32_t)4 * \
		    (uint32_t)HandlePtr->SecondSlice) + (uint32_t)2)));
}
100029c4:	46bd      	mov	sp, r7
100029c6:	b002      	add	sp, #8
100029c8:	bdb0      	pop	{r4, r5, r7, pc}
100029ca:	46c0      	nop			; (mov r8, r8)
100029cc:	e7f3ffff 	.word	0xe7f3ffff
100029d0:	9ecfffff 	.word	0x9ecfffff
100029d4:	fffdffff 	.word	0xfffdffff
100029d8:	ffff98f4 	.word	0xffff98f4
100029dc:	ffdfffff 	.word	0xffdfffff
100029e0:	ffbfffff 	.word	0xffbfffff

100029e4 <PWMSP001_EnableEvent>:
status_t PWMSP001_EnableEvent
(
    const PWMSP001_HandleType * HandlePtr,
    const PWMSP001_EventNameType Event
)
{
100029e4:	b590      	push	{r4, r7, lr}
100029e6:	b085      	sub	sp, #20
100029e8:	af00      	add	r7, sp, #0
100029ea:	6078      	str	r0, [r7, #4]
100029ec:	1c0a      	adds	r2, r1, #0
100029ee:	1cfb      	adds	r3, r7, #3
100029f0:	701a      	strb	r2, [r3, #0]
  status_t Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;
100029f2:	2301      	movs	r3, #1
100029f4:	60fb      	str	r3, [r7, #12]

  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
100029f6:	687b      	ldr	r3, [r7, #4]
100029f8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100029fa:	781b      	ldrb	r3, [r3, #0]
100029fc:	2b00      	cmp	r3, #0
100029fe:	d102      	bne.n	10002a06 <PWMSP001_EnableEvent+0x22>
  {
    Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;
10002a00:	2301      	movs	r3, #1
10002a02:	60fb      	str	r3, [r7, #12]
10002a04:	e025      	b.n	10002a52 <PWMSP001_EnableEvent+0x6e>
    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  else
  {
    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)
10002a06:	687a      	ldr	r2, [r7, #4]
10002a08:	2320      	movs	r3, #32
10002a0a:	5cd3      	ldrb	r3, [r2, r3]
10002a0c:	2b01      	cmp	r3, #1
10002a0e:	d10f      	bne.n	10002a30 <PWMSP001_EnableEvent+0x4c>
    {
      SET_BIT(HandlePtr->CC4yRegs1Ptr->INTE,(uint8_t) Event);
10002a10:	687b      	ldr	r3, [r7, #4]
10002a12:	69da      	ldr	r2, [r3, #28]
10002a14:	687b      	ldr	r3, [r7, #4]
10002a16:	69d9      	ldr	r1, [r3, #28]
10002a18:	23a4      	movs	r3, #164	; 0xa4
10002a1a:	58c9      	ldr	r1, [r1, r3]
10002a1c:	1cfb      	adds	r3, r7, #3
10002a1e:	781b      	ldrb	r3, [r3, #0]
10002a20:	2001      	movs	r0, #1
10002a22:	1c04      	adds	r4, r0, #0
10002a24:	409c      	lsls	r4, r3
10002a26:	1c23      	adds	r3, r4, #0
10002a28:	4319      	orrs	r1, r3
10002a2a:	23a4      	movs	r3, #164	; 0xa4
10002a2c:	50d1      	str	r1, [r2, r3]
10002a2e:	e00e      	b.n	10002a4e <PWMSP001_EnableEvent+0x6a>
    }
    else
    {
      SET_BIT(HandlePtr->CC4yRegsPtr->INTE,(uint8_t) Event);
10002a30:	687b      	ldr	r3, [r7, #4]
10002a32:	699a      	ldr	r2, [r3, #24]
10002a34:	687b      	ldr	r3, [r7, #4]
10002a36:	6999      	ldr	r1, [r3, #24]
10002a38:	23a4      	movs	r3, #164	; 0xa4
10002a3a:	58c9      	ldr	r1, [r1, r3]
10002a3c:	1cfb      	adds	r3, r7, #3
10002a3e:	781b      	ldrb	r3, [r3, #0]
10002a40:	2001      	movs	r0, #1
10002a42:	1c04      	adds	r4, r0, #0
10002a44:	409c      	lsls	r4, r3
10002a46:	1c23      	adds	r3, r4, #0
10002a48:	4319      	orrs	r1, r3
10002a4a:	23a4      	movs	r3, #164	; 0xa4
10002a4c:	50d1      	str	r1, [r2, r3]
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
10002a4e:	2300      	movs	r3, #0
10002a50:	60fb      	str	r3, [r7, #12]
  }
  return (Status);
10002a52:	68fb      	ldr	r3, [r7, #12]
}
10002a54:	1c18      	adds	r0, r3, #0
10002a56:	46bd      	mov	sp, r7
10002a58:	b005      	add	sp, #20
10002a5a:	bd90      	pop	{r4, r7, pc}

10002a5c <PWMSP001_DisableEvent>:
status_t PWMSP001_DisableEvent
(
    const PWMSP001_HandleType * HandlePtr,
    const PWMSP001_EventNameType Event
)
{
10002a5c:	b590      	push	{r4, r7, lr}
10002a5e:	b085      	sub	sp, #20
10002a60:	af00      	add	r7, sp, #0
10002a62:	6078      	str	r0, [r7, #4]
10002a64:	1c0a      	adds	r2, r1, #0
10002a66:	1cfb      	adds	r3, r7, #3
10002a68:	701a      	strb	r2, [r3, #0]
  status_t Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;
10002a6a:	2301      	movs	r3, #1
10002a6c:	60fb      	str	r3, [r7, #12]

  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
10002a6e:	687b      	ldr	r3, [r7, #4]
10002a70:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10002a72:	781b      	ldrb	r3, [r3, #0]
10002a74:	2b00      	cmp	r3, #0
10002a76:	d102      	bne.n	10002a7e <PWMSP001_DisableEvent+0x22>
  {
    Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
10002a78:	2301      	movs	r3, #1
10002a7a:	60fb      	str	r3, [r7, #12]
10002a7c:	e027      	b.n	10002ace <PWMSP001_DisableEvent+0x72>
    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  else
  {
    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)
10002a7e:	687a      	ldr	r2, [r7, #4]
10002a80:	2320      	movs	r3, #32
10002a82:	5cd3      	ldrb	r3, [r2, r3]
10002a84:	2b01      	cmp	r3, #1
10002a86:	d110      	bne.n	10002aaa <PWMSP001_DisableEvent+0x4e>
    {
      CLR_BIT(HandlePtr->CC4yRegs1Ptr->INTE,(uint8_t) Event);
10002a88:	687b      	ldr	r3, [r7, #4]
10002a8a:	69da      	ldr	r2, [r3, #28]
10002a8c:	687b      	ldr	r3, [r7, #4]
10002a8e:	69d9      	ldr	r1, [r3, #28]
10002a90:	23a4      	movs	r3, #164	; 0xa4
10002a92:	58cb      	ldr	r3, [r1, r3]
10002a94:	1cf9      	adds	r1, r7, #3
10002a96:	7809      	ldrb	r1, [r1, #0]
10002a98:	2001      	movs	r0, #1
10002a9a:	1c04      	adds	r4, r0, #0
10002a9c:	408c      	lsls	r4, r1
10002a9e:	1c21      	adds	r1, r4, #0
10002aa0:	43c9      	mvns	r1, r1
10002aa2:	4019      	ands	r1, r3
10002aa4:	23a4      	movs	r3, #164	; 0xa4
10002aa6:	50d1      	str	r1, [r2, r3]
10002aa8:	e00f      	b.n	10002aca <PWMSP001_DisableEvent+0x6e>
    }
    else
    {
      CLR_BIT(HandlePtr->CC4yRegsPtr->INTE,(uint8_t) Event);
10002aaa:	687b      	ldr	r3, [r7, #4]
10002aac:	699a      	ldr	r2, [r3, #24]
10002aae:	687b      	ldr	r3, [r7, #4]
10002ab0:	6999      	ldr	r1, [r3, #24]
10002ab2:	23a4      	movs	r3, #164	; 0xa4
10002ab4:	58cb      	ldr	r3, [r1, r3]
10002ab6:	1cf9      	adds	r1, r7, #3
10002ab8:	7809      	ldrb	r1, [r1, #0]
10002aba:	2001      	movs	r0, #1
10002abc:	1c04      	adds	r4, r0, #0
10002abe:	408c      	lsls	r4, r1
10002ac0:	1c21      	adds	r1, r4, #0
10002ac2:	43c9      	mvns	r1, r1
10002ac4:	4019      	ands	r1, r3
10002ac6:	23a4      	movs	r3, #164	; 0xa4
10002ac8:	50d1      	str	r1, [r2, r3]
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
10002aca:	2300      	movs	r3, #0
10002acc:	60fb      	str	r3, [r7, #12]
  }
  return (Status);
10002ace:	68fb      	ldr	r3, [r7, #12]
}
10002ad0:	1c18      	adds	r0, r3, #0
10002ad2:	46bd      	mov	sp, r7
10002ad4:	b005      	add	sp, #20
10002ad6:	bd90      	pop	{r4, r7, pc}

10002ad8 <PWMSP001_ClearPendingEvent>:
status_t PWMSP001_ClearPendingEvent
(
    const PWMSP001_HandleType * HandlePtr,
    const PWMSP001_EventNameType Event
)
{
10002ad8:	b590      	push	{r4, r7, lr}
10002ada:	b085      	sub	sp, #20
10002adc:	af00      	add	r7, sp, #0
10002ade:	6078      	str	r0, [r7, #4]
10002ae0:	1c0a      	adds	r2, r1, #0
10002ae2:	1cfb      	adds	r3, r7, #3
10002ae4:	701a      	strb	r2, [r3, #0]
  status_t Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;
10002ae6:	2301      	movs	r3, #1
10002ae8:	60fb      	str	r3, [r7, #12]

  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
10002aea:	687b      	ldr	r3, [r7, #4]
10002aec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10002aee:	781b      	ldrb	r3, [r3, #0]
10002af0:	2b00      	cmp	r3, #0
10002af2:	d102      	bne.n	10002afa <PWMSP001_ClearPendingEvent+0x22>
  {
    Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;
10002af4:	2301      	movs	r3, #1
10002af6:	60fb      	str	r3, [r7, #12]
10002af8:	e025      	b.n	10002b46 <PWMSP001_ClearPendingEvent+0x6e>
    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  else
  {
    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)
10002afa:	687a      	ldr	r2, [r7, #4]
10002afc:	2320      	movs	r3, #32
10002afe:	5cd3      	ldrb	r3, [r2, r3]
10002b00:	2b01      	cmp	r3, #1
10002b02:	d10f      	bne.n	10002b24 <PWMSP001_ClearPendingEvent+0x4c>
    {
      SET_BIT(HandlePtr->CC4yRegs1Ptr->SWR,(uint8_t) Event);
10002b04:	687b      	ldr	r3, [r7, #4]
10002b06:	69da      	ldr	r2, [r3, #28]
10002b08:	687b      	ldr	r3, [r7, #4]
10002b0a:	69d9      	ldr	r1, [r3, #28]
10002b0c:	23b0      	movs	r3, #176	; 0xb0
10002b0e:	58c9      	ldr	r1, [r1, r3]
10002b10:	1cfb      	adds	r3, r7, #3
10002b12:	781b      	ldrb	r3, [r3, #0]
10002b14:	2001      	movs	r0, #1
10002b16:	1c04      	adds	r4, r0, #0
10002b18:	409c      	lsls	r4, r3
10002b1a:	1c23      	adds	r3, r4, #0
10002b1c:	4319      	orrs	r1, r3
10002b1e:	23b0      	movs	r3, #176	; 0xb0
10002b20:	50d1      	str	r1, [r2, r3]
10002b22:	e00e      	b.n	10002b42 <PWMSP001_ClearPendingEvent+0x6a>
    }
    else
    {
      SET_BIT(HandlePtr->CC4yRegsPtr->SWR, (uint8_t)Event);
10002b24:	687b      	ldr	r3, [r7, #4]
10002b26:	699a      	ldr	r2, [r3, #24]
10002b28:	687b      	ldr	r3, [r7, #4]
10002b2a:	6999      	ldr	r1, [r3, #24]
10002b2c:	23b0      	movs	r3, #176	; 0xb0
10002b2e:	58c9      	ldr	r1, [r1, r3]
10002b30:	1cfb      	adds	r3, r7, #3
10002b32:	781b      	ldrb	r3, [r3, #0]
10002b34:	2001      	movs	r0, #1
10002b36:	1c04      	adds	r4, r0, #0
10002b38:	409c      	lsls	r4, r3
10002b3a:	1c23      	adds	r3, r4, #0
10002b3c:	4319      	orrs	r1, r3
10002b3e:	23b0      	movs	r3, #176	; 0xb0
10002b40:	50d1      	str	r1, [r2, r3]
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
10002b42:	2300      	movs	r3, #0
10002b44:	60fb      	str	r3, [r7, #12]
  }
  return (Status);
10002b46:	68fb      	ldr	r3, [r7, #12]
}
10002b48:	1c18      	adds	r0, r3, #0
10002b4a:	46bd      	mov	sp, r7
10002b4c:	b005      	add	sp, #20
10002b4e:	bd90      	pop	{r4, r7, pc}

10002b50 <PWMSP001_SetPendingEvent>:
status_t PWMSP001_SetPendingEvent
(
    const PWMSP001_HandleType * HandlePtr,
    const PWMSP001_EventNameType Event
)
{
10002b50:	b590      	push	{r4, r7, lr}
10002b52:	b085      	sub	sp, #20
10002b54:	af00      	add	r7, sp, #0
10002b56:	6078      	str	r0, [r7, #4]
10002b58:	1c0a      	adds	r2, r1, #0
10002b5a:	1cfb      	adds	r3, r7, #3
10002b5c:	701a      	strb	r2, [r3, #0]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
10002b5e:	2301      	movs	r3, #1
10002b60:	60fb      	str	r3, [r7, #12]

  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
10002b62:	687b      	ldr	r3, [r7, #4]
10002b64:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10002b66:	781b      	ldrb	r3, [r3, #0]
10002b68:	2b00      	cmp	r3, #0
10002b6a:	d102      	bne.n	10002b72 <PWMSP001_SetPendingEvent+0x22>
  {
    Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
10002b6c:	2301      	movs	r3, #1
10002b6e:	60fb      	str	r3, [r7, #12]
10002b70:	e025      	b.n	10002bbe <PWMSP001_SetPendingEvent+0x6e>
    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  else
  {
    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)
10002b72:	687a      	ldr	r2, [r7, #4]
10002b74:	2320      	movs	r3, #32
10002b76:	5cd3      	ldrb	r3, [r2, r3]
10002b78:	2b01      	cmp	r3, #1
10002b7a:	d10f      	bne.n	10002b9c <PWMSP001_SetPendingEvent+0x4c>
    {
      SET_BIT(HandlePtr->CC4yRegs1Ptr->SWS,(uint8_t)Event);
10002b7c:	687b      	ldr	r3, [r7, #4]
10002b7e:	69da      	ldr	r2, [r3, #28]
10002b80:	687b      	ldr	r3, [r7, #4]
10002b82:	69d9      	ldr	r1, [r3, #28]
10002b84:	23ac      	movs	r3, #172	; 0xac
10002b86:	58c9      	ldr	r1, [r1, r3]
10002b88:	1cfb      	adds	r3, r7, #3
10002b8a:	781b      	ldrb	r3, [r3, #0]
10002b8c:	2001      	movs	r0, #1
10002b8e:	1c04      	adds	r4, r0, #0
10002b90:	409c      	lsls	r4, r3
10002b92:	1c23      	adds	r3, r4, #0
10002b94:	4319      	orrs	r1, r3
10002b96:	23ac      	movs	r3, #172	; 0xac
10002b98:	50d1      	str	r1, [r2, r3]
10002b9a:	e00e      	b.n	10002bba <PWMSP001_SetPendingEvent+0x6a>
    }
    else
    {
      SET_BIT(HandlePtr->CC4yRegsPtr->SWS, (uint8_t)Event);
10002b9c:	687b      	ldr	r3, [r7, #4]
10002b9e:	699a      	ldr	r2, [r3, #24]
10002ba0:	687b      	ldr	r3, [r7, #4]
10002ba2:	6999      	ldr	r1, [r3, #24]
10002ba4:	23ac      	movs	r3, #172	; 0xac
10002ba6:	58c9      	ldr	r1, [r1, r3]
10002ba8:	1cfb      	adds	r3, r7, #3
10002baa:	781b      	ldrb	r3, [r3, #0]
10002bac:	2001      	movs	r0, #1
10002bae:	1c04      	adds	r4, r0, #0
10002bb0:	409c      	lsls	r4, r3
10002bb2:	1c23      	adds	r3, r4, #0
10002bb4:	4319      	orrs	r1, r3
10002bb6:	23ac      	movs	r3, #172	; 0xac
10002bb8:	50d1      	str	r1, [r2, r3]
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
10002bba:	2300      	movs	r3, #0
10002bbc:	60fb      	str	r3, [r7, #12]
  }
  return (Status);
10002bbe:	68fb      	ldr	r3, [r7, #12]
}
10002bc0:	1c18      	adds	r0, r3, #0
10002bc2:	46bd      	mov	sp, r7
10002bc4:	b005      	add	sp, #20
10002bc6:	bd90      	pop	{r4, r7, pc}

10002bc8 <PWMSP001_GetPendingEvent>:
(
    const PWMSP001_HandleType * HandlePtr,
    const PWMSP001_EventNameType Event,
    uint8_t*EvtStatus
)
{
10002bc8:	b580      	push	{r7, lr}
10002bca:	b086      	sub	sp, #24
10002bcc:	af00      	add	r7, sp, #0
10002bce:	60f8      	str	r0, [r7, #12]
10002bd0:	607a      	str	r2, [r7, #4]
10002bd2:	1c3b      	adds	r3, r7, #0
10002bd4:	330b      	adds	r3, #11
10002bd6:	1c0a      	adds	r2, r1, #0
10002bd8:	701a      	strb	r2, [r3, #0]
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
10002bda:	2301      	movs	r3, #1
10002bdc:	617b      	str	r3, [r7, #20]

  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
10002bde:	68fb      	ldr	r3, [r7, #12]
10002be0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10002be2:	781b      	ldrb	r3, [r3, #0]
10002be4:	2b00      	cmp	r3, #0
10002be6:	d102      	bne.n	10002bee <PWMSP001_GetPendingEvent+0x26>
  {
    Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;
10002be8:	2301      	movs	r3, #1
10002bea:	617b      	str	r3, [r7, #20]
10002bec:	e03d      	b.n	10002c6a <PWMSP001_GetPendingEvent+0xa2>
    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  else
  {
    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)
10002bee:	68fa      	ldr	r2, [r7, #12]
10002bf0:	2320      	movs	r3, #32
10002bf2:	5cd3      	ldrb	r3, [r2, r3]
10002bf4:	2b01      	cmp	r3, #1
10002bf6:	d11b      	bne.n	10002c30 <PWMSP001_GetPendingEvent+0x68>
    {

      if(RD_REG(HandlePtr->CC4yRegs1Ptr->INTS, ((uint32_t)0x01 <<(uint32_t)Event), (uint32_t)Event))
10002bf8:	68fb      	ldr	r3, [r7, #12]
10002bfa:	69da      	ldr	r2, [r3, #28]
10002bfc:	23a0      	movs	r3, #160	; 0xa0
10002bfe:	58d3      	ldr	r3, [r2, r3]
10002c00:	1c3a      	adds	r2, r7, #0
10002c02:	320b      	adds	r2, #11
10002c04:	7812      	ldrb	r2, [r2, #0]
10002c06:	2101      	movs	r1, #1
10002c08:	1c08      	adds	r0, r1, #0
10002c0a:	4090      	lsls	r0, r2
10002c0c:	1c02      	adds	r2, r0, #0
10002c0e:	401a      	ands	r2, r3
10002c10:	1c3b      	adds	r3, r7, #0
10002c12:	330b      	adds	r3, #11
10002c14:	781b      	ldrb	r3, [r3, #0]
10002c16:	1c11      	adds	r1, r2, #0
10002c18:	40d9      	lsrs	r1, r3
10002c1a:	1c0b      	adds	r3, r1, #0
10002c1c:	2b00      	cmp	r3, #0
10002c1e:	d003      	beq.n	10002c28 <PWMSP001_GetPendingEvent+0x60>
	  {
	      *EvtStatus = (uint8_t)SET;
10002c20:	687b      	ldr	r3, [r7, #4]
10002c22:	2201      	movs	r2, #1
10002c24:	701a      	strb	r2, [r3, #0]
10002c26:	e01e      	b.n	10002c66 <PWMSP001_GetPendingEvent+0x9e>
	  }
	  else
	  {
	      *EvtStatus = (uint8_t)RESET;
10002c28:	687b      	ldr	r3, [r7, #4]
10002c2a:	2200      	movs	r2, #0
10002c2c:	701a      	strb	r2, [r3, #0]
10002c2e:	e01a      	b.n	10002c66 <PWMSP001_GetPendingEvent+0x9e>
	  }
    }
    else
    {
      if(RD_REG(HandlePtr->CC4yRegsPtr->INTS, ((uint32_t)0x01 << (uint32_t)Event),(uint32_t)Event))
10002c30:	68fb      	ldr	r3, [r7, #12]
10002c32:	699a      	ldr	r2, [r3, #24]
10002c34:	23a0      	movs	r3, #160	; 0xa0
10002c36:	58d3      	ldr	r3, [r2, r3]
10002c38:	1c3a      	adds	r2, r7, #0
10002c3a:	320b      	adds	r2, #11
10002c3c:	7812      	ldrb	r2, [r2, #0]
10002c3e:	2101      	movs	r1, #1
10002c40:	1c08      	adds	r0, r1, #0
10002c42:	4090      	lsls	r0, r2
10002c44:	1c02      	adds	r2, r0, #0
10002c46:	401a      	ands	r2, r3
10002c48:	1c3b      	adds	r3, r7, #0
10002c4a:	330b      	adds	r3, #11
10002c4c:	781b      	ldrb	r3, [r3, #0]
10002c4e:	1c11      	adds	r1, r2, #0
10002c50:	40d9      	lsrs	r1, r3
10002c52:	1c0b      	adds	r3, r1, #0
10002c54:	2b00      	cmp	r3, #0
10002c56:	d003      	beq.n	10002c60 <PWMSP001_GetPendingEvent+0x98>
      {
        *EvtStatus = (uint8_t)SET;
10002c58:	687b      	ldr	r3, [r7, #4]
10002c5a:	2201      	movs	r2, #1
10002c5c:	701a      	strb	r2, [r3, #0]
10002c5e:	e002      	b.n	10002c66 <PWMSP001_GetPendingEvent+0x9e>
      }
      else
      {
        *EvtStatus = (uint8_t)RESET;
10002c60:	687b      	ldr	r3, [r7, #4]
10002c62:	2200      	movs	r2, #0
10002c64:	701a      	strb	r2, [r3, #0]
      }
      /* *EvtStatus = RD_REG(HandlePtr->CC4yRegsPtr->INTS, (0x01 << (uint8_t)Event),(uint8_t) Event)\
	   ? (uint8_t)SET : (uint8_t)RESET;	*/
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
10002c66:	2300      	movs	r3, #0
10002c68:	617b      	str	r3, [r7, #20]
  }
  return (Status);
10002c6a:	697b      	ldr	r3, [r7, #20]
}
10002c6c:	1c18      	adds	r0, r3, #0
10002c6e:	46bd      	mov	sp, r7
10002c70:	b006      	add	sp, #24
10002c72:	bd80      	pop	{r7, pc}

10002c74 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
10002c74:	b580      	push	{r7, lr}
10002c76:	b082      	sub	sp, #8
10002c78:	af00      	add	r7, sp, #0
10002c7a:	1c02      	adds	r2, r0, #0
10002c7c:	1dfb      	adds	r3, r7, #7
10002c7e:	701a      	strb	r2, [r3, #0]
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
10002c80:	4b06      	ldr	r3, [pc, #24]	; (10002c9c <NVIC_EnableIRQ+0x28>)
10002c82:	1dfa      	adds	r2, r7, #7
10002c84:	7812      	ldrb	r2, [r2, #0]
10002c86:	1c11      	adds	r1, r2, #0
10002c88:	221f      	movs	r2, #31
10002c8a:	400a      	ands	r2, r1
10002c8c:	2101      	movs	r1, #1
10002c8e:	1c08      	adds	r0, r1, #0
10002c90:	4090      	lsls	r0, r2
10002c92:	1c02      	adds	r2, r0, #0
10002c94:	601a      	str	r2, [r3, #0]
}
10002c96:	46bd      	mov	sp, r7
10002c98:	b002      	add	sp, #8
10002c9a:	bd80      	pop	{r7, pc}
10002c9c:	e000e100 	.word	0xe000e100

10002ca0 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
10002ca0:	b5b0      	push	{r4, r5, r7, lr}
10002ca2:	b082      	sub	sp, #8
10002ca4:	af00      	add	r7, sp, #0
10002ca6:	1c02      	adds	r2, r0, #0
10002ca8:	6039      	str	r1, [r7, #0]
10002caa:	1dfb      	adds	r3, r7, #7
10002cac:	701a      	strb	r2, [r3, #0]
  if(IRQn < 0) {
10002cae:	1dfb      	adds	r3, r7, #7
10002cb0:	781b      	ldrb	r3, [r3, #0]
10002cb2:	2b7f      	cmp	r3, #127	; 0x7f
10002cb4:	d932      	bls.n	10002d1c <NVIC_SetPriority+0x7c>
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
10002cb6:	4930      	ldr	r1, [pc, #192]	; (10002d78 <NVIC_SetPriority+0xd8>)
10002cb8:	1dfb      	adds	r3, r7, #7
10002cba:	781b      	ldrb	r3, [r3, #0]
10002cbc:	1c1a      	adds	r2, r3, #0
10002cbe:	230f      	movs	r3, #15
10002cc0:	4013      	ands	r3, r2
10002cc2:	3b08      	subs	r3, #8
10002cc4:	0898      	lsrs	r0, r3, #2
10002cc6:	4a2c      	ldr	r2, [pc, #176]	; (10002d78 <NVIC_SetPriority+0xd8>)
10002cc8:	1dfb      	adds	r3, r7, #7
10002cca:	781b      	ldrb	r3, [r3, #0]
10002ccc:	1c1c      	adds	r4, r3, #0
10002cce:	230f      	movs	r3, #15
10002cd0:	4023      	ands	r3, r4
10002cd2:	3b08      	subs	r3, #8
10002cd4:	089b      	lsrs	r3, r3, #2
10002cd6:	3306      	adds	r3, #6
10002cd8:	009b      	lsls	r3, r3, #2
10002cda:	18d3      	adds	r3, r2, r3
10002cdc:	685b      	ldr	r3, [r3, #4]
10002cde:	1dfa      	adds	r2, r7, #7
10002ce0:	7812      	ldrb	r2, [r2, #0]
10002ce2:	1c14      	adds	r4, r2, #0
10002ce4:	2203      	movs	r2, #3
10002ce6:	4022      	ands	r2, r4
10002ce8:	00d2      	lsls	r2, r2, #3
10002cea:	24ff      	movs	r4, #255	; 0xff
10002cec:	1c25      	adds	r5, r4, #0
10002cee:	4095      	lsls	r5, r2
10002cf0:	1c2a      	adds	r2, r5, #0
10002cf2:	43d2      	mvns	r2, r2
10002cf4:	401a      	ands	r2, r3
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
10002cf6:	683b      	ldr	r3, [r7, #0]
10002cf8:	019c      	lsls	r4, r3, #6
10002cfa:	23ff      	movs	r3, #255	; 0xff
10002cfc:	401c      	ands	r4, r3
10002cfe:	1dfb      	adds	r3, r7, #7
10002d00:	781b      	ldrb	r3, [r3, #0]
10002d02:	1c1d      	adds	r5, r3, #0
10002d04:	2303      	movs	r3, #3
10002d06:	402b      	ands	r3, r5
10002d08:	00db      	lsls	r3, r3, #3
10002d0a:	1c25      	adds	r5, r4, #0
10002d0c:	409d      	lsls	r5, r3
10002d0e:	1c2b      	adds	r3, r5, #0
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
10002d10:	431a      	orrs	r2, r3
10002d12:	1d83      	adds	r3, r0, #6
10002d14:	009b      	lsls	r3, r3, #2
10002d16:	18cb      	adds	r3, r1, r3
10002d18:	605a      	str	r2, [r3, #4]
10002d1a:	e029      	b.n	10002d70 <NVIC_SetPriority+0xd0>
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
  else {
    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
10002d1c:	4b17      	ldr	r3, [pc, #92]	; (10002d7c <NVIC_SetPriority+0xdc>)
10002d1e:	1dfa      	adds	r2, r7, #7
10002d20:	7812      	ldrb	r2, [r2, #0]
10002d22:	b252      	sxtb	r2, r2
10002d24:	0892      	lsrs	r2, r2, #2
10002d26:	4915      	ldr	r1, [pc, #84]	; (10002d7c <NVIC_SetPriority+0xdc>)
10002d28:	1df8      	adds	r0, r7, #7
10002d2a:	7800      	ldrb	r0, [r0, #0]
10002d2c:	b240      	sxtb	r0, r0
10002d2e:	0880      	lsrs	r0, r0, #2
10002d30:	30c0      	adds	r0, #192	; 0xc0
10002d32:	0080      	lsls	r0, r0, #2
10002d34:	5841      	ldr	r1, [r0, r1]
10002d36:	1df8      	adds	r0, r7, #7
10002d38:	7800      	ldrb	r0, [r0, #0]
10002d3a:	1c04      	adds	r4, r0, #0
10002d3c:	2003      	movs	r0, #3
10002d3e:	4020      	ands	r0, r4
10002d40:	00c0      	lsls	r0, r0, #3
10002d42:	24ff      	movs	r4, #255	; 0xff
10002d44:	1c25      	adds	r5, r4, #0
10002d46:	4085      	lsls	r5, r0
10002d48:	1c28      	adds	r0, r5, #0
10002d4a:	43c0      	mvns	r0, r0
10002d4c:	4008      	ands	r0, r1
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
10002d4e:	6839      	ldr	r1, [r7, #0]
10002d50:	018c      	lsls	r4, r1, #6
10002d52:	21ff      	movs	r1, #255	; 0xff
10002d54:	400c      	ands	r4, r1
10002d56:	1df9      	adds	r1, r7, #7
10002d58:	7809      	ldrb	r1, [r1, #0]
10002d5a:	1c0d      	adds	r5, r1, #0
10002d5c:	2103      	movs	r1, #3
10002d5e:	4029      	ands	r1, r5
10002d60:	00c9      	lsls	r1, r1, #3
10002d62:	1c25      	adds	r5, r4, #0
10002d64:	408d      	lsls	r5, r1
10002d66:	1c29      	adds	r1, r5, #0
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
  else {
    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
10002d68:	4301      	orrs	r1, r0
10002d6a:	32c0      	adds	r2, #192	; 0xc0
10002d6c:	0092      	lsls	r2, r2, #2
10002d6e:	50d1      	str	r1, [r2, r3]
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
}
10002d70:	46bd      	mov	sp, r7
10002d72:	b002      	add	sp, #8
10002d74:	bdb0      	pop	{r4, r5, r7, pc}
10002d76:	46c0      	nop			; (mov r8, r8)
10002d78:	e000ed00 	.word	0xe000ed00
10002d7c:	e000e100 	.word	0xe000e100

10002d80 <NVIC002_EnableIRQ>:
 *    NVIC002_EnableIRQ(&NVIC002_Handle0);
 *    return 0;
 *  }
 * @endcode<BR> </p>
 */
__STATIC_INLINE void NVIC002_EnableIRQ (const NVIC002_HandleType *const Handle) {
10002d80:	b580      	push	{r7, lr}
10002d82:	b082      	sub	sp, #8
10002d84:	af00      	add	r7, sp, #0
10002d86:	6078      	str	r0, [r7, #4]
    NVIC_EnableIRQ(Handle->NodeID);
10002d88:	687b      	ldr	r3, [r7, #4]
10002d8a:	781b      	ldrb	r3, [r3, #0]
10002d8c:	b2db      	uxtb	r3, r3
10002d8e:	b25b      	sxtb	r3, r3
10002d90:	1c18      	adds	r0, r3, #0
10002d92:	f7ff ff6f 	bl	10002c74 <NVIC_EnableIRQ>
}
10002d96:	46bd      	mov	sp, r7
10002d98:	b002      	add	sp, #8
10002d9a:	bd80      	pop	{r7, pc}

10002d9c <NVIC002_Init>:

/**  Function to initialize the NVIC node parameters based on 
 *  UI configuration.
 */
void NVIC002_Init(void)
{
10002d9c:	b580      	push	{r7, lr}
10002d9e:	b082      	sub	sp, #8
10002da0:	af00      	add	r7, sp, #0
  uint32_t Count;
  for (Count = 0U; Count<(uint32_t)NVIC002_NUM_INSTANCES; Count++)
10002da2:	2300      	movs	r3, #0
10002da4:	607b      	str	r3, [r7, #4]
10002da6:	e009      	b.n	10002dbc <NVIC002_Init+0x20>
  {
	  NVIC002_lInit(NVIC002_HandleArray[Count]);
10002da8:	4b07      	ldr	r3, [pc, #28]	; (10002dc8 <NVIC002_Init+0x2c>)
10002daa:	687a      	ldr	r2, [r7, #4]
10002dac:	0092      	lsls	r2, r2, #2
10002dae:	58d3      	ldr	r3, [r2, r3]
10002db0:	1c18      	adds	r0, r3, #0
10002db2:	f000 f80b 	bl	10002dcc <NVIC002_lInit>
 *  UI configuration.
 */
void NVIC002_Init(void)
{
  uint32_t Count;
  for (Count = 0U; Count<(uint32_t)NVIC002_NUM_INSTANCES; Count++)
10002db6:	687b      	ldr	r3, [r7, #4]
10002db8:	3301      	adds	r3, #1
10002dba:	607b      	str	r3, [r7, #4]
10002dbc:	687b      	ldr	r3, [r7, #4]
10002dbe:	2b00      	cmp	r3, #0
10002dc0:	d0f2      	beq.n	10002da8 <NVIC002_Init+0xc>
  {
	  NVIC002_lInit(NVIC002_HandleArray[Count]);
  }
}
10002dc2:	46bd      	mov	sp, r7
10002dc4:	b002      	add	sp, #8
10002dc6:	bd80      	pop	{r7, pc}
10002dc8:	20000ae0 	.word	0x20000ae0

10002dcc <NVIC002_lInit>:

static void NVIC002_lInit(const NVIC002_HandleType * Handle)
{
10002dcc:	b580      	push	{r7, lr}
10002dce:	b082      	sub	sp, #8
10002dd0:	af00      	add	r7, sp, #0
10002dd2:	6078      	str	r0, [r7, #4]
   /* Set Interrupt Priority for NVIC <%=NodeID%> 
      Node App Instance <%=appInst%>  */
	#if (UC_FAMILY == XMC1) 
	   NVIC_SetPriority((IRQn_Type)Handle->NodeID, 
10002dd4:	687b      	ldr	r3, [r7, #4]
10002dd6:	781b      	ldrb	r3, [r3, #0]
10002dd8:	b2da      	uxtb	r2, r3
			             Handle->Priority);
10002dda:	687b      	ldr	r3, [r7, #4]
10002ddc:	785b      	ldrb	r3, [r3, #1]
static void NVIC002_lInit(const NVIC002_HandleType * Handle)
{
   /* Set Interrupt Priority for NVIC <%=NodeID%> 
      Node App Instance <%=appInst%>  */
	#if (UC_FAMILY == XMC1) 
	   NVIC_SetPriority((IRQn_Type)Handle->NodeID, 
10002dde:	b252      	sxtb	r2, r2
10002de0:	1c10      	adds	r0, r2, #0
10002de2:	1c19      	adds	r1, r3, #0
10002de4:	f7ff ff5c 	bl	10002ca0 <NVIC_SetPriority>
	   NVIC_SetPriority((IRQn_Type)Handle->NodeID, 
			   	   	     NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
			   	   	     Handle->Priority,
			   	   	     Handle->SubPriority));
	#endif
	if(Handle->InterruptEnable == 1)
10002de8:	687b      	ldr	r3, [r7, #4]
10002dea:	78db      	ldrb	r3, [r3, #3]
10002dec:	2b01      	cmp	r3, #1
10002dee:	d103      	bne.n	10002df8 <NVIC002_lInit+0x2c>
	{
	   /* Enable Interrupt */
		NVIC002_EnableIRQ(Handle);
10002df0:	687b      	ldr	r3, [r7, #4]
10002df2:	1c18      	adds	r0, r3, #0
10002df4:	f7ff ffc4 	bl	10002d80 <NVIC002_EnableIRQ>
	}
   
}
10002df8:	46bd      	mov	sp, r7
10002dfa:	b002      	add	sp, #8
10002dfc:	bd80      	pop	{r7, pc}
10002dfe:	46c0      	nop			; (mov r8, r8)

10002e00 <DAVE_Init>:
// @Parameters    None
//
//****************************************************************************

void DAVE_Init(void)
{
10002e00:	b580      	push	{r7, lr}
10002e02:	af00      	add	r7, sp, #0

//****************************************************************************
// @Initialization of APPs Init Functions
//****************************************************************************
	//  MUX configurations
	DAVE_MUX_PreInit(); 
10002e04:	f000 f828 	bl	10002e58 <DAVE_MUX_PreInit>
	//  Initialization of app 'CLK002'		     
	CLK002_Init();
10002e08:	f000 f82a 	bl	10002e60 <CLK002_Init>
	 
	//  Initialization of app 'CCU4GLOBAL'		     
	CCU4GLOBAL_Init();
10002e0c:	f000 f93c 	bl	10003088 <CCU4GLOBAL_Init>
	 
	//  Initialization of app 'PWMSP001'		     
	PWMSP001_Init();
10002e10:	f7fe fbd8 	bl	100015c4 <PWMSP001_Init>
	 
	//  Initialization of app 'NVIC002'		     
	NVIC002_Init();
10002e14:	f7ff ffc2 	bl	10002d9c <NVIC002_Init>
	
      
	//  MUX configurations
	DAVE_MUX_Init();	
10002e18:	f000 f802 	bl	10002e20 <DAVE_MUX_Init>
} //  End of function DAVE_Init
10002e1c:	46bd      	mov	sp, r7
10002e1e:	bd80      	pop	{r7, pc}

10002e20 <DAVE_MUX_Init>:
** Description      : This is the Mux configuration                           **
**                                                                            **
*******************************************************************************/
           
void DAVE_MUX_Init(void)
{  
10002e20:	b580      	push	{r7, lr}
10002e22:	af00      	add	r7, sp, #0
       /*        SCU Macro definitions     */                  
        //********* Capture/Compare Unit 4 (CAPCOM4) CONFIGURATIONS ************************* 
                       
    // Configuring CCU40_CC40SRS  =  Service Request Selector

    WR_REG(CCU40_CC40->SRS, CCU4_CC4_SRS_POSR_Msk, CCU4_CC4_SRS_POSR_Pos, CCU_SR3);    
10002e24:	4a09      	ldr	r2, [pc, #36]	; (10002e4c <DAVE_MUX_Init+0x2c>)
10002e26:	4909      	ldr	r1, [pc, #36]	; (10002e4c <DAVE_MUX_Init+0x2c>)
10002e28:	23a8      	movs	r3, #168	; 0xa8
10002e2a:	58cb      	ldr	r3, [r1, r3]
10002e2c:	2103      	movs	r1, #3
10002e2e:	4319      	orrs	r1, r3
10002e30:	23a8      	movs	r3, #168	; 0xa8
10002e32:	50d1      	str	r1, [r2, r3]
   	 
            	         
                                                 

/*        PORT Macro definitions for IOCR_OE, IOCR_PCR & HWSEL_HW     */                                      
  WR_REG(PORT0->IOCR4, 0xb800U, PORT_IOCR_PC1_PCR_Pos, 0x14U);                /*P0.5 : PORT0_IOCR4_PC5_PCR and PORT0_IOCR4_PC5_OE */					   
10002e34:	4b06      	ldr	r3, [pc, #24]	; (10002e50 <DAVE_MUX_Init+0x30>)
10002e36:	4a06      	ldr	r2, [pc, #24]	; (10002e50 <DAVE_MUX_Init+0x30>)
10002e38:	6951      	ldr	r1, [r2, #20]
10002e3a:	4a06      	ldr	r2, [pc, #24]	; (10002e54 <DAVE_MUX_Init+0x34>)
10002e3c:	400a      	ands	r2, r1
10002e3e:	21a0      	movs	r1, #160	; 0xa0
10002e40:	0209      	lsls	r1, r1, #8
10002e42:	430a      	orrs	r2, r1
10002e44:	615a      	str	r2, [r3, #20]
					      
   	 
            	         
                                                     
}
10002e46:	46bd      	mov	sp, r7
10002e48:	bd80      	pop	{r7, pc}
10002e4a:	46c0      	nop			; (mov r8, r8)
10002e4c:	48040100 	.word	0x48040100
10002e50:	40040000 	.word	0x40040000
10002e54:	ffff47ff 	.word	0xffff47ff

10002e58 <DAVE_MUX_PreInit>:
** Description      : This is the Mux configuration                           **
**                                                                            **
*******************************************************************************/
 
void DAVE_MUX_PreInit(void)
{        
10002e58:	b580      	push	{r7, lr}
10002e5a:	af00      	add	r7, sp, #0

/*        PORT Macro definitions for IOCR_OE, IOCR_PCR & HWSEL_HW     */                       
}
10002e5c:	46bd      	mov	sp, r7
10002e5e:	bd80      	pop	{r7, pc}

10002e60 <CLK002_Init>:
  * @note   -
  * @param  None
  * @retval None
  */
void CLK002_Init(void)
{
10002e60:	b580      	push	{r7, lr}
10002e62:	af00      	add	r7, sp, #0
    /* Open the lock that protects privileged bits. */
    SCU_GENERAL->PASSWD = CLK002_DIRECT_ACCESS_ALLOW;
10002e64:	4b0a      	ldr	r3, [pc, #40]	; (10002e90 <CLK002_Init+0x30>)
10002e66:	22c0      	movs	r2, #192	; 0xc0
10002e68:	625a      	str	r2, [r3, #36]	; 0x24

    /* Loop until protection is removed. */
    while(((SCU_GENERAL->PASSWD)&SCU_GENERAL_PASSWD_PROTS_Msk))
10002e6a:	46c0      	nop			; (mov r8, r8)
10002e6c:	4b08      	ldr	r3, [pc, #32]	; (10002e90 <CLK002_Init+0x30>)
10002e6e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
10002e70:	2304      	movs	r3, #4
10002e72:	4013      	ands	r3, r2
10002e74:	d1fa      	bne.n	10002e6c <CLK002_Init+0xc>
    {
	    ;
    }

    /* Update PCLK selection mux. */
    SCU_CLK->CLKCR|=(((uint32_t)CLK002_CLKCR_PCLKSEL<<\
10002e76:	4b07      	ldr	r3, [pc, #28]	; (10002e94 <CLK002_Init+0x34>)
10002e78:	4a06      	ldr	r2, [pc, #24]	; (10002e94 <CLK002_Init+0x34>)
10002e7a:	6812      	ldr	r2, [r2, #0]
10002e7c:	601a      	str	r2, [r3, #0]
	             (uint32_t)SCU_CLK_CLKCR_PCLKSEL_Pos)&SCU_CLK_CLKCR_PCLKSEL_Msk);

    CLK002_lDivUpdate();
10002e7e:	f000 f811 	bl	10002ea4 <CLK002_lDivUpdate>

    /*Close the lock opened above. */
    SCU_GENERAL->PASSWD = CLK002_DIRECT_ACCESS_DISALLOW;
10002e82:	4b03      	ldr	r3, [pc, #12]	; (10002e90 <CLK002_Init+0x30>)
10002e84:	22c3      	movs	r2, #195	; 0xc3
10002e86:	625a      	str	r2, [r3, #36]	; 0x24

    /* Update the clock variable */
    SystemCoreClockUpdate();
10002e88:	f7fe f942 	bl	10001110 <SystemCoreClockUpdate>
}
10002e8c:	46bd      	mov	sp, r7
10002e8e:	bd80      	pop	{r7, pc}
10002e90:	40010000 	.word	0x40010000
10002e94:	40010300 	.word	0x40010300

10002e98 <AllowClkInitByStartup>:
*         proceeds with program  loading. Return 0 to disallow CStart from
*         performing clock tree setup.
*/

uint32_t AllowClkInitByStartup(void)
{
10002e98:	b580      	push	{r7, lr}
10002e9a:	af00      	add	r7, sp, #0
    /* Return FALSE - Do not allow any initialisation by startup code. */
    return ((uint32_t)0);
10002e9c:	2300      	movs	r3, #0
}
10002e9e:	1c18      	adds	r0, r3, #0
10002ea0:	46bd      	mov	sp, r7
10002ea2:	bd80      	pop	{r7, pc}

10002ea4 <CLK002_lDivUpdate>:
  * @note   -
  * @param  None
  * @retval None
  */
static void CLK002_lDivUpdate(void)
{
10002ea4:	b580      	push	{r7, lr}
10002ea6:	b084      	sub	sp, #16
10002ea8:	af00      	add	r7, sp, #0
 /*  Find out current and target value of idiv */
 uint32_t lCurrIdiv= (uint32_t) 0;      /* Current idiv. */
10002eaa:	2300      	movs	r3, #0
10002eac:	60fb      	str	r3, [r7, #12]
 uint32_t lTargetidiv= (uint32_t) 0;    /* Target idiv. */
10002eae:	2300      	movs	r3, #0
10002eb0:	60bb      	str	r3, [r7, #8]
 uint32_t lCLKCR;
 lCurrIdiv = (((SCU_CLK->CLKCR)&SCU_CLK_CLKCR_IDIV_Msk)>>SCU_CLK_CLKCR_IDIV_Pos);
10002eb2:	4b18      	ldr	r3, [pc, #96]	; (10002f14 <CLK002_lDivUpdate+0x70>)
10002eb4:	681a      	ldr	r2, [r3, #0]
10002eb6:	23ff      	movs	r3, #255	; 0xff
10002eb8:	021b      	lsls	r3, r3, #8
10002eba:	4013      	ands	r3, r2
10002ebc:	0a1b      	lsrs	r3, r3, #8
10002ebe:	60fb      	str	r3, [r7, #12]
 lTargetidiv = CLK002_CLKCR_IDIV;
10002ec0:	2301      	movs	r3, #1
10002ec2:	60bb      	str	r3, [r7, #8]

 /* Update FDIV here, unconditionally. */

  lCLKCR = SCU_CLK->CLKCR;
10002ec4:	4b13      	ldr	r3, [pc, #76]	; (10002f14 <CLK002_lDivUpdate+0x70>)
10002ec6:	681b      	ldr	r3, [r3, #0]
10002ec8:	607b      	str	r3, [r7, #4]
  WR_REG(lCLKCR, SCU_CLK_CLKCR_FDIV_Msk, SCU_CLK_CLKCR_FDIV_Pos,CLK002_CLKCR_FDIV);
10002eca:	687b      	ldr	r3, [r7, #4]
10002ecc:	22ff      	movs	r2, #255	; 0xff
10002ece:	4393      	bics	r3, r2
10002ed0:	607b      	str	r3, [r7, #4]
  SCU_CLK->CLKCR = lCLKCR;
10002ed2:	4b10      	ldr	r3, [pc, #64]	; (10002f14 <CLK002_lDivUpdate+0x70>)
10002ed4:	687a      	ldr	r2, [r7, #4]
10002ed6:	601a      	str	r2, [r3, #0]

     /* Delay, till frequency stable, appox. 15us. */


  WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);
10002ed8:	4b0e      	ldr	r3, [pc, #56]	; (10002f14 <CLK002_lDivUpdate+0x70>)
10002eda:	4a0e      	ldr	r2, [pc, #56]	; (10002f14 <CLK002_lDivUpdate+0x70>)
10002edc:	6812      	ldr	r2, [r2, #0]
10002ede:	490e      	ldr	r1, [pc, #56]	; (10002f18 <CLK002_lDivUpdate+0x74>)
10002ee0:	430a      	orrs	r2, r1
10002ee2:	601a      	str	r2, [r3, #0]
  while (SCU_CLK->CLKCR&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
10002ee4:	46c0      	nop			; (mov r8, r8)
10002ee6:	4b0b      	ldr	r3, [pc, #44]	; (10002f14 <CLK002_lDivUpdate+0x70>)
10002ee8:	681a      	ldr	r2, [r3, #0]
10002eea:	2380      	movs	r3, #128	; 0x80
10002eec:	05db      	lsls	r3, r3, #23
10002eee:	4013      	ands	r3, r2
10002ef0:	d1f9      	bne.n	10002ee6 <CLK002_lDivUpdate+0x42>
    ;
  }


    /* Find out current value of direction in which idiv has to update. */
 if (lCurrIdiv==lTargetidiv)
10002ef2:	68fa      	ldr	r2, [r7, #12]
10002ef4:	68bb      	ldr	r3, [r7, #8]
10002ef6:	429a      	cmp	r2, r3
10002ef8:	d008      	beq.n	10002f0c <CLK002_lDivUpdate+0x68>
  {
   /*No change in IDIV. */
  }
 else if(lCurrIdiv < lTargetidiv)
10002efa:	68fa      	ldr	r2, [r7, #12]
10002efc:	68bb      	ldr	r3, [r7, #8]
10002efe:	429a      	cmp	r2, r3
10002f00:	d202      	bcs.n	10002f08 <CLK002_lDivUpdate+0x64>
  {
    CLK002_lFrequencyDownScaling();
10002f02:	f000 f869 	bl	10002fd8 <CLK002_lFrequencyDownScaling>
10002f06:	e001      	b.n	10002f0c <CLK002_lDivUpdate+0x68>
  }
  else
   {
     CLK002_lFrequencyUpScaling();
10002f08:	f000 f808 	bl	10002f1c <CLK002_lFrequencyUpScaling>
   }

}
10002f0c:	46bd      	mov	sp, r7
10002f0e:	b004      	add	sp, #16
10002f10:	bd80      	pop	{r7, pc}
10002f12:	46c0      	nop			; (mov r8, r8)
10002f14:	40010300 	.word	0x40010300
10002f18:	3ff00000 	.word	0x3ff00000

10002f1c <CLK002_lFrequencyUpScaling>:
  * @note   -
  * @param  None
  * @retval None
  */
static void     CLK002_lFrequencyUpScaling()
{
10002f1c:	b580      	push	{r7, lr}
10002f1e:	b084      	sub	sp, #16
10002f20:	af00      	add	r7, sp, #0
  uint32_t CurrIdiv;
  uint32_t TargetIdiv;
  uint32_t lCLKCR;
  CurrIdiv = (((SCU_CLK->CLKCR)&SCU_CLK_CLKCR_IDIV_Msk)>>SCU_CLK_CLKCR_IDIV_Pos);
10002f22:	4b2a      	ldr	r3, [pc, #168]	; (10002fcc <CLK002_lFrequencyUpScaling+0xb0>)
10002f24:	681a      	ldr	r2, [r3, #0]
10002f26:	23ff      	movs	r3, #255	; 0xff
10002f28:	021b      	lsls	r3, r3, #8
10002f2a:	4013      	ands	r3, r2
10002f2c:	0a1b      	lsrs	r3, r3, #8
10002f2e:	60fb      	str	r3, [r7, #12]
  TargetIdiv = CLK002_CLKCR_IDIV;
10002f30:	2301      	movs	r3, #1
10002f32:	60bb      	str	r3, [r7, #8]
  while(1)
  {
    if(CurrIdiv > (TargetIdiv * 4UL))
10002f34:	68bb      	ldr	r3, [r7, #8]
10002f36:	009a      	lsls	r2, r3, #2
10002f38:	68fb      	ldr	r3, [r7, #12]
10002f3a:	429a      	cmp	r2, r3
10002f3c:	d224      	bcs.n	10002f88 <CLK002_lFrequencyUpScaling+0x6c>
    {
        CurrIdiv = (CurrIdiv & 0xFFFFFFFCU) + 4U;
10002f3e:	68fb      	ldr	r3, [r7, #12]
10002f40:	2203      	movs	r2, #3
10002f42:	4393      	bics	r3, r2
10002f44:	3304      	adds	r3, #4
10002f46:	60fb      	str	r3, [r7, #12]
        CurrIdiv  = CurrIdiv >> 2;   /* Divide by 4. */
10002f48:	68fb      	ldr	r3, [r7, #12]
10002f4a:	089b      	lsrs	r3, r3, #2
10002f4c:	60fb      	str	r3, [r7, #12]
        /* Program interim value of IDIV. */

        lCLKCR = SCU_CLK->CLKCR;
10002f4e:	4b1f      	ldr	r3, [pc, #124]	; (10002fcc <CLK002_lFrequencyUpScaling+0xb0>)
10002f50:	681b      	ldr	r3, [r3, #0]
10002f52:	607b      	str	r3, [r7, #4]
        WR_REG(lCLKCR, SCU_CLK_CLKCR_IDIV_Msk, SCU_CLK_CLKCR_IDIV_Pos,CurrIdiv);
10002f54:	68fb      	ldr	r3, [r7, #12]
10002f56:	021b      	lsls	r3, r3, #8
10002f58:	041b      	lsls	r3, r3, #16
10002f5a:	0c1a      	lsrs	r2, r3, #16
10002f5c:	6879      	ldr	r1, [r7, #4]
10002f5e:	4b1c      	ldr	r3, [pc, #112]	; (10002fd0 <CLK002_lFrequencyUpScaling+0xb4>)
10002f60:	400b      	ands	r3, r1
10002f62:	4313      	orrs	r3, r2
10002f64:	607b      	str	r3, [r7, #4]
        SCU_CLK->CLKCR = lCLKCR;
10002f66:	4b19      	ldr	r3, [pc, #100]	; (10002fcc <CLK002_lFrequencyUpScaling+0xb0>)
10002f68:	687a      	ldr	r2, [r7, #4]
10002f6a:	601a      	str	r2, [r3, #0]

        /* Wait till frequency stable. */
        WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);
10002f6c:	4b17      	ldr	r3, [pc, #92]	; (10002fcc <CLK002_lFrequencyUpScaling+0xb0>)
10002f6e:	4a17      	ldr	r2, [pc, #92]	; (10002fcc <CLK002_lFrequencyUpScaling+0xb0>)
10002f70:	6812      	ldr	r2, [r2, #0]
10002f72:	4918      	ldr	r1, [pc, #96]	; (10002fd4 <CLK002_lFrequencyUpScaling+0xb8>)
10002f74:	430a      	orrs	r2, r1
10002f76:	601a      	str	r2, [r3, #0]
        while (SCU_CLK->CLKCR&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
10002f78:	46c0      	nop			; (mov r8, r8)
10002f7a:	4b14      	ldr	r3, [pc, #80]	; (10002fcc <CLK002_lFrequencyUpScaling+0xb0>)
10002f7c:	681a      	ldr	r2, [r3, #0]
10002f7e:	2380      	movs	r3, #128	; 0x80
10002f80:	05db      	lsls	r3, r3, #23
10002f82:	4013      	ands	r3, r2
10002f84:	d1f9      	bne.n	10002f7a <CLK002_lFrequencyUpScaling+0x5e>
10002f86:	e01c      	b.n	10002fc2 <CLK002_lFrequencyUpScaling+0xa6>
        }
    }
    else
    {
        /* Program TargetIDiv into IDIV bitfield of CLKCR. */
        lCLKCR = SCU_CLK->CLKCR;
10002f88:	4b10      	ldr	r3, [pc, #64]	; (10002fcc <CLK002_lFrequencyUpScaling+0xb0>)
10002f8a:	681b      	ldr	r3, [r3, #0]
10002f8c:	607b      	str	r3, [r7, #4]
        WR_REG(lCLKCR, SCU_CLK_CLKCR_IDIV_Msk, SCU_CLK_CLKCR_IDIV_Pos,TargetIdiv);
10002f8e:	68bb      	ldr	r3, [r7, #8]
10002f90:	021b      	lsls	r3, r3, #8
10002f92:	041b      	lsls	r3, r3, #16
10002f94:	0c1a      	lsrs	r2, r3, #16
10002f96:	6879      	ldr	r1, [r7, #4]
10002f98:	4b0d      	ldr	r3, [pc, #52]	; (10002fd0 <CLK002_lFrequencyUpScaling+0xb4>)
10002f9a:	400b      	ands	r3, r1
10002f9c:	4313      	orrs	r3, r2
10002f9e:	607b      	str	r3, [r7, #4]
        SCU_CLK->CLKCR = lCLKCR;
10002fa0:	4b0a      	ldr	r3, [pc, #40]	; (10002fcc <CLK002_lFrequencyUpScaling+0xb0>)
10002fa2:	687a      	ldr	r2, [r7, #4]
10002fa4:	601a      	str	r2, [r3, #0]
        /* Wait till frequency stable. */
        WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);
10002fa6:	4b09      	ldr	r3, [pc, #36]	; (10002fcc <CLK002_lFrequencyUpScaling+0xb0>)
10002fa8:	4a08      	ldr	r2, [pc, #32]	; (10002fcc <CLK002_lFrequencyUpScaling+0xb0>)
10002faa:	6812      	ldr	r2, [r2, #0]
10002fac:	4909      	ldr	r1, [pc, #36]	; (10002fd4 <CLK002_lFrequencyUpScaling+0xb8>)
10002fae:	430a      	orrs	r2, r1
10002fb0:	601a      	str	r2, [r3, #0]
        while (SCU_CLK->CLKCR&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
10002fb2:	46c0      	nop			; (mov r8, r8)
10002fb4:	4b05      	ldr	r3, [pc, #20]	; (10002fcc <CLK002_lFrequencyUpScaling+0xb0>)
10002fb6:	681a      	ldr	r2, [r3, #0]
10002fb8:	2380      	movs	r3, #128	; 0x80
10002fba:	05db      	lsls	r3, r3, #23
10002fbc:	4013      	ands	r3, r2
10002fbe:	d1f9      	bne.n	10002fb4 <CLK002_lFrequencyUpScaling+0x98>
        {
            ;
        }
        break;
10002fc0:	e000      	b.n	10002fc4 <CLK002_lFrequencyUpScaling+0xa8>
    }

  }
10002fc2:	e7b7      	b.n	10002f34 <CLK002_lFrequencyUpScaling+0x18>

}
10002fc4:	46bd      	mov	sp, r7
10002fc6:	b004      	add	sp, #16
10002fc8:	bd80      	pop	{r7, pc}
10002fca:	46c0      	nop			; (mov r8, r8)
10002fcc:	40010300 	.word	0x40010300
10002fd0:	ffff00ff 	.word	0xffff00ff
10002fd4:	3ff00000 	.word	0x3ff00000

10002fd8 <CLK002_lFrequencyDownScaling>:
  * @note   -
  * @param  None
  * @retval None
  */
static void     CLK002_lFrequencyDownScaling()
{
10002fd8:	b580      	push	{r7, lr}
10002fda:	b084      	sub	sp, #16
10002fdc:	af00      	add	r7, sp, #0
    uint32_t CurrIdiv;
    uint32_t TargetIdiv;
    uint32_t lCLKCR;
    CurrIdiv = (((SCU_CLK->CLKCR)&SCU_CLK_CLKCR_IDIV_Msk)>>SCU_CLK_CLKCR_IDIV_Pos);
10002fde:	4b27      	ldr	r3, [pc, #156]	; (1000307c <CLK002_lFrequencyDownScaling+0xa4>)
10002fe0:	681a      	ldr	r2, [r3, #0]
10002fe2:	23ff      	movs	r3, #255	; 0xff
10002fe4:	021b      	lsls	r3, r3, #8
10002fe6:	4013      	ands	r3, r2
10002fe8:	0a1b      	lsrs	r3, r3, #8
10002fea:	60fb      	str	r3, [r7, #12]
    TargetIdiv = CLK002_CLKCR_IDIV;
10002fec:	2301      	movs	r3, #1
10002fee:	60bb      	str	r3, [r7, #8]
    while(1)
    {
        if((CurrIdiv * 4UL) < TargetIdiv )
10002ff0:	68fb      	ldr	r3, [r7, #12]
10002ff2:	009a      	lsls	r2, r3, #2
10002ff4:	68bb      	ldr	r3, [r7, #8]
10002ff6:	429a      	cmp	r2, r3
10002ff8:	d21f      	bcs.n	1000303a <CLK002_lFrequencyDownScaling+0x62>
        {
            CurrIdiv  = CurrIdiv << 2;   /* Multiply by 4. */
10002ffa:	68fb      	ldr	r3, [r7, #12]
10002ffc:	009b      	lsls	r3, r3, #2
10002ffe:	60fb      	str	r3, [r7, #12]
            /* Program interim value of IDIV */
            lCLKCR = SCU_CLK->CLKCR;
10003000:	4b1e      	ldr	r3, [pc, #120]	; (1000307c <CLK002_lFrequencyDownScaling+0xa4>)
10003002:	681b      	ldr	r3, [r3, #0]
10003004:	607b      	str	r3, [r7, #4]
            WR_REG(lCLKCR, SCU_CLK_CLKCR_IDIV_Msk, SCU_CLK_CLKCR_IDIV_Pos,CurrIdiv);
10003006:	68fb      	ldr	r3, [r7, #12]
10003008:	021b      	lsls	r3, r3, #8
1000300a:	041b      	lsls	r3, r3, #16
1000300c:	0c1a      	lsrs	r2, r3, #16
1000300e:	6879      	ldr	r1, [r7, #4]
10003010:	4b1b      	ldr	r3, [pc, #108]	; (10003080 <CLK002_lFrequencyDownScaling+0xa8>)
10003012:	400b      	ands	r3, r1
10003014:	4313      	orrs	r3, r2
10003016:	607b      	str	r3, [r7, #4]
            SCU_CLK->CLKCR = lCLKCR;
10003018:	4b18      	ldr	r3, [pc, #96]	; (1000307c <CLK002_lFrequencyDownScaling+0xa4>)
1000301a:	687a      	ldr	r2, [r7, #4]
1000301c:	601a      	str	r2, [r3, #0]
            /* Wait till frequency stable. */
            WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);
1000301e:	4b17      	ldr	r3, [pc, #92]	; (1000307c <CLK002_lFrequencyDownScaling+0xa4>)
10003020:	4a16      	ldr	r2, [pc, #88]	; (1000307c <CLK002_lFrequencyDownScaling+0xa4>)
10003022:	6812      	ldr	r2, [r2, #0]
10003024:	4917      	ldr	r1, [pc, #92]	; (10003084 <CLK002_lFrequencyDownScaling+0xac>)
10003026:	430a      	orrs	r2, r1
10003028:	601a      	str	r2, [r3, #0]
            while (SCU_CLK->CLKCR&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
1000302a:	46c0      	nop			; (mov r8, r8)
1000302c:	4b13      	ldr	r3, [pc, #76]	; (1000307c <CLK002_lFrequencyDownScaling+0xa4>)
1000302e:	681a      	ldr	r2, [r3, #0]
10003030:	2380      	movs	r3, #128	; 0x80
10003032:	05db      	lsls	r3, r3, #23
10003034:	4013      	ands	r3, r2
10003036:	d1f9      	bne.n	1000302c <CLK002_lFrequencyDownScaling+0x54>
10003038:	e01c      	b.n	10003074 <CLK002_lFrequencyDownScaling+0x9c>
            }
        }
        else
        {
            /* Program TargetIDiv into IDIV bitfield of CLKCR */
            lCLKCR = SCU_CLK->CLKCR;
1000303a:	4b10      	ldr	r3, [pc, #64]	; (1000307c <CLK002_lFrequencyDownScaling+0xa4>)
1000303c:	681b      	ldr	r3, [r3, #0]
1000303e:	607b      	str	r3, [r7, #4]
            WR_REG(lCLKCR, SCU_CLK_CLKCR_IDIV_Msk, SCU_CLK_CLKCR_IDIV_Pos,TargetIdiv);
10003040:	68bb      	ldr	r3, [r7, #8]
10003042:	021b      	lsls	r3, r3, #8
10003044:	041b      	lsls	r3, r3, #16
10003046:	0c1a      	lsrs	r2, r3, #16
10003048:	6879      	ldr	r1, [r7, #4]
1000304a:	4b0d      	ldr	r3, [pc, #52]	; (10003080 <CLK002_lFrequencyDownScaling+0xa8>)
1000304c:	400b      	ands	r3, r1
1000304e:	4313      	orrs	r3, r2
10003050:	607b      	str	r3, [r7, #4]
            SCU_CLK->CLKCR = lCLKCR;
10003052:	4b0a      	ldr	r3, [pc, #40]	; (1000307c <CLK002_lFrequencyDownScaling+0xa4>)
10003054:	687a      	ldr	r2, [r7, #4]
10003056:	601a      	str	r2, [r3, #0]
            /* Wait till frequency stable. */
           
            WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);
10003058:	4b08      	ldr	r3, [pc, #32]	; (1000307c <CLK002_lFrequencyDownScaling+0xa4>)
1000305a:	4a08      	ldr	r2, [pc, #32]	; (1000307c <CLK002_lFrequencyDownScaling+0xa4>)
1000305c:	6812      	ldr	r2, [r2, #0]
1000305e:	4909      	ldr	r1, [pc, #36]	; (10003084 <CLK002_lFrequencyDownScaling+0xac>)
10003060:	430a      	orrs	r2, r1
10003062:	601a      	str	r2, [r3, #0]
            while (SCU_CLK->CLKCR&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
10003064:	46c0      	nop			; (mov r8, r8)
10003066:	4b05      	ldr	r3, [pc, #20]	; (1000307c <CLK002_lFrequencyDownScaling+0xa4>)
10003068:	681a      	ldr	r2, [r3, #0]
1000306a:	2380      	movs	r3, #128	; 0x80
1000306c:	05db      	lsls	r3, r3, #23
1000306e:	4013      	ands	r3, r2
10003070:	d1f9      	bne.n	10003066 <CLK002_lFrequencyDownScaling+0x8e>
            {
                ;
            }
             break;
10003072:	e000      	b.n	10003076 <CLK002_lFrequencyDownScaling+0x9e>
        }

	  }
10003074:	e7bc      	b.n	10002ff0 <CLK002_lFrequencyDownScaling+0x18>
}
10003076:	46bd      	mov	sp, r7
10003078:	b004      	add	sp, #16
1000307a:	bd80      	pop	{r7, pc}
1000307c:	40010300 	.word	0x40010300
10003080:	ffff00ff 	.word	0xffff00ff
10003084:	3ff00000 	.word	0x3ff00000

10003088 <CCU4GLOBAL_Init>:
/**
 * @cond INTERNAL_DOCS
 */

void CCU4GLOBAL_Init(void)
{
10003088:	b580      	push	{r7, lr}
1000308a:	b082      	sub	sp, #8
1000308c:	af00      	add	r7, sp, #0
  static uint32_t CCU4InitCalled = (uint32_t)0U;
  uint32_t Count = 0U;
1000308e:	2300      	movs	r3, #0
10003090:	607b      	str	r3, [r7, #4]
  
  if(CCU4InitCalled == (uint32_t)0U)
10003092:	4b0e      	ldr	r3, [pc, #56]	; (100030cc <CCU4GLOBAL_Init+0x44>)
10003094:	681b      	ldr	r3, [r3, #0]
10003096:	2b00      	cmp	r3, #0
10003098:	d114      	bne.n	100030c4 <CCU4GLOBAL_Init+0x3c>
	#if (UC_FAMILY == XMC4)     
		CLK001_Init();     
	#endif		
	
	#if (UC_FAMILY == XMC1)    
		CLK002_Init();
1000309a:	f7ff fee1 	bl	10002e60 <CLK002_Init>
	#endif
    
    for (Count = 0U; Count<(uint32_t)CCU4GLOBAL_NUM_INSTANCES; Count++)
1000309e:	2300      	movs	r3, #0
100030a0:	607b      	str	r3, [r7, #4]
100030a2:	e009      	b.n	100030b8 <CCU4GLOBAL_Init+0x30>
    {
  	  CCU4Global_lInit(CCU4Global_HandleArray[Count]);
100030a4:	4b0a      	ldr	r3, [pc, #40]	; (100030d0 <CCU4GLOBAL_Init+0x48>)
100030a6:	687a      	ldr	r2, [r7, #4]
100030a8:	0092      	lsls	r2, r2, #2
100030aa:	58d3      	ldr	r3, [r2, r3]
100030ac:	1c18      	adds	r0, r3, #0
100030ae:	f000 f811 	bl	100030d4 <CCU4Global_lInit>
	
	#if (UC_FAMILY == XMC1)    
		CLK002_Init();
	#endif
    
    for (Count = 0U; Count<(uint32_t)CCU4GLOBAL_NUM_INSTANCES; Count++)
100030b2:	687b      	ldr	r3, [r7, #4]
100030b4:	3301      	adds	r3, #1
100030b6:	607b      	str	r3, [r7, #4]
100030b8:	687b      	ldr	r3, [r7, #4]
100030ba:	2b00      	cmp	r3, #0
100030bc:	d0f2      	beq.n	100030a4 <CCU4GLOBAL_Init+0x1c>
    {
  	  CCU4Global_lInit(CCU4Global_HandleArray[Count]);
    }

    CCU4InitCalled = (uint32_t)1;
100030be:	4b03      	ldr	r3, [pc, #12]	; (100030cc <CCU4GLOBAL_Init+0x44>)
100030c0:	2201      	movs	r2, #1
100030c2:	601a      	str	r2, [r3, #0]
  }
}
100030c4:	46bd      	mov	sp, r7
100030c6:	b002      	add	sp, #8
100030c8:	bd80      	pop	{r7, pc}
100030ca:	46c0      	nop			; (mov r8, r8)
100030cc:	20000ad0 	.word	0x20000ad0
100030d0:	20000ae4 	.word	0x20000ae4

100030d4 <CCU4Global_lInit>:

static void CCU4Global_lInit(const CCU4Global_HandleType * Handle)
{
100030d4:	b590      	push	{r4, r7, lr}
100030d6:	b083      	sub	sp, #12
100030d8:	af00      	add	r7, sp, #0
100030da:	6078      	str	r0, [r7, #4]
    if( Handle->KernelNumber <= 2 )
100030dc:	687b      	ldr	r3, [r7, #4]
100030de:	685b      	ldr	r3, [r3, #4]
100030e0:	2b02      	cmp	r3, #2
100030e2:	d823      	bhi.n	1000312c <CCU4Global_lInit+0x58>
	{
		/* Disables the gating for CCU4 kernel */      
		/*This is applicable for XMC4400,XMC4200 and XMC1xxx Devices*/
		#if (UC_FAMILY == XMC1 )
			if (!((uint32_t)SCU_CLK->CGATCLR0 & Handle->ClockGating))
100030e4:	4b17      	ldr	r3, [pc, #92]	; (10003144 <CCU4Global_lInit+0x70>)
100030e6:	691a      	ldr	r2, [r3, #16]
100030e8:	687b      	ldr	r3, [r7, #4]
100030ea:	689b      	ldr	r3, [r3, #8]
100030ec:	4013      	ands	r3, r2
100030ee:	d11d      	bne.n	1000312c <CCU4Global_lInit+0x58>
			{ 
				SCU_GENERAL->PASSWD = 0x000000C0UL;
100030f0:	4b15      	ldr	r3, [pc, #84]	; (10003148 <CCU4Global_lInit+0x74>)
100030f2:	22c0      	movs	r2, #192	; 0xc0
100030f4:	625a      	str	r2, [r3, #36]	; 0x24
				WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, 
100030f6:	4b13      	ldr	r3, [pc, #76]	; (10003144 <CCU4Global_lInit+0x70>)
100030f8:	4a12      	ldr	r2, [pc, #72]	; (10003144 <CCU4Global_lInit+0x70>)
100030fa:	6812      	ldr	r2, [r2, #0]
100030fc:	4913      	ldr	r1, [pc, #76]	; (1000314c <CCU4Global_lInit+0x78>)
100030fe:	430a      	orrs	r2, r1
10003100:	601a      	str	r2, [r3, #0]
					   SCU_CLK_CLKCR_CNTADJ_Pos,CCU4GLOBAL_DELAYCNT);
				
				SET_BIT(SCU_CLK->CGATCLR0, Handle->ClockGating);
10003102:	4b10      	ldr	r3, [pc, #64]	; (10003144 <CCU4Global_lInit+0x70>)
10003104:	4a0f      	ldr	r2, [pc, #60]	; (10003144 <CCU4Global_lInit+0x70>)
10003106:	6911      	ldr	r1, [r2, #16]
10003108:	687a      	ldr	r2, [r7, #4]
1000310a:	6892      	ldr	r2, [r2, #8]
1000310c:	2001      	movs	r0, #1
1000310e:	1c04      	adds	r4, r0, #0
10003110:	4094      	lsls	r4, r2
10003112:	1c22      	adds	r2, r4, #0
10003114:	430a      	orrs	r2, r1
10003116:	611a      	str	r2, [r3, #16]
				while ((uint32_t)SCU_CLK->CLKCR & 
10003118:	46c0      	nop			; (mov r8, r8)
1000311a:	4b0a      	ldr	r3, [pc, #40]	; (10003144 <CCU4Global_lInit+0x70>)
1000311c:	681a      	ldr	r2, [r3, #0]
1000311e:	2380      	movs	r3, #128	; 0x80
10003120:	05db      	lsls	r3, r3, #23
10003122:	4013      	ands	r3, r2
10003124:	d1f9      	bne.n	1000311a <CCU4Global_lInit+0x46>
					   (uint32_t)SCU_CLK_CLKCR_VDDC2LOW_Msk)
				{
					;
				}
				SCU_GENERAL->PASSWD = 0x000000C3UL;
10003126:	4b08      	ldr	r3, [pc, #32]	; (10003148 <CCU4Global_lInit+0x74>)
10003128:	22c3      	movs	r2, #195	; 0xc3
1000312a:	625a      	str	r2, [r3, #36]	; 0x24
		RESET001_DeassertReset(Handle->PeripheralReset);
	#endif    

		
    /* Sets Run bit of the Prescalar */
    SET_BIT(Handle->CC4yKernRegsPtr->GIDLC,CCU4_GIDLC_SPRB_Pos);
1000312c:	687b      	ldr	r3, [r7, #4]
1000312e:	681b      	ldr	r3, [r3, #0]
10003130:	687a      	ldr	r2, [r7, #4]
10003132:	6812      	ldr	r2, [r2, #0]
10003134:	68d2      	ldr	r2, [r2, #12]
10003136:	2180      	movs	r1, #128	; 0x80
10003138:	0049      	lsls	r1, r1, #1
1000313a:	430a      	orrs	r2, r1
1000313c:	60da      	str	r2, [r3, #12]

}
1000313e:	46bd      	mov	sp, r7
10003140:	b003      	add	sp, #12
10003142:	bd90      	pop	{r4, r7, pc}
10003144:	40010300 	.word	0x40010300
10003148:	40010000 	.word	0x40010000
1000314c:	3ff00000 	.word	0x3ff00000

10003150 <__aeabi_uidiv>:
10003150:	2900      	cmp	r1, #0
10003152:	d034      	beq.n	100031be <.udivsi3_skip_div0_test+0x6a>

10003154 <.udivsi3_skip_div0_test>:
10003154:	2301      	movs	r3, #1
10003156:	2200      	movs	r2, #0
10003158:	b410      	push	{r4}
1000315a:	4288      	cmp	r0, r1
1000315c:	d32c      	bcc.n	100031b8 <.udivsi3_skip_div0_test+0x64>
1000315e:	2401      	movs	r4, #1
10003160:	0724      	lsls	r4, r4, #28
10003162:	42a1      	cmp	r1, r4
10003164:	d204      	bcs.n	10003170 <.udivsi3_skip_div0_test+0x1c>
10003166:	4281      	cmp	r1, r0
10003168:	d202      	bcs.n	10003170 <.udivsi3_skip_div0_test+0x1c>
1000316a:	0109      	lsls	r1, r1, #4
1000316c:	011b      	lsls	r3, r3, #4
1000316e:	e7f8      	b.n	10003162 <.udivsi3_skip_div0_test+0xe>
10003170:	00e4      	lsls	r4, r4, #3
10003172:	42a1      	cmp	r1, r4
10003174:	d204      	bcs.n	10003180 <.udivsi3_skip_div0_test+0x2c>
10003176:	4281      	cmp	r1, r0
10003178:	d202      	bcs.n	10003180 <.udivsi3_skip_div0_test+0x2c>
1000317a:	0049      	lsls	r1, r1, #1
1000317c:	005b      	lsls	r3, r3, #1
1000317e:	e7f8      	b.n	10003172 <.udivsi3_skip_div0_test+0x1e>
10003180:	4288      	cmp	r0, r1
10003182:	d301      	bcc.n	10003188 <.udivsi3_skip_div0_test+0x34>
10003184:	1a40      	subs	r0, r0, r1
10003186:	431a      	orrs	r2, r3
10003188:	084c      	lsrs	r4, r1, #1
1000318a:	42a0      	cmp	r0, r4
1000318c:	d302      	bcc.n	10003194 <.udivsi3_skip_div0_test+0x40>
1000318e:	1b00      	subs	r0, r0, r4
10003190:	085c      	lsrs	r4, r3, #1
10003192:	4322      	orrs	r2, r4
10003194:	088c      	lsrs	r4, r1, #2
10003196:	42a0      	cmp	r0, r4
10003198:	d302      	bcc.n	100031a0 <.udivsi3_skip_div0_test+0x4c>
1000319a:	1b00      	subs	r0, r0, r4
1000319c:	089c      	lsrs	r4, r3, #2
1000319e:	4322      	orrs	r2, r4
100031a0:	08cc      	lsrs	r4, r1, #3
100031a2:	42a0      	cmp	r0, r4
100031a4:	d302      	bcc.n	100031ac <.udivsi3_skip_div0_test+0x58>
100031a6:	1b00      	subs	r0, r0, r4
100031a8:	08dc      	lsrs	r4, r3, #3
100031aa:	4322      	orrs	r2, r4
100031ac:	2800      	cmp	r0, #0
100031ae:	d003      	beq.n	100031b8 <.udivsi3_skip_div0_test+0x64>
100031b0:	091b      	lsrs	r3, r3, #4
100031b2:	d001      	beq.n	100031b8 <.udivsi3_skip_div0_test+0x64>
100031b4:	0909      	lsrs	r1, r1, #4
100031b6:	e7e3      	b.n	10003180 <.udivsi3_skip_div0_test+0x2c>
100031b8:	1c10      	adds	r0, r2, #0
100031ba:	bc10      	pop	{r4}
100031bc:	4770      	bx	lr
100031be:	2800      	cmp	r0, #0
100031c0:	d001      	beq.n	100031c6 <.udivsi3_skip_div0_test+0x72>
100031c2:	2000      	movs	r0, #0
100031c4:	43c0      	mvns	r0, r0
100031c6:	b407      	push	{r0, r1, r2}
100031c8:	4802      	ldr	r0, [pc, #8]	; (100031d4 <.udivsi3_skip_div0_test+0x80>)
100031ca:	a102      	add	r1, pc, #8	; (adr r1, 100031d4 <.udivsi3_skip_div0_test+0x80>)
100031cc:	1840      	adds	r0, r0, r1
100031ce:	9002      	str	r0, [sp, #8]
100031d0:	bd03      	pop	{r0, r1, pc}
100031d2:	46c0      	nop			; (mov r8, r8)
100031d4:	000000d9 	.word	0x000000d9

100031d8 <__aeabi_uidivmod>:
100031d8:	2900      	cmp	r1, #0
100031da:	d0f0      	beq.n	100031be <.udivsi3_skip_div0_test+0x6a>
100031dc:	b503      	push	{r0, r1, lr}
100031de:	f7ff ffb9 	bl	10003154 <.udivsi3_skip_div0_test>
100031e2:	bc0e      	pop	{r1, r2, r3}
100031e4:	4342      	muls	r2, r0
100031e6:	1a89      	subs	r1, r1, r2
100031e8:	4718      	bx	r3
100031ea:	46c0      	nop			; (mov r8, r8)

100031ec <__aeabi_idiv>:
100031ec:	2900      	cmp	r1, #0
100031ee:	d041      	beq.n	10003274 <.divsi3_skip_div0_test+0x84>

100031f0 <.divsi3_skip_div0_test>:
100031f0:	b410      	push	{r4}
100031f2:	1c04      	adds	r4, r0, #0
100031f4:	404c      	eors	r4, r1
100031f6:	46a4      	mov	ip, r4
100031f8:	2301      	movs	r3, #1
100031fa:	2200      	movs	r2, #0
100031fc:	2900      	cmp	r1, #0
100031fe:	d500      	bpl.n	10003202 <.divsi3_skip_div0_test+0x12>
10003200:	4249      	negs	r1, r1
10003202:	2800      	cmp	r0, #0
10003204:	d500      	bpl.n	10003208 <.divsi3_skip_div0_test+0x18>
10003206:	4240      	negs	r0, r0
10003208:	4288      	cmp	r0, r1
1000320a:	d32c      	bcc.n	10003266 <.divsi3_skip_div0_test+0x76>
1000320c:	2401      	movs	r4, #1
1000320e:	0724      	lsls	r4, r4, #28
10003210:	42a1      	cmp	r1, r4
10003212:	d204      	bcs.n	1000321e <.divsi3_skip_div0_test+0x2e>
10003214:	4281      	cmp	r1, r0
10003216:	d202      	bcs.n	1000321e <.divsi3_skip_div0_test+0x2e>
10003218:	0109      	lsls	r1, r1, #4
1000321a:	011b      	lsls	r3, r3, #4
1000321c:	e7f8      	b.n	10003210 <.divsi3_skip_div0_test+0x20>
1000321e:	00e4      	lsls	r4, r4, #3
10003220:	42a1      	cmp	r1, r4
10003222:	d204      	bcs.n	1000322e <.divsi3_skip_div0_test+0x3e>
10003224:	4281      	cmp	r1, r0
10003226:	d202      	bcs.n	1000322e <.divsi3_skip_div0_test+0x3e>
10003228:	0049      	lsls	r1, r1, #1
1000322a:	005b      	lsls	r3, r3, #1
1000322c:	e7f8      	b.n	10003220 <.divsi3_skip_div0_test+0x30>
1000322e:	4288      	cmp	r0, r1
10003230:	d301      	bcc.n	10003236 <.divsi3_skip_div0_test+0x46>
10003232:	1a40      	subs	r0, r0, r1
10003234:	431a      	orrs	r2, r3
10003236:	084c      	lsrs	r4, r1, #1
10003238:	42a0      	cmp	r0, r4
1000323a:	d302      	bcc.n	10003242 <.divsi3_skip_div0_test+0x52>
1000323c:	1b00      	subs	r0, r0, r4
1000323e:	085c      	lsrs	r4, r3, #1
10003240:	4322      	orrs	r2, r4
10003242:	088c      	lsrs	r4, r1, #2
10003244:	42a0      	cmp	r0, r4
10003246:	d302      	bcc.n	1000324e <.divsi3_skip_div0_test+0x5e>
10003248:	1b00      	subs	r0, r0, r4
1000324a:	089c      	lsrs	r4, r3, #2
1000324c:	4322      	orrs	r2, r4
1000324e:	08cc      	lsrs	r4, r1, #3
10003250:	42a0      	cmp	r0, r4
10003252:	d302      	bcc.n	1000325a <.divsi3_skip_div0_test+0x6a>
10003254:	1b00      	subs	r0, r0, r4
10003256:	08dc      	lsrs	r4, r3, #3
10003258:	4322      	orrs	r2, r4
1000325a:	2800      	cmp	r0, #0
1000325c:	d003      	beq.n	10003266 <.divsi3_skip_div0_test+0x76>
1000325e:	091b      	lsrs	r3, r3, #4
10003260:	d001      	beq.n	10003266 <.divsi3_skip_div0_test+0x76>
10003262:	0909      	lsrs	r1, r1, #4
10003264:	e7e3      	b.n	1000322e <.divsi3_skip_div0_test+0x3e>
10003266:	1c10      	adds	r0, r2, #0
10003268:	4664      	mov	r4, ip
1000326a:	2c00      	cmp	r4, #0
1000326c:	d500      	bpl.n	10003270 <.divsi3_skip_div0_test+0x80>
1000326e:	4240      	negs	r0, r0
10003270:	bc10      	pop	{r4}
10003272:	4770      	bx	lr
10003274:	2800      	cmp	r0, #0
10003276:	d006      	beq.n	10003286 <.divsi3_skip_div0_test+0x96>
10003278:	db03      	blt.n	10003282 <.divsi3_skip_div0_test+0x92>
1000327a:	2000      	movs	r0, #0
1000327c:	43c0      	mvns	r0, r0
1000327e:	0840      	lsrs	r0, r0, #1
10003280:	e001      	b.n	10003286 <.divsi3_skip_div0_test+0x96>
10003282:	2080      	movs	r0, #128	; 0x80
10003284:	0600      	lsls	r0, r0, #24
10003286:	b407      	push	{r0, r1, r2}
10003288:	4802      	ldr	r0, [pc, #8]	; (10003294 <.divsi3_skip_div0_test+0xa4>)
1000328a:	a102      	add	r1, pc, #8	; (adr r1, 10003294 <.divsi3_skip_div0_test+0xa4>)
1000328c:	1840      	adds	r0, r0, r1
1000328e:	9002      	str	r0, [sp, #8]
10003290:	bd03      	pop	{r0, r1, pc}
10003292:	46c0      	nop			; (mov r8, r8)
10003294:	00000019 	.word	0x00000019

10003298 <__aeabi_idivmod>:
10003298:	2900      	cmp	r1, #0
1000329a:	d0eb      	beq.n	10003274 <.divsi3_skip_div0_test+0x84>
1000329c:	b503      	push	{r0, r1, lr}
1000329e:	f7ff ffa7 	bl	100031f0 <.divsi3_skip_div0_test>
100032a2:	bc0e      	pop	{r1, r2, r3}
100032a4:	4342      	muls	r2, r0
100032a6:	1a89      	subs	r1, r1, r2
100032a8:	4718      	bx	r3
100032aa:	46c0      	nop			; (mov r8, r8)

100032ac <__aeabi_idiv0>:
100032ac:	4770      	bx	lr
100032ae:	46c0      	nop			; (mov r8, r8)

100032b0 <__aeabi_cfrcmple>:
100032b0:	4684      	mov	ip, r0
100032b2:	1c08      	adds	r0, r1, #0
100032b4:	4661      	mov	r1, ip
100032b6:	e7ff      	b.n	100032b8 <__aeabi_cfcmpeq>

100032b8 <__aeabi_cfcmpeq>:
100032b8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
100032ba:	f000 f9f5 	bl	100036a8 <__lesf2>
100032be:	2800      	cmp	r0, #0
100032c0:	d401      	bmi.n	100032c6 <__aeabi_cfcmpeq+0xe>
100032c2:	2100      	movs	r1, #0
100032c4:	42c8      	cmn	r0, r1
100032c6:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

100032c8 <__aeabi_fcmpeq>:
100032c8:	b510      	push	{r4, lr}
100032ca:	f000 f97d 	bl	100035c8 <__eqsf2>
100032ce:	4240      	negs	r0, r0
100032d0:	3001      	adds	r0, #1
100032d2:	bd10      	pop	{r4, pc}

100032d4 <__aeabi_fcmplt>:
100032d4:	b510      	push	{r4, lr}
100032d6:	f000 f9e7 	bl	100036a8 <__lesf2>
100032da:	2800      	cmp	r0, #0
100032dc:	db01      	blt.n	100032e2 <__aeabi_fcmplt+0xe>
100032de:	2000      	movs	r0, #0
100032e0:	bd10      	pop	{r4, pc}
100032e2:	2001      	movs	r0, #1
100032e4:	bd10      	pop	{r4, pc}
100032e6:	46c0      	nop			; (mov r8, r8)

100032e8 <__aeabi_fcmple>:
100032e8:	b510      	push	{r4, lr}
100032ea:	f000 f9dd 	bl	100036a8 <__lesf2>
100032ee:	2800      	cmp	r0, #0
100032f0:	dd01      	ble.n	100032f6 <__aeabi_fcmple+0xe>
100032f2:	2000      	movs	r0, #0
100032f4:	bd10      	pop	{r4, pc}
100032f6:	2001      	movs	r0, #1
100032f8:	bd10      	pop	{r4, pc}
100032fa:	46c0      	nop			; (mov r8, r8)

100032fc <__aeabi_fcmpgt>:
100032fc:	b510      	push	{r4, lr}
100032fe:	f000 f98b 	bl	10003618 <__gesf2>
10003302:	2800      	cmp	r0, #0
10003304:	dc01      	bgt.n	1000330a <__aeabi_fcmpgt+0xe>
10003306:	2000      	movs	r0, #0
10003308:	bd10      	pop	{r4, pc}
1000330a:	2001      	movs	r0, #1
1000330c:	bd10      	pop	{r4, pc}
1000330e:	46c0      	nop			; (mov r8, r8)

10003310 <__aeabi_fcmpge>:
10003310:	b510      	push	{r4, lr}
10003312:	f000 f981 	bl	10003618 <__gesf2>
10003316:	2800      	cmp	r0, #0
10003318:	da01      	bge.n	1000331e <__aeabi_fcmpge+0xe>
1000331a:	2000      	movs	r0, #0
1000331c:	bd10      	pop	{r4, pc}
1000331e:	2001      	movs	r0, #1
10003320:	bd10      	pop	{r4, pc}
10003322:	46c0      	nop			; (mov r8, r8)

10003324 <__aeabi_f2uiz>:
10003324:	219e      	movs	r1, #158	; 0x9e
10003326:	b510      	push	{r4, lr}
10003328:	05c9      	lsls	r1, r1, #23
1000332a:	1c04      	adds	r4, r0, #0
1000332c:	f7ff fff0 	bl	10003310 <__aeabi_fcmpge>
10003330:	2800      	cmp	r0, #0
10003332:	d103      	bne.n	1000333c <__aeabi_f2uiz+0x18>
10003334:	1c20      	adds	r0, r4, #0
10003336:	f000 fd09 	bl	10003d4c <__aeabi_f2iz>
1000333a:	bd10      	pop	{r4, pc}
1000333c:	229e      	movs	r2, #158	; 0x9e
1000333e:	1c20      	adds	r0, r4, #0
10003340:	05d1      	lsls	r1, r2, #23
10003342:	f000 fb29 	bl	10003998 <__aeabi_fsub>
10003346:	f000 fd01 	bl	10003d4c <__aeabi_f2iz>
1000334a:	2380      	movs	r3, #128	; 0x80
1000334c:	061c      	lsls	r4, r3, #24
1000334e:	1900      	adds	r0, r0, r4
10003350:	e7f3      	b.n	1000333a <__aeabi_f2uiz+0x16>
10003352:	46c0      	nop			; (mov r8, r8)

10003354 <__aeabi_fdiv>:
10003354:	b5f0      	push	{r4, r5, r6, r7, lr}
10003356:	465f      	mov	r7, fp
10003358:	4656      	mov	r6, sl
1000335a:	464d      	mov	r5, r9
1000335c:	4644      	mov	r4, r8
1000335e:	b4f0      	push	{r4, r5, r6, r7}
10003360:	0245      	lsls	r5, r0, #9
10003362:	0044      	lsls	r4, r0, #1
10003364:	b083      	sub	sp, #12
10003366:	1c0e      	adds	r6, r1, #0
10003368:	0a6d      	lsrs	r5, r5, #9
1000336a:	0e24      	lsrs	r4, r4, #24
1000336c:	0fc7      	lsrs	r7, r0, #31
1000336e:	2c00      	cmp	r4, #0
10003370:	d107      	bne.n	10003382 <__aeabi_fdiv+0x2e>
10003372:	2d00      	cmp	r5, #0
10003374:	d000      	beq.n	10003378 <__aeabi_fdiv+0x24>
10003376:	e091      	b.n	1000349c <__aeabi_fdiv+0x148>
10003378:	2104      	movs	r1, #4
1000337a:	2201      	movs	r2, #1
1000337c:	4688      	mov	r8, r1
1000337e:	4692      	mov	sl, r2
10003380:	e009      	b.n	10003396 <__aeabi_fdiv+0x42>
10003382:	2cff      	cmp	r4, #255	; 0xff
10003384:	d055      	beq.n	10003432 <__aeabi_fdiv+0xde>
10003386:	2380      	movs	r3, #128	; 0x80
10003388:	0418      	lsls	r0, r3, #16
1000338a:	2100      	movs	r1, #0
1000338c:	4305      	orrs	r5, r0
1000338e:	00ed      	lsls	r5, r5, #3
10003390:	3c7f      	subs	r4, #127	; 0x7f
10003392:	4688      	mov	r8, r1
10003394:	468a      	mov	sl, r1
10003396:	1c33      	adds	r3, r6, #0
10003398:	0058      	lsls	r0, r3, #1
1000339a:	0276      	lsls	r6, r6, #9
1000339c:	0fd9      	lsrs	r1, r3, #31
1000339e:	0a76      	lsrs	r6, r6, #9
100033a0:	0e00      	lsrs	r0, r0, #24
100033a2:	468b      	mov	fp, r1
100033a4:	d14c      	bne.n	10003440 <__aeabi_fdiv+0xec>
100033a6:	2201      	movs	r2, #1
100033a8:	4694      	mov	ip, r2
100033aa:	2e00      	cmp	r6, #0
100033ac:	d000      	beq.n	100033b0 <__aeabi_fdiv+0x5c>
100033ae:	e081      	b.n	100034b4 <__aeabi_fdiv+0x160>
100033b0:	465b      	mov	r3, fp
100033b2:	407b      	eors	r3, r7
100033b4:	4662      	mov	r2, ip
100033b6:	4641      	mov	r1, r8
100033b8:	9301      	str	r3, [sp, #4]
100033ba:	430a      	orrs	r2, r1
100033bc:	2a0f      	cmp	r2, #15
100033be:	d950      	bls.n	10003462 <__aeabi_fdiv+0x10e>
100033c0:	1a20      	subs	r0, r4, r0
100033c2:	0169      	lsls	r1, r5, #5
100033c4:	4681      	mov	r9, r0
100033c6:	0175      	lsls	r5, r6, #5
100033c8:	42a9      	cmp	r1, r5
100033ca:	d300      	bcc.n	100033ce <__aeabi_fdiv+0x7a>
100033cc:	e0b3      	b.n	10003536 <__aeabi_fdiv+0x1e2>
100033ce:	2201      	movs	r2, #1
100033d0:	4253      	negs	r3, r2
100033d2:	4499      	add	r9, r3
100033d4:	241b      	movs	r4, #27
100033d6:	2600      	movs	r6, #0
100033d8:	2701      	movs	r7, #1
100033da:	1e62      	subs	r2, r4, #1
100033dc:	1c38      	adds	r0, r7, #0
100033de:	4010      	ands	r0, r2
100033e0:	004b      	lsls	r3, r1, #1
100033e2:	0076      	lsls	r6, r6, #1
100033e4:	2900      	cmp	r1, #0
100033e6:	da00      	bge.n	100033ea <__aeabi_fdiv+0x96>
100033e8:	e0a9      	b.n	1000353e <__aeabi_fdiv+0x1ea>
100033ea:	429d      	cmp	r5, r3
100033ec:	d800      	bhi.n	100033f0 <__aeabi_fdiv+0x9c>
100033ee:	e0a6      	b.n	1000353e <__aeabi_fdiv+0x1ea>
100033f0:	3c01      	subs	r4, #1
100033f2:	2c00      	cmp	r4, #0
100033f4:	dc00      	bgt.n	100033f8 <__aeabi_fdiv+0xa4>
100033f6:	e0ab      	b.n	10003550 <__aeabi_fdiv+0x1fc>
100033f8:	2800      	cmp	r0, #0
100033fa:	d00c      	beq.n	10003416 <__aeabi_fdiv+0xc2>
100033fc:	1c19      	adds	r1, r3, #0
100033fe:	0076      	lsls	r6, r6, #1
10003400:	005b      	lsls	r3, r3, #1
10003402:	2900      	cmp	r1, #0
10003404:	db01      	blt.n	1000340a <__aeabi_fdiv+0xb6>
10003406:	429d      	cmp	r5, r3
10003408:	d801      	bhi.n	1000340e <__aeabi_fdiv+0xba>
1000340a:	1b5b      	subs	r3, r3, r5
1000340c:	433e      	orrs	r6, r7
1000340e:	3c01      	subs	r4, #1
10003410:	2c00      	cmp	r4, #0
10003412:	dc00      	bgt.n	10003416 <__aeabi_fdiv+0xc2>
10003414:	e09c      	b.n	10003550 <__aeabi_fdiv+0x1fc>
10003416:	0059      	lsls	r1, r3, #1
10003418:	0072      	lsls	r2, r6, #1
1000341a:	2b00      	cmp	r3, #0
1000341c:	db01      	blt.n	10003422 <__aeabi_fdiv+0xce>
1000341e:	428d      	cmp	r5, r1
10003420:	d801      	bhi.n	10003426 <__aeabi_fdiv+0xd2>
10003422:	1b49      	subs	r1, r1, r5
10003424:	433a      	orrs	r2, r7
10003426:	3c01      	subs	r4, #1
10003428:	004b      	lsls	r3, r1, #1
1000342a:	0056      	lsls	r6, r2, #1
1000342c:	2900      	cmp	r1, #0
1000342e:	daea      	bge.n	10003406 <__aeabi_fdiv+0xb2>
10003430:	e7eb      	b.n	1000340a <__aeabi_fdiv+0xb6>
10003432:	2d00      	cmp	r5, #0
10003434:	d12d      	bne.n	10003492 <__aeabi_fdiv+0x13e>
10003436:	2008      	movs	r0, #8
10003438:	2102      	movs	r1, #2
1000343a:	4680      	mov	r8, r0
1000343c:	468a      	mov	sl, r1
1000343e:	e7aa      	b.n	10003396 <__aeabi_fdiv+0x42>
10003440:	28ff      	cmp	r0, #255	; 0xff
10003442:	d020      	beq.n	10003486 <__aeabi_fdiv+0x132>
10003444:	2280      	movs	r2, #128	; 0x80
10003446:	0413      	lsls	r3, r2, #16
10003448:	2100      	movs	r1, #0
1000344a:	431e      	orrs	r6, r3
1000344c:	468c      	mov	ip, r1
1000344e:	465b      	mov	r3, fp
10003450:	407b      	eors	r3, r7
10003452:	4662      	mov	r2, ip
10003454:	4641      	mov	r1, r8
10003456:	00f6      	lsls	r6, r6, #3
10003458:	387f      	subs	r0, #127	; 0x7f
1000345a:	9301      	str	r3, [sp, #4]
1000345c:	430a      	orrs	r2, r1
1000345e:	2a0f      	cmp	r2, #15
10003460:	d8ae      	bhi.n	100033c0 <__aeabi_fdiv+0x6c>
10003462:	4956      	ldr	r1, [pc, #344]	; (100035bc <__aeabi_fdiv+0x268>)
10003464:	0092      	lsls	r2, r2, #2
10003466:	588a      	ldr	r2, [r1, r2]
10003468:	4697      	mov	pc, r2
1000346a:	9b01      	ldr	r3, [sp, #4]
1000346c:	26ff      	movs	r6, #255	; 0xff
1000346e:	2500      	movs	r5, #0
10003470:	05f0      	lsls	r0, r6, #23
10003472:	4328      	orrs	r0, r5
10003474:	07de      	lsls	r6, r3, #31
10003476:	4330      	orrs	r0, r6
10003478:	b003      	add	sp, #12
1000347a:	bc3c      	pop	{r2, r3, r4, r5}
1000347c:	4690      	mov	r8, r2
1000347e:	4699      	mov	r9, r3
10003480:	46a2      	mov	sl, r4
10003482:	46ab      	mov	fp, r5
10003484:	bdf0      	pop	{r4, r5, r6, r7, pc}
10003486:	1c33      	adds	r3, r6, #0
10003488:	1e5a      	subs	r2, r3, #1
1000348a:	4193      	sbcs	r3, r2
1000348c:	3302      	adds	r3, #2
1000348e:	469c      	mov	ip, r3
10003490:	e78e      	b.n	100033b0 <__aeabi_fdiv+0x5c>
10003492:	220c      	movs	r2, #12
10003494:	2303      	movs	r3, #3
10003496:	4690      	mov	r8, r2
10003498:	469a      	mov	sl, r3
1000349a:	e77c      	b.n	10003396 <__aeabi_fdiv+0x42>
1000349c:	1c28      	adds	r0, r5, #0
1000349e:	f000 fcc9 	bl	10003e34 <__clzsi2>
100034a2:	2276      	movs	r2, #118	; 0x76
100034a4:	1f44      	subs	r4, r0, #5
100034a6:	4253      	negs	r3, r2
100034a8:	40a5      	lsls	r5, r4
100034aa:	1a1c      	subs	r4, r3, r0
100034ac:	2000      	movs	r0, #0
100034ae:	4680      	mov	r8, r0
100034b0:	4682      	mov	sl, r0
100034b2:	e770      	b.n	10003396 <__aeabi_fdiv+0x42>
100034b4:	1c30      	adds	r0, r6, #0
100034b6:	f000 fcbd 	bl	10003e34 <__clzsi2>
100034ba:	2376      	movs	r3, #118	; 0x76
100034bc:	1f41      	subs	r1, r0, #5
100034be:	408e      	lsls	r6, r1
100034c0:	425a      	negs	r2, r3
100034c2:	2100      	movs	r1, #0
100034c4:	1a10      	subs	r0, r2, r0
100034c6:	468c      	mov	ip, r1
100034c8:	e772      	b.n	100033b0 <__aeabi_fdiv+0x5c>
100034ca:	2300      	movs	r3, #0
100034cc:	4d3c      	ldr	r5, [pc, #240]	; (100035c0 <__aeabi_fdiv+0x26c>)
100034ce:	26ff      	movs	r6, #255	; 0xff
100034d0:	e7ce      	b.n	10003470 <__aeabi_fdiv+0x11c>
100034d2:	465f      	mov	r7, fp
100034d4:	1c35      	adds	r5, r6, #0
100034d6:	9701      	str	r7, [sp, #4]
100034d8:	4663      	mov	r3, ip
100034da:	2b02      	cmp	r3, #2
100034dc:	d0c5      	beq.n	1000346a <__aeabi_fdiv+0x116>
100034de:	2b03      	cmp	r3, #3
100034e0:	d063      	beq.n	100035aa <__aeabi_fdiv+0x256>
100034e2:	2b01      	cmp	r3, #1
100034e4:	d043      	beq.n	1000356e <__aeabi_fdiv+0x21a>
100034e6:	4649      	mov	r1, r9
100034e8:	317f      	adds	r1, #127	; 0x7f
100034ea:	2900      	cmp	r1, #0
100034ec:	dd35      	ble.n	1000355a <__aeabi_fdiv+0x206>
100034ee:	270f      	movs	r7, #15
100034f0:	402f      	ands	r7, r5
100034f2:	2f04      	cmp	r7, #4
100034f4:	d000      	beq.n	100034f8 <__aeabi_fdiv+0x1a4>
100034f6:	3504      	adds	r5, #4
100034f8:	012b      	lsls	r3, r5, #4
100034fa:	d503      	bpl.n	10003504 <__aeabi_fdiv+0x1b0>
100034fc:	4a31      	ldr	r2, [pc, #196]	; (100035c4 <__aeabi_fdiv+0x270>)
100034fe:	4649      	mov	r1, r9
10003500:	4015      	ands	r5, r2
10003502:	3180      	adds	r1, #128	; 0x80
10003504:	29fe      	cmp	r1, #254	; 0xfe
10003506:	dcb0      	bgt.n	1000346a <__aeabi_fdiv+0x116>
10003508:	01a8      	lsls	r0, r5, #6
1000350a:	0a45      	lsrs	r5, r0, #9
1000350c:	b2ce      	uxtb	r6, r1
1000350e:	9b01      	ldr	r3, [sp, #4]
10003510:	e7ae      	b.n	10003470 <__aeabi_fdiv+0x11c>
10003512:	2600      	movs	r6, #0
10003514:	2500      	movs	r5, #0
10003516:	e7ab      	b.n	10003470 <__aeabi_fdiv+0x11c>
10003518:	2080      	movs	r0, #128	; 0x80
1000351a:	03c1      	lsls	r1, r0, #15
1000351c:	420d      	tst	r5, r1
1000351e:	d011      	beq.n	10003544 <__aeabi_fdiv+0x1f0>
10003520:	420e      	tst	r6, r1
10003522:	d10f      	bne.n	10003544 <__aeabi_fdiv+0x1f0>
10003524:	430e      	orrs	r6, r1
10003526:	0273      	lsls	r3, r6, #9
10003528:	0a5d      	lsrs	r5, r3, #9
1000352a:	26ff      	movs	r6, #255	; 0xff
1000352c:	465b      	mov	r3, fp
1000352e:	e79f      	b.n	10003470 <__aeabi_fdiv+0x11c>
10003530:	9701      	str	r7, [sp, #4]
10003532:	4653      	mov	r3, sl
10003534:	e7d1      	b.n	100034da <__aeabi_fdiv+0x186>
10003536:	1b49      	subs	r1, r1, r5
10003538:	241a      	movs	r4, #26
1000353a:	2601      	movs	r6, #1
1000353c:	e74c      	b.n	100033d8 <__aeabi_fdiv+0x84>
1000353e:	1b5b      	subs	r3, r3, r5
10003540:	433e      	orrs	r6, r7
10003542:	e755      	b.n	100033f0 <__aeabi_fdiv+0x9c>
10003544:	430d      	orrs	r5, r1
10003546:	026a      	lsls	r2, r5, #9
10003548:	0a55      	lsrs	r5, r2, #9
1000354a:	1c3b      	adds	r3, r7, #0
1000354c:	26ff      	movs	r6, #255	; 0xff
1000354e:	e78f      	b.n	10003470 <__aeabi_fdiv+0x11c>
10003550:	1c1d      	adds	r5, r3, #0
10003552:	1e6b      	subs	r3, r5, #1
10003554:	419d      	sbcs	r5, r3
10003556:	4335      	orrs	r5, r6
10003558:	e7c5      	b.n	100034e6 <__aeabi_fdiv+0x192>
1000355a:	247e      	movs	r4, #126	; 0x7e
1000355c:	4267      	negs	r7, r4
1000355e:	464a      	mov	r2, r9
10003560:	1ab9      	subs	r1, r7, r2
10003562:	291b      	cmp	r1, #27
10003564:	dd08      	ble.n	10003578 <__aeabi_fdiv+0x224>
10003566:	9b01      	ldr	r3, [sp, #4]
10003568:	2600      	movs	r6, #0
1000356a:	2500      	movs	r5, #0
1000356c:	e780      	b.n	10003470 <__aeabi_fdiv+0x11c>
1000356e:	9d01      	ldr	r5, [sp, #4]
10003570:	2600      	movs	r6, #0
10003572:	402b      	ands	r3, r5
10003574:	2500      	movs	r5, #0
10003576:	e77b      	b.n	10003470 <__aeabi_fdiv+0x11c>
10003578:	464e      	mov	r6, r9
1000357a:	369e      	adds	r6, #158	; 0x9e
1000357c:	1c28      	adds	r0, r5, #0
1000357e:	40b5      	lsls	r5, r6
10003580:	1c2b      	adds	r3, r5, #0
10003582:	1e5d      	subs	r5, r3, #1
10003584:	41ab      	sbcs	r3, r5
10003586:	40c8      	lsrs	r0, r1
10003588:	4303      	orrs	r3, r0
1000358a:	250f      	movs	r5, #15
1000358c:	401d      	ands	r5, r3
1000358e:	2d04      	cmp	r5, #4
10003590:	d000      	beq.n	10003594 <__aeabi_fdiv+0x240>
10003592:	3304      	adds	r3, #4
10003594:	015a      	lsls	r2, r3, #5
10003596:	d503      	bpl.n	100035a0 <__aeabi_fdiv+0x24c>
10003598:	9b01      	ldr	r3, [sp, #4]
1000359a:	2601      	movs	r6, #1
1000359c:	2500      	movs	r5, #0
1000359e:	e767      	b.n	10003470 <__aeabi_fdiv+0x11c>
100035a0:	019c      	lsls	r4, r3, #6
100035a2:	0a65      	lsrs	r5, r4, #9
100035a4:	9b01      	ldr	r3, [sp, #4]
100035a6:	2600      	movs	r6, #0
100035a8:	e762      	b.n	10003470 <__aeabi_fdiv+0x11c>
100035aa:	2780      	movs	r7, #128	; 0x80
100035ac:	03fc      	lsls	r4, r7, #15
100035ae:	4325      	orrs	r5, r4
100035b0:	026e      	lsls	r6, r5, #9
100035b2:	0a75      	lsrs	r5, r6, #9
100035b4:	9b01      	ldr	r3, [sp, #4]
100035b6:	26ff      	movs	r6, #255	; 0xff
100035b8:	e75a      	b.n	10003470 <__aeabi_fdiv+0x11c>
100035ba:	46c0      	nop			; (mov r8, r8)
100035bc:	10003ed8 	.word	0x10003ed8
100035c0:	007fffff 	.word	0x007fffff
100035c4:	f7ffffff 	.word	0xf7ffffff

100035c8 <__eqsf2>:
100035c8:	0243      	lsls	r3, r0, #9
100035ca:	0042      	lsls	r2, r0, #1
100035cc:	b570      	push	{r4, r5, r6, lr}
100035ce:	0a5c      	lsrs	r4, r3, #9
100035d0:	0fc6      	lsrs	r6, r0, #31
100035d2:	0e13      	lsrs	r3, r2, #24
100035d4:	0248      	lsls	r0, r1, #9
100035d6:	004a      	lsls	r2, r1, #1
100035d8:	0a45      	lsrs	r5, r0, #9
100035da:	0e12      	lsrs	r2, r2, #24
100035dc:	0fc9      	lsrs	r1, r1, #31
100035de:	2bff      	cmp	r3, #255	; 0xff
100035e0:	d005      	beq.n	100035ee <__eqsf2+0x26>
100035e2:	2aff      	cmp	r2, #255	; 0xff
100035e4:	d008      	beq.n	100035f8 <__eqsf2+0x30>
100035e6:	2001      	movs	r0, #1
100035e8:	4293      	cmp	r3, r2
100035ea:	d00b      	beq.n	10003604 <__eqsf2+0x3c>
100035ec:	bd70      	pop	{r4, r5, r6, pc}
100035ee:	2001      	movs	r0, #1
100035f0:	2c00      	cmp	r4, #0
100035f2:	d1fb      	bne.n	100035ec <__eqsf2+0x24>
100035f4:	2aff      	cmp	r2, #255	; 0xff
100035f6:	d1f6      	bne.n	100035e6 <__eqsf2+0x1e>
100035f8:	2001      	movs	r0, #1
100035fa:	2d00      	cmp	r5, #0
100035fc:	d1f6      	bne.n	100035ec <__eqsf2+0x24>
100035fe:	2001      	movs	r0, #1
10003600:	4293      	cmp	r3, r2
10003602:	d1f3      	bne.n	100035ec <__eqsf2+0x24>
10003604:	42ac      	cmp	r4, r5
10003606:	d1f1      	bne.n	100035ec <__eqsf2+0x24>
10003608:	428e      	cmp	r6, r1
1000360a:	d003      	beq.n	10003614 <__eqsf2+0x4c>
1000360c:	2b00      	cmp	r3, #0
1000360e:	d1ed      	bne.n	100035ec <__eqsf2+0x24>
10003610:	2c00      	cmp	r4, #0
10003612:	d1eb      	bne.n	100035ec <__eqsf2+0x24>
10003614:	2000      	movs	r0, #0
10003616:	e7e9      	b.n	100035ec <__eqsf2+0x24>

10003618 <__gesf2>:
10003618:	b5f0      	push	{r4, r5, r6, r7, lr}
1000361a:	0243      	lsls	r3, r0, #9
1000361c:	0042      	lsls	r2, r0, #1
1000361e:	004f      	lsls	r7, r1, #1
10003620:	0fc6      	lsrs	r6, r0, #31
10003622:	0248      	lsls	r0, r1, #9
10003624:	0a5c      	lsrs	r4, r3, #9
10003626:	0a45      	lsrs	r5, r0, #9
10003628:	0e13      	lsrs	r3, r2, #24
1000362a:	0fc9      	lsrs	r1, r1, #31
1000362c:	0e3a      	lsrs	r2, r7, #24
1000362e:	2bff      	cmp	r3, #255	; 0xff
10003630:	d026      	beq.n	10003680 <__gesf2+0x68>
10003632:	2aff      	cmp	r2, #255	; 0xff
10003634:	d029      	beq.n	1000368a <__gesf2+0x72>
10003636:	2b00      	cmp	r3, #0
10003638:	d10c      	bne.n	10003654 <__gesf2+0x3c>
1000363a:	4260      	negs	r0, r4
1000363c:	4160      	adcs	r0, r4
1000363e:	4684      	mov	ip, r0
10003640:	2a00      	cmp	r2, #0
10003642:	d00a      	beq.n	1000365a <__gesf2+0x42>
10003644:	2800      	cmp	r0, #0
10003646:	d116      	bne.n	10003676 <__gesf2+0x5e>
10003648:	428e      	cmp	r6, r1
1000364a:	d021      	beq.n	10003690 <__gesf2+0x78>
1000364c:	2e00      	cmp	r6, #0
1000364e:	d114      	bne.n	1000367a <__gesf2+0x62>
10003650:	2001      	movs	r0, #1
10003652:	e014      	b.n	1000367e <__gesf2+0x66>
10003654:	2a00      	cmp	r2, #0
10003656:	d1f7      	bne.n	10003648 <__gesf2+0x30>
10003658:	4694      	mov	ip, r2
1000365a:	426f      	negs	r7, r5
1000365c:	416f      	adcs	r7, r5
1000365e:	4660      	mov	r0, ip
10003660:	2800      	cmp	r0, #0
10003662:	d105      	bne.n	10003670 <__gesf2+0x58>
10003664:	2f00      	cmp	r7, #0
10003666:	d0ef      	beq.n	10003648 <__gesf2+0x30>
10003668:	2001      	movs	r0, #1
1000366a:	2e00      	cmp	r6, #0
1000366c:	d007      	beq.n	1000367e <__gesf2+0x66>
1000366e:	e004      	b.n	1000367a <__gesf2+0x62>
10003670:	2000      	movs	r0, #0
10003672:	2f00      	cmp	r7, #0
10003674:	d103      	bne.n	1000367e <__gesf2+0x66>
10003676:	2900      	cmp	r1, #0
10003678:	d1ea      	bne.n	10003650 <__gesf2+0x38>
1000367a:	2101      	movs	r1, #1
1000367c:	4248      	negs	r0, r1
1000367e:	bdf0      	pop	{r4, r5, r6, r7, pc}
10003680:	2c00      	cmp	r4, #0
10003682:	d0d6      	beq.n	10003632 <__gesf2+0x1a>
10003684:	2202      	movs	r2, #2
10003686:	4250      	negs	r0, r2
10003688:	e7f9      	b.n	1000367e <__gesf2+0x66>
1000368a:	2d00      	cmp	r5, #0
1000368c:	d0d3      	beq.n	10003636 <__gesf2+0x1e>
1000368e:	e7f9      	b.n	10003684 <__gesf2+0x6c>
10003690:	4293      	cmp	r3, r2
10003692:	dcdb      	bgt.n	1000364c <__gesf2+0x34>
10003694:	db04      	blt.n	100036a0 <__gesf2+0x88>
10003696:	42ac      	cmp	r4, r5
10003698:	d8d8      	bhi.n	1000364c <__gesf2+0x34>
1000369a:	2000      	movs	r0, #0
1000369c:	42ac      	cmp	r4, r5
1000369e:	d2ee      	bcs.n	1000367e <__gesf2+0x66>
100036a0:	2e00      	cmp	r6, #0
100036a2:	d0ea      	beq.n	1000367a <__gesf2+0x62>
100036a4:	2001      	movs	r0, #1
100036a6:	e7ea      	b.n	1000367e <__gesf2+0x66>

100036a8 <__lesf2>:
100036a8:	b5f0      	push	{r4, r5, r6, r7, lr}
100036aa:	0243      	lsls	r3, r0, #9
100036ac:	0042      	lsls	r2, r0, #1
100036ae:	004f      	lsls	r7, r1, #1
100036b0:	0fc6      	lsrs	r6, r0, #31
100036b2:	0248      	lsls	r0, r1, #9
100036b4:	0a5c      	lsrs	r4, r3, #9
100036b6:	0a45      	lsrs	r5, r0, #9
100036b8:	0e13      	lsrs	r3, r2, #24
100036ba:	0fc9      	lsrs	r1, r1, #31
100036bc:	0e3a      	lsrs	r2, r7, #24
100036be:	2bff      	cmp	r3, #255	; 0xff
100036c0:	d026      	beq.n	10003710 <__lesf2+0x68>
100036c2:	2aff      	cmp	r2, #255	; 0xff
100036c4:	d028      	beq.n	10003718 <__lesf2+0x70>
100036c6:	2b00      	cmp	r3, #0
100036c8:	d00f      	beq.n	100036ea <__lesf2+0x42>
100036ca:	2a00      	cmp	r2, #0
100036cc:	d114      	bne.n	100036f8 <__lesf2+0x50>
100036ce:	4694      	mov	ip, r2
100036d0:	426f      	negs	r7, r5
100036d2:	416f      	adcs	r7, r5
100036d4:	4660      	mov	r0, ip
100036d6:	2800      	cmp	r0, #0
100036d8:	d014      	beq.n	10003704 <__lesf2+0x5c>
100036da:	2000      	movs	r0, #0
100036dc:	2f00      	cmp	r7, #0
100036de:	d103      	bne.n	100036e8 <__lesf2+0x40>
100036e0:	2900      	cmp	r1, #0
100036e2:	d10d      	bne.n	10003700 <__lesf2+0x58>
100036e4:	2101      	movs	r1, #1
100036e6:	4248      	negs	r0, r1
100036e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
100036ea:	4260      	negs	r0, r4
100036ec:	4160      	adcs	r0, r4
100036ee:	4684      	mov	ip, r0
100036f0:	2a00      	cmp	r2, #0
100036f2:	d0ed      	beq.n	100036d0 <__lesf2+0x28>
100036f4:	2800      	cmp	r0, #0
100036f6:	d1f3      	bne.n	100036e0 <__lesf2+0x38>
100036f8:	428e      	cmp	r6, r1
100036fa:	d011      	beq.n	10003720 <__lesf2+0x78>
100036fc:	2e00      	cmp	r6, #0
100036fe:	d1f1      	bne.n	100036e4 <__lesf2+0x3c>
10003700:	2001      	movs	r0, #1
10003702:	e7f1      	b.n	100036e8 <__lesf2+0x40>
10003704:	2f00      	cmp	r7, #0
10003706:	d0f7      	beq.n	100036f8 <__lesf2+0x50>
10003708:	2001      	movs	r0, #1
1000370a:	2e00      	cmp	r6, #0
1000370c:	d0ec      	beq.n	100036e8 <__lesf2+0x40>
1000370e:	e7e9      	b.n	100036e4 <__lesf2+0x3c>
10003710:	2002      	movs	r0, #2
10003712:	2c00      	cmp	r4, #0
10003714:	d1e8      	bne.n	100036e8 <__lesf2+0x40>
10003716:	e7d4      	b.n	100036c2 <__lesf2+0x1a>
10003718:	2002      	movs	r0, #2
1000371a:	2d00      	cmp	r5, #0
1000371c:	d1e4      	bne.n	100036e8 <__lesf2+0x40>
1000371e:	e7d2      	b.n	100036c6 <__lesf2+0x1e>
10003720:	4293      	cmp	r3, r2
10003722:	dceb      	bgt.n	100036fc <__lesf2+0x54>
10003724:	db04      	blt.n	10003730 <__lesf2+0x88>
10003726:	42ac      	cmp	r4, r5
10003728:	d8e8      	bhi.n	100036fc <__lesf2+0x54>
1000372a:	2000      	movs	r0, #0
1000372c:	42ac      	cmp	r4, r5
1000372e:	d2db      	bcs.n	100036e8 <__lesf2+0x40>
10003730:	2e00      	cmp	r6, #0
10003732:	d0d7      	beq.n	100036e4 <__lesf2+0x3c>
10003734:	2001      	movs	r0, #1
10003736:	e7d7      	b.n	100036e8 <__lesf2+0x40>

10003738 <__aeabi_fmul>:
10003738:	b5f0      	push	{r4, r5, r6, r7, lr}
1000373a:	465f      	mov	r7, fp
1000373c:	4656      	mov	r6, sl
1000373e:	464d      	mov	r5, r9
10003740:	4644      	mov	r4, r8
10003742:	b4f0      	push	{r4, r5, r6, r7}
10003744:	0245      	lsls	r5, r0, #9
10003746:	0046      	lsls	r6, r0, #1
10003748:	b083      	sub	sp, #12
1000374a:	1c0f      	adds	r7, r1, #0
1000374c:	0a6d      	lsrs	r5, r5, #9
1000374e:	0e36      	lsrs	r6, r6, #24
10003750:	0fc4      	lsrs	r4, r0, #31
10003752:	2e00      	cmp	r6, #0
10003754:	d106      	bne.n	10003764 <__aeabi_fmul+0x2c>
10003756:	2d00      	cmp	r5, #0
10003758:	d170      	bne.n	1000383c <__aeabi_fmul+0x104>
1000375a:	2104      	movs	r1, #4
1000375c:	2201      	movs	r2, #1
1000375e:	4688      	mov	r8, r1
10003760:	4692      	mov	sl, r2
10003762:	e009      	b.n	10003778 <__aeabi_fmul+0x40>
10003764:	2eff      	cmp	r6, #255	; 0xff
10003766:	d043      	beq.n	100037f0 <__aeabi_fmul+0xb8>
10003768:	2380      	movs	r3, #128	; 0x80
1000376a:	0418      	lsls	r0, r3, #16
1000376c:	2100      	movs	r1, #0
1000376e:	4305      	orrs	r5, r0
10003770:	00ed      	lsls	r5, r5, #3
10003772:	3e7f      	subs	r6, #127	; 0x7f
10003774:	4688      	mov	r8, r1
10003776:	468a      	mov	sl, r1
10003778:	1c38      	adds	r0, r7, #0
1000377a:	0043      	lsls	r3, r0, #1
1000377c:	027f      	lsls	r7, r7, #9
1000377e:	0fc1      	lsrs	r1, r0, #31
10003780:	0a7f      	lsrs	r7, r7, #9
10003782:	0e1b      	lsrs	r3, r3, #24
10003784:	468b      	mov	fp, r1
10003786:	d13a      	bne.n	100037fe <__aeabi_fmul+0xc6>
10003788:	2101      	movs	r1, #1
1000378a:	2f00      	cmp	r7, #0
1000378c:	d162      	bne.n	10003854 <__aeabi_fmul+0x11c>
1000378e:	4658      	mov	r0, fp
10003790:	4060      	eors	r0, r4
10003792:	4642      	mov	r2, r8
10003794:	9001      	str	r0, [sp, #4]
10003796:	430a      	orrs	r2, r1
10003798:	2a0f      	cmp	r2, #15
1000379a:	d93f      	bls.n	1000381c <__aeabi_fmul+0xe4>
1000379c:	042c      	lsls	r4, r5, #16
1000379e:	18f0      	adds	r0, r6, r3
100037a0:	0c26      	lsrs	r6, r4, #16
100037a2:	043b      	lsls	r3, r7, #16
100037a4:	0c1a      	lsrs	r2, r3, #16
100037a6:	1c31      	adds	r1, r6, #0
100037a8:	4351      	muls	r1, r2
100037aa:	0c3f      	lsrs	r7, r7, #16
100037ac:	0c2d      	lsrs	r5, r5, #16
100037ae:	437e      	muls	r6, r7
100037b0:	436a      	muls	r2, r5
100037b2:	4681      	mov	r9, r0
100037b4:	0c08      	lsrs	r0, r1, #16
100037b6:	1836      	adds	r6, r6, r0
100037b8:	1c2c      	adds	r4, r5, #0
100037ba:	18b3      	adds	r3, r6, r2
100037bc:	437c      	muls	r4, r7
100037be:	429a      	cmp	r2, r3
100037c0:	d900      	bls.n	100037c4 <__aeabi_fmul+0x8c>
100037c2:	e09a      	b.n	100038fa <__aeabi_fmul+0x1c2>
100037c4:	0409      	lsls	r1, r1, #16
100037c6:	041d      	lsls	r5, r3, #16
100037c8:	0c08      	lsrs	r0, r1, #16
100037ca:	182e      	adds	r6, r5, r0
100037cc:	01b5      	lsls	r5, r6, #6
100037ce:	0c1b      	lsrs	r3, r3, #16
100037d0:	1e69      	subs	r1, r5, #1
100037d2:	418d      	sbcs	r5, r1
100037d4:	0eb2      	lsrs	r2, r6, #26
100037d6:	18e7      	adds	r7, r4, r3
100037d8:	4315      	orrs	r5, r2
100037da:	01bc      	lsls	r4, r7, #6
100037dc:	4325      	orrs	r5, r4
100037de:	012b      	lsls	r3, r5, #4
100037e0:	d54b      	bpl.n	1000387a <__aeabi_fmul+0x142>
100037e2:	2001      	movs	r0, #1
100037e4:	4028      	ands	r0, r5
100037e6:	2101      	movs	r1, #1
100037e8:	086d      	lsrs	r5, r5, #1
100037ea:	4489      	add	r9, r1
100037ec:	4305      	orrs	r5, r0
100037ee:	e044      	b.n	1000387a <__aeabi_fmul+0x142>
100037f0:	2d00      	cmp	r5, #0
100037f2:	d11e      	bne.n	10003832 <__aeabi_fmul+0xfa>
100037f4:	2008      	movs	r0, #8
100037f6:	2102      	movs	r1, #2
100037f8:	4680      	mov	r8, r0
100037fa:	468a      	mov	sl, r1
100037fc:	e7bc      	b.n	10003778 <__aeabi_fmul+0x40>
100037fe:	2bff      	cmp	r3, #255	; 0xff
10003800:	d012      	beq.n	10003828 <__aeabi_fmul+0xf0>
10003802:	2280      	movs	r2, #128	; 0x80
10003804:	0410      	lsls	r0, r2, #16
10003806:	4307      	orrs	r7, r0
10003808:	4658      	mov	r0, fp
1000380a:	2100      	movs	r1, #0
1000380c:	4060      	eors	r0, r4
1000380e:	4642      	mov	r2, r8
10003810:	00ff      	lsls	r7, r7, #3
10003812:	3b7f      	subs	r3, #127	; 0x7f
10003814:	9001      	str	r0, [sp, #4]
10003816:	430a      	orrs	r2, r1
10003818:	2a0f      	cmp	r2, #15
1000381a:	d8bf      	bhi.n	1000379c <__aeabi_fmul+0x64>
1000381c:	0090      	lsls	r0, r2, #2
1000381e:	4a5b      	ldr	r2, [pc, #364]	; (1000398c <__aeabi_fmul+0x254>)
10003820:	4684      	mov	ip, r0
10003822:	4462      	add	r2, ip
10003824:	6810      	ldr	r0, [r2, #0]
10003826:	4687      	mov	pc, r0
10003828:	1c39      	adds	r1, r7, #0
1000382a:	1e4a      	subs	r2, r1, #1
1000382c:	4191      	sbcs	r1, r2
1000382e:	3102      	adds	r1, #2
10003830:	e7ad      	b.n	1000378e <__aeabi_fmul+0x56>
10003832:	220c      	movs	r2, #12
10003834:	2303      	movs	r3, #3
10003836:	4690      	mov	r8, r2
10003838:	469a      	mov	sl, r3
1000383a:	e79d      	b.n	10003778 <__aeabi_fmul+0x40>
1000383c:	1c28      	adds	r0, r5, #0
1000383e:	f000 faf9 	bl	10003e34 <__clzsi2>
10003842:	2276      	movs	r2, #118	; 0x76
10003844:	1f46      	subs	r6, r0, #5
10003846:	4253      	negs	r3, r2
10003848:	40b5      	lsls	r5, r6
1000384a:	1a1e      	subs	r6, r3, r0
1000384c:	2000      	movs	r0, #0
1000384e:	4680      	mov	r8, r0
10003850:	4682      	mov	sl, r0
10003852:	e791      	b.n	10003778 <__aeabi_fmul+0x40>
10003854:	1c38      	adds	r0, r7, #0
10003856:	f000 faed 	bl	10003e34 <__clzsi2>
1000385a:	2176      	movs	r1, #118	; 0x76
1000385c:	1f43      	subs	r3, r0, #5
1000385e:	424a      	negs	r2, r1
10003860:	409f      	lsls	r7, r3
10003862:	2100      	movs	r1, #0
10003864:	1a13      	subs	r3, r2, r0
10003866:	e792      	b.n	1000378e <__aeabi_fmul+0x56>
10003868:	9401      	str	r4, [sp, #4]
1000386a:	4651      	mov	r1, sl
1000386c:	2902      	cmp	r1, #2
1000386e:	d02c      	beq.n	100038ca <__aeabi_fmul+0x192>
10003870:	2903      	cmp	r1, #3
10003872:	d100      	bne.n	10003876 <__aeabi_fmul+0x13e>
10003874:	e080      	b.n	10003978 <__aeabi_fmul+0x240>
10003876:	2901      	cmp	r1, #1
10003878:	d048      	beq.n	1000390c <__aeabi_fmul+0x1d4>
1000387a:	464e      	mov	r6, r9
1000387c:	367f      	adds	r6, #127	; 0x7f
1000387e:	2e00      	cmp	r6, #0
10003880:	dd51      	ble.n	10003926 <__aeabi_fmul+0x1ee>
10003882:	240f      	movs	r4, #15
10003884:	402c      	ands	r4, r5
10003886:	2c04      	cmp	r4, #4
10003888:	d000      	beq.n	1000388c <__aeabi_fmul+0x154>
1000388a:	3504      	adds	r5, #4
1000388c:	012a      	lsls	r2, r5, #4
1000388e:	d503      	bpl.n	10003898 <__aeabi_fmul+0x160>
10003890:	493f      	ldr	r1, [pc, #252]	; (10003990 <__aeabi_fmul+0x258>)
10003892:	464e      	mov	r6, r9
10003894:	400d      	ands	r5, r1
10003896:	3680      	adds	r6, #128	; 0x80
10003898:	2efe      	cmp	r6, #254	; 0xfe
1000389a:	dd3d      	ble.n	10003918 <__aeabi_fmul+0x1e0>
1000389c:	9b01      	ldr	r3, [sp, #4]
1000389e:	2401      	movs	r4, #1
100038a0:	401c      	ands	r4, r3
100038a2:	21ff      	movs	r1, #255	; 0xff
100038a4:	2500      	movs	r5, #0
100038a6:	05c8      	lsls	r0, r1, #23
100038a8:	07e2      	lsls	r2, r4, #31
100038aa:	4328      	orrs	r0, r5
100038ac:	4310      	orrs	r0, r2
100038ae:	b003      	add	sp, #12
100038b0:	bc3c      	pop	{r2, r3, r4, r5}
100038b2:	4690      	mov	r8, r2
100038b4:	4699      	mov	r9, r3
100038b6:	46a2      	mov	sl, r4
100038b8:	46ab      	mov	fp, r5
100038ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
100038bc:	2400      	movs	r4, #0
100038be:	4d35      	ldr	r5, [pc, #212]	; (10003994 <__aeabi_fmul+0x25c>)
100038c0:	21ff      	movs	r1, #255	; 0xff
100038c2:	e7f0      	b.n	100038a6 <__aeabi_fmul+0x16e>
100038c4:	4651      	mov	r1, sl
100038c6:	2902      	cmp	r1, #2
100038c8:	d1d2      	bne.n	10003870 <__aeabi_fmul+0x138>
100038ca:	9d01      	ldr	r5, [sp, #4]
100038cc:	2401      	movs	r4, #1
100038ce:	402c      	ands	r4, r5
100038d0:	21ff      	movs	r1, #255	; 0xff
100038d2:	2500      	movs	r5, #0
100038d4:	e7e7      	b.n	100038a6 <__aeabi_fmul+0x16e>
100038d6:	465e      	mov	r6, fp
100038d8:	1c3d      	adds	r5, r7, #0
100038da:	9601      	str	r6, [sp, #4]
100038dc:	e7c6      	b.n	1000386c <__aeabi_fmul+0x134>
100038de:	1c3d      	adds	r5, r7, #0
100038e0:	e7c4      	b.n	1000386c <__aeabi_fmul+0x134>
100038e2:	2680      	movs	r6, #128	; 0x80
100038e4:	03f3      	lsls	r3, r6, #15
100038e6:	421d      	tst	r5, r3
100038e8:	d00b      	beq.n	10003902 <__aeabi_fmul+0x1ca>
100038ea:	421f      	tst	r7, r3
100038ec:	d109      	bne.n	10003902 <__aeabi_fmul+0x1ca>
100038ee:	431f      	orrs	r7, r3
100038f0:	027a      	lsls	r2, r7, #9
100038f2:	0a55      	lsrs	r5, r2, #9
100038f4:	465c      	mov	r4, fp
100038f6:	21ff      	movs	r1, #255	; 0xff
100038f8:	e7d5      	b.n	100038a6 <__aeabi_fmul+0x16e>
100038fa:	2280      	movs	r2, #128	; 0x80
100038fc:	0257      	lsls	r7, r2, #9
100038fe:	19e4      	adds	r4, r4, r7
10003900:	e760      	b.n	100037c4 <__aeabi_fmul+0x8c>
10003902:	431d      	orrs	r5, r3
10003904:	026f      	lsls	r7, r5, #9
10003906:	0a7d      	lsrs	r5, r7, #9
10003908:	21ff      	movs	r1, #255	; 0xff
1000390a:	e7cc      	b.n	100038a6 <__aeabi_fmul+0x16e>
1000390c:	9b01      	ldr	r3, [sp, #4]
1000390e:	2500      	movs	r5, #0
10003910:	4019      	ands	r1, r3
10003912:	b2cc      	uxtb	r4, r1
10003914:	2100      	movs	r1, #0
10003916:	e7c6      	b.n	100038a6 <__aeabi_fmul+0x16e>
10003918:	9801      	ldr	r0, [sp, #4]
1000391a:	01ad      	lsls	r5, r5, #6
1000391c:	2401      	movs	r4, #1
1000391e:	0a6d      	lsrs	r5, r5, #9
10003920:	b2f1      	uxtb	r1, r6
10003922:	4004      	ands	r4, r0
10003924:	e7bf      	b.n	100038a6 <__aeabi_fmul+0x16e>
10003926:	267e      	movs	r6, #126	; 0x7e
10003928:	4273      	negs	r3, r6
1000392a:	464a      	mov	r2, r9
1000392c:	1a9f      	subs	r7, r3, r2
1000392e:	2f1b      	cmp	r7, #27
10003930:	dd05      	ble.n	1000393e <__aeabi_fmul+0x206>
10003932:	9d01      	ldr	r5, [sp, #4]
10003934:	2401      	movs	r4, #1
10003936:	402c      	ands	r4, r5
10003938:	2100      	movs	r1, #0
1000393a:	2500      	movs	r5, #0
1000393c:	e7b3      	b.n	100038a6 <__aeabi_fmul+0x16e>
1000393e:	4649      	mov	r1, r9
10003940:	319e      	adds	r1, #158	; 0x9e
10003942:	1c2c      	adds	r4, r5, #0
10003944:	408d      	lsls	r5, r1
10003946:	1c2e      	adds	r6, r5, #0
10003948:	40fc      	lsrs	r4, r7
1000394a:	1e75      	subs	r5, r6, #1
1000394c:	41ae      	sbcs	r6, r5
1000394e:	4326      	orrs	r6, r4
10003950:	200f      	movs	r0, #15
10003952:	4030      	ands	r0, r6
10003954:	2804      	cmp	r0, #4
10003956:	d000      	beq.n	1000395a <__aeabi_fmul+0x222>
10003958:	3604      	adds	r6, #4
1000395a:	0170      	lsls	r0, r6, #5
1000395c:	d505      	bpl.n	1000396a <__aeabi_fmul+0x232>
1000395e:	9f01      	ldr	r7, [sp, #4]
10003960:	2401      	movs	r4, #1
10003962:	403c      	ands	r4, r7
10003964:	2101      	movs	r1, #1
10003966:	2500      	movs	r5, #0
10003968:	e79d      	b.n	100038a6 <__aeabi_fmul+0x16e>
1000396a:	9a01      	ldr	r2, [sp, #4]
1000396c:	01b3      	lsls	r3, r6, #6
1000396e:	2401      	movs	r4, #1
10003970:	0a5d      	lsrs	r5, r3, #9
10003972:	4014      	ands	r4, r2
10003974:	2100      	movs	r1, #0
10003976:	e796      	b.n	100038a6 <__aeabi_fmul+0x16e>
10003978:	2280      	movs	r2, #128	; 0x80
1000397a:	03d0      	lsls	r0, r2, #15
1000397c:	4305      	orrs	r5, r0
1000397e:	026c      	lsls	r4, r5, #9
10003980:	9901      	ldr	r1, [sp, #4]
10003982:	0a65      	lsrs	r5, r4, #9
10003984:	2401      	movs	r4, #1
10003986:	400c      	ands	r4, r1
10003988:	21ff      	movs	r1, #255	; 0xff
1000398a:	e78c      	b.n	100038a6 <__aeabi_fmul+0x16e>
1000398c:	10003f18 	.word	0x10003f18
10003990:	f7ffffff 	.word	0xf7ffffff
10003994:	007fffff 	.word	0x007fffff

10003998 <__aeabi_fsub>:
10003998:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1000399a:	0243      	lsls	r3, r0, #9
1000399c:	0045      	lsls	r5, r0, #1
1000399e:	024f      	lsls	r7, r1, #9
100039a0:	004c      	lsls	r4, r1, #1
100039a2:	0fc2      	lsrs	r2, r0, #31
100039a4:	0998      	lsrs	r0, r3, #6
100039a6:	4684      	mov	ip, r0
100039a8:	0e2d      	lsrs	r5, r5, #24
100039aa:	0e20      	lsrs	r0, r4, #24
100039ac:	0fc9      	lsrs	r1, r1, #31
100039ae:	09bf      	lsrs	r7, r7, #6
100039b0:	28ff      	cmp	r0, #255	; 0xff
100039b2:	d054      	beq.n	10003a5e <__aeabi_fsub+0xc6>
100039b4:	2601      	movs	r6, #1
100039b6:	4071      	eors	r1, r6
100039b8:	428a      	cmp	r2, r1
100039ba:	d03b      	beq.n	10003a34 <__aeabi_fsub+0x9c>
100039bc:	1a2c      	subs	r4, r5, r0
100039be:	2c00      	cmp	r4, #0
100039c0:	dc00      	bgt.n	100039c4 <__aeabi_fsub+0x2c>
100039c2:	e089      	b.n	10003ad8 <__aeabi_fsub+0x140>
100039c4:	2800      	cmp	r0, #0
100039c6:	d125      	bne.n	10003a14 <__aeabi_fsub+0x7c>
100039c8:	2f00      	cmp	r7, #0
100039ca:	d14b      	bne.n	10003a64 <__aeabi_fsub+0xcc>
100039cc:	1c6e      	adds	r6, r5, #1
100039ce:	1c2c      	adds	r4, r5, #0
100039d0:	4663      	mov	r3, ip
100039d2:	1c15      	adds	r5, r2, #0
100039d4:	220f      	movs	r2, #15
100039d6:	401a      	ands	r2, r3
100039d8:	2a04      	cmp	r2, #4
100039da:	d000      	beq.n	100039de <__aeabi_fsub+0x46>
100039dc:	3304      	adds	r3, #4
100039de:	2780      	movs	r7, #128	; 0x80
100039e0:	04f9      	lsls	r1, r7, #19
100039e2:	2201      	movs	r2, #1
100039e4:	4019      	ands	r1, r3
100039e6:	402a      	ands	r2, r5
100039e8:	2900      	cmp	r1, #0
100039ea:	d006      	beq.n	100039fa <__aeabi_fsub+0x62>
100039ec:	2eff      	cmp	r6, #255	; 0xff
100039ee:	d100      	bne.n	100039f2 <__aeabi_fsub+0x5a>
100039f0:	e081      	b.n	10003af6 <__aeabi_fsub+0x15e>
100039f2:	4db1      	ldr	r5, [pc, #708]	; (10003cb8 <__aeabi_fsub+0x320>)
100039f4:	1c34      	adds	r4, r6, #0
100039f6:	402b      	ands	r3, r5
100039f8:	3601      	adds	r6, #1
100039fa:	b2f6      	uxtb	r6, r6
100039fc:	08dd      	lsrs	r5, r3, #3
100039fe:	2e01      	cmp	r6, #1
10003a00:	dd62      	ble.n	10003ac8 <__aeabi_fsub+0x130>
10003a02:	026b      	lsls	r3, r5, #9
10003a04:	0a5d      	lsrs	r5, r3, #9
10003a06:	b2e4      	uxtb	r4, r4
10003a08:	05e4      	lsls	r4, r4, #23
10003a0a:	4325      	orrs	r5, r4
10003a0c:	1c28      	adds	r0, r5, #0
10003a0e:	07d2      	lsls	r2, r2, #31
10003a10:	4310      	orrs	r0, r2
10003a12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
10003a14:	2dff      	cmp	r5, #255	; 0xff
10003a16:	d051      	beq.n	10003abc <__aeabi_fsub+0x124>
10003a18:	2180      	movs	r1, #128	; 0x80
10003a1a:	04cb      	lsls	r3, r1, #19
10003a1c:	431f      	orrs	r7, r3
10003a1e:	2601      	movs	r6, #1
10003a20:	2c1b      	cmp	r4, #27
10003a22:	dd70      	ble.n	10003b06 <__aeabi_fsub+0x16e>
10003a24:	4667      	mov	r7, ip
10003a26:	1c2c      	adds	r4, r5, #0
10003a28:	1bbb      	subs	r3, r7, r6
10003a2a:	1c15      	adds	r5, r2, #0
10003a2c:	0158      	lsls	r0, r3, #5
10003a2e:	d422      	bmi.n	10003a76 <__aeabi_fsub+0xde>
10003a30:	1c66      	adds	r6, r4, #1
10003a32:	e7cf      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003a34:	1a2e      	subs	r6, r5, r0
10003a36:	2e00      	cmp	r6, #0
10003a38:	dd76      	ble.n	10003b28 <__aeabi_fsub+0x190>
10003a3a:	2800      	cmp	r0, #0
10003a3c:	d032      	beq.n	10003aa4 <__aeabi_fsub+0x10c>
10003a3e:	2dff      	cmp	r5, #255	; 0xff
10003a40:	d03c      	beq.n	10003abc <__aeabi_fsub+0x124>
10003a42:	2480      	movs	r4, #128	; 0x80
10003a44:	04e1      	lsls	r1, r4, #19
10003a46:	430f      	orrs	r7, r1
10003a48:	2301      	movs	r3, #1
10003a4a:	2e1b      	cmp	r6, #27
10003a4c:	dc00      	bgt.n	10003a50 <__aeabi_fsub+0xb8>
10003a4e:	e0d1      	b.n	10003bf4 <__aeabi_fsub+0x25c>
10003a50:	4463      	add	r3, ip
10003a52:	1c2c      	adds	r4, r5, #0
10003a54:	0158      	lsls	r0, r3, #5
10003a56:	d47a      	bmi.n	10003b4e <__aeabi_fsub+0x1b6>
10003a58:	1c66      	adds	r6, r4, #1
10003a5a:	1c15      	adds	r5, r2, #0
10003a5c:	e7ba      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003a5e:	2f00      	cmp	r7, #0
10003a60:	d1aa      	bne.n	100039b8 <__aeabi_fsub+0x20>
10003a62:	e7a7      	b.n	100039b4 <__aeabi_fsub+0x1c>
10003a64:	3c01      	subs	r4, #1
10003a66:	2c00      	cmp	r4, #0
10003a68:	d16d      	bne.n	10003b46 <__aeabi_fsub+0x1ae>
10003a6a:	4663      	mov	r3, ip
10003a6c:	1c2c      	adds	r4, r5, #0
10003a6e:	1bdb      	subs	r3, r3, r7
10003a70:	1c15      	adds	r5, r2, #0
10003a72:	0158      	lsls	r0, r3, #5
10003a74:	d5dc      	bpl.n	10003a30 <__aeabi_fsub+0x98>
10003a76:	019a      	lsls	r2, r3, #6
10003a78:	0996      	lsrs	r6, r2, #6
10003a7a:	1c30      	adds	r0, r6, #0
10003a7c:	f000 f9da 	bl	10003e34 <__clzsi2>
10003a80:	3805      	subs	r0, #5
10003a82:	4086      	lsls	r6, r0
10003a84:	4284      	cmp	r4, r0
10003a86:	dc39      	bgt.n	10003afc <__aeabi_fsub+0x164>
10003a88:	1b00      	subs	r0, r0, r4
10003a8a:	231f      	movs	r3, #31
10003a8c:	1a1a      	subs	r2, r3, r0
10003a8e:	1c33      	adds	r3, r6, #0
10003a90:	1c31      	adds	r1, r6, #0
10003a92:	1c44      	adds	r4, r0, #1
10003a94:	4093      	lsls	r3, r2
10003a96:	40e1      	lsrs	r1, r4
10003a98:	1e5e      	subs	r6, r3, #1
10003a9a:	41b3      	sbcs	r3, r6
10003a9c:	430b      	orrs	r3, r1
10003a9e:	2601      	movs	r6, #1
10003aa0:	2400      	movs	r4, #0
10003aa2:	e797      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003aa4:	2f00      	cmp	r7, #0
10003aa6:	d100      	bne.n	10003aaa <__aeabi_fsub+0x112>
10003aa8:	e790      	b.n	100039cc <__aeabi_fsub+0x34>
10003aaa:	3e01      	subs	r6, #1
10003aac:	2e00      	cmp	r6, #0
10003aae:	d103      	bne.n	10003ab8 <__aeabi_fsub+0x120>
10003ab0:	4664      	mov	r4, ip
10003ab2:	193b      	adds	r3, r7, r4
10003ab4:	1c2c      	adds	r4, r5, #0
10003ab6:	e7cd      	b.n	10003a54 <__aeabi_fsub+0xbc>
10003ab8:	2dff      	cmp	r5, #255	; 0xff
10003aba:	d1c5      	bne.n	10003a48 <__aeabi_fsub+0xb0>
10003abc:	1c15      	adds	r5, r2, #0
10003abe:	2280      	movs	r2, #128	; 0x80
10003ac0:	4663      	mov	r3, ip
10003ac2:	0056      	lsls	r6, r2, #1
10003ac4:	24ff      	movs	r4, #255	; 0xff
10003ac6:	e785      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003ac8:	2d00      	cmp	r5, #0
10003aca:	d09c      	beq.n	10003a06 <__aeabi_fsub+0x6e>
10003acc:	2c00      	cmp	r4, #0
10003ace:	d028      	beq.n	10003b22 <__aeabi_fsub+0x18a>
10003ad0:	2080      	movs	r0, #128	; 0x80
10003ad2:	03c7      	lsls	r7, r0, #15
10003ad4:	433d      	orrs	r5, r7
10003ad6:	e794      	b.n	10003a02 <__aeabi_fsub+0x6a>
10003ad8:	2c00      	cmp	r4, #0
10003ada:	d145      	bne.n	10003b68 <__aeabi_fsub+0x1d0>
10003adc:	1c6b      	adds	r3, r5, #1
10003ade:	b2d8      	uxtb	r0, r3
10003ae0:	2801      	cmp	r0, #1
10003ae2:	dc00      	bgt.n	10003ae6 <__aeabi_fsub+0x14e>
10003ae4:	e090      	b.n	10003c08 <__aeabi_fsub+0x270>
10003ae6:	4664      	mov	r4, ip
10003ae8:	1be6      	subs	r6, r4, r7
10003aea:	0173      	lsls	r3, r6, #5
10003aec:	d557      	bpl.n	10003b9e <__aeabi_fsub+0x206>
10003aee:	1b3e      	subs	r6, r7, r4
10003af0:	1c2c      	adds	r4, r5, #0
10003af2:	1c0d      	adds	r5, r1, #0
10003af4:	e7c1      	b.n	10003a7a <__aeabi_fsub+0xe2>
10003af6:	24ff      	movs	r4, #255	; 0xff
10003af8:	2500      	movs	r5, #0
10003afa:	e785      	b.n	10003a08 <__aeabi_fsub+0x70>
10003afc:	4b6e      	ldr	r3, [pc, #440]	; (10003cb8 <__aeabi_fsub+0x320>)
10003afe:	1a24      	subs	r4, r4, r0
10003b00:	4033      	ands	r3, r6
10003b02:	1c66      	adds	r6, r4, #1
10003b04:	e766      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003b06:	1c38      	adds	r0, r7, #0
10003b08:	2120      	movs	r1, #32
10003b0a:	40e0      	lsrs	r0, r4
10003b0c:	1b0c      	subs	r4, r1, r4
10003b0e:	40a7      	lsls	r7, r4
10003b10:	1c3e      	adds	r6, r7, #0
10003b12:	1e77      	subs	r7, r6, #1
10003b14:	41be      	sbcs	r6, r7
10003b16:	4306      	orrs	r6, r0
10003b18:	4667      	mov	r7, ip
10003b1a:	1c2c      	adds	r4, r5, #0
10003b1c:	1bbb      	subs	r3, r7, r6
10003b1e:	1c15      	adds	r5, r2, #0
10003b20:	e784      	b.n	10003a2c <__aeabi_fsub+0x94>
10003b22:	0269      	lsls	r1, r5, #9
10003b24:	0a4d      	lsrs	r5, r1, #9
10003b26:	e76f      	b.n	10003a08 <__aeabi_fsub+0x70>
10003b28:	2e00      	cmp	r6, #0
10003b2a:	d179      	bne.n	10003c20 <__aeabi_fsub+0x288>
10003b2c:	1c6c      	adds	r4, r5, #1
10003b2e:	b2e0      	uxtb	r0, r4
10003b30:	2801      	cmp	r0, #1
10003b32:	dd4b      	ble.n	10003bcc <__aeabi_fsub+0x234>
10003b34:	2cff      	cmp	r4, #255	; 0xff
10003b36:	d100      	bne.n	10003b3a <__aeabi_fsub+0x1a2>
10003b38:	e098      	b.n	10003c6c <__aeabi_fsub+0x2d4>
10003b3a:	4661      	mov	r1, ip
10003b3c:	187f      	adds	r7, r7, r1
10003b3e:	1cae      	adds	r6, r5, #2
10003b40:	087b      	lsrs	r3, r7, #1
10003b42:	1c15      	adds	r5, r2, #0
10003b44:	e746      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003b46:	2dff      	cmp	r5, #255	; 0xff
10003b48:	d000      	beq.n	10003b4c <__aeabi_fsub+0x1b4>
10003b4a:	e768      	b.n	10003a1e <__aeabi_fsub+0x86>
10003b4c:	e7b6      	b.n	10003abc <__aeabi_fsub+0x124>
10003b4e:	1c67      	adds	r7, r4, #1
10003b50:	2fff      	cmp	r7, #255	; 0xff
10003b52:	d036      	beq.n	10003bc2 <__aeabi_fsub+0x22a>
10003b54:	4858      	ldr	r0, [pc, #352]	; (10003cb8 <__aeabi_fsub+0x320>)
10003b56:	2101      	movs	r1, #1
10003b58:	4019      	ands	r1, r3
10003b5a:	4003      	ands	r3, r0
10003b5c:	085b      	lsrs	r3, r3, #1
10003b5e:	1ca6      	adds	r6, r4, #2
10003b60:	430b      	orrs	r3, r1
10003b62:	1c3c      	adds	r4, r7, #0
10003b64:	1c15      	adds	r5, r2, #0
10003b66:	e735      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003b68:	4266      	negs	r6, r4
10003b6a:	2d00      	cmp	r5, #0
10003b6c:	d01e      	beq.n	10003bac <__aeabi_fsub+0x214>
10003b6e:	28ff      	cmp	r0, #255	; 0xff
10003b70:	d06f      	beq.n	10003c52 <__aeabi_fsub+0x2ba>
10003b72:	2580      	movs	r5, #128	; 0x80
10003b74:	4662      	mov	r2, ip
10003b76:	04eb      	lsls	r3, r5, #19
10003b78:	431a      	orrs	r2, r3
10003b7a:	4694      	mov	ip, r2
10003b7c:	2501      	movs	r5, #1
10003b7e:	2e1b      	cmp	r6, #27
10003b80:	dc09      	bgt.n	10003b96 <__aeabi_fsub+0x1fe>
10003b82:	4662      	mov	r2, ip
10003b84:	2320      	movs	r3, #32
10003b86:	40f2      	lsrs	r2, r6
10003b88:	4664      	mov	r4, ip
10003b8a:	1b9e      	subs	r6, r3, r6
10003b8c:	40b4      	lsls	r4, r6
10003b8e:	1c25      	adds	r5, r4, #0
10003b90:	1e6c      	subs	r4, r5, #1
10003b92:	41a5      	sbcs	r5, r4
10003b94:	4315      	orrs	r5, r2
10003b96:	1b7b      	subs	r3, r7, r5
10003b98:	1c04      	adds	r4, r0, #0
10003b9a:	1c0d      	adds	r5, r1, #0
10003b9c:	e769      	b.n	10003a72 <__aeabi_fsub+0xda>
10003b9e:	2e00      	cmp	r6, #0
10003ba0:	d10c      	bne.n	10003bbc <__aeabi_fsub+0x224>
10003ba2:	2200      	movs	r2, #0
10003ba4:	2601      	movs	r6, #1
10003ba6:	2304      	movs	r3, #4
10003ba8:	2400      	movs	r4, #0
10003baa:	e726      	b.n	100039fa <__aeabi_fsub+0x62>
10003bac:	4664      	mov	r4, ip
10003bae:	2c00      	cmp	r4, #0
10003bb0:	d155      	bne.n	10003c5e <__aeabi_fsub+0x2c6>
10003bb2:	1c46      	adds	r6, r0, #1
10003bb4:	1c3b      	adds	r3, r7, #0
10003bb6:	1c04      	adds	r4, r0, #0
10003bb8:	1c0d      	adds	r5, r1, #0
10003bba:	e70b      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003bbc:	1c2c      	adds	r4, r5, #0
10003bbe:	1c15      	adds	r5, r2, #0
10003bc0:	e75b      	b.n	10003a7a <__aeabi_fsub+0xe2>
10003bc2:	2380      	movs	r3, #128	; 0x80
10003bc4:	005e      	lsls	r6, r3, #1
10003bc6:	24ff      	movs	r4, #255	; 0xff
10003bc8:	2304      	movs	r3, #4
10003bca:	e716      	b.n	100039fa <__aeabi_fsub+0x62>
10003bcc:	2d00      	cmp	r5, #0
10003bce:	d000      	beq.n	10003bd2 <__aeabi_fsub+0x23a>
10003bd0:	e08d      	b.n	10003cee <__aeabi_fsub+0x356>
10003bd2:	4665      	mov	r5, ip
10003bd4:	2d00      	cmp	r5, #0
10003bd6:	d100      	bne.n	10003bda <__aeabi_fsub+0x242>
10003bd8:	e0ad      	b.n	10003d36 <__aeabi_fsub+0x39e>
10003bda:	2f00      	cmp	r7, #0
10003bdc:	d100      	bne.n	10003be0 <__aeabi_fsub+0x248>
10003bde:	e081      	b.n	10003ce4 <__aeabi_fsub+0x34c>
10003be0:	197b      	adds	r3, r7, r5
10003be2:	015c      	lsls	r4, r3, #5
10003be4:	d400      	bmi.n	10003be8 <__aeabi_fsub+0x250>
10003be6:	e07e      	b.n	10003ce6 <__aeabi_fsub+0x34e>
10003be8:	4f33      	ldr	r7, [pc, #204]	; (10003cb8 <__aeabi_fsub+0x320>)
10003bea:	1c15      	adds	r5, r2, #0
10003bec:	403b      	ands	r3, r7
10003bee:	2602      	movs	r6, #2
10003bf0:	2401      	movs	r4, #1
10003bf2:	e6ef      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003bf4:	1c38      	adds	r0, r7, #0
10003bf6:	2320      	movs	r3, #32
10003bf8:	40f0      	lsrs	r0, r6
10003bfa:	1b9e      	subs	r6, r3, r6
10003bfc:	40b7      	lsls	r7, r6
10003bfe:	1c3b      	adds	r3, r7, #0
10003c00:	1e5f      	subs	r7, r3, #1
10003c02:	41bb      	sbcs	r3, r7
10003c04:	4303      	orrs	r3, r0
10003c06:	e723      	b.n	10003a50 <__aeabi_fsub+0xb8>
10003c08:	2d00      	cmp	r5, #0
10003c0a:	d115      	bne.n	10003c38 <__aeabi_fsub+0x2a0>
10003c0c:	4665      	mov	r5, ip
10003c0e:	2d00      	cmp	r5, #0
10003c10:	d147      	bne.n	10003ca2 <__aeabi_fsub+0x30a>
10003c12:	2f00      	cmp	r7, #0
10003c14:	d0c5      	beq.n	10003ba2 <__aeabi_fsub+0x20a>
10003c16:	1c3b      	adds	r3, r7, #0
10003c18:	1c0d      	adds	r5, r1, #0
10003c1a:	2601      	movs	r6, #1
10003c1c:	2400      	movs	r4, #0
10003c1e:	e6d9      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003c20:	4276      	negs	r6, r6
10003c22:	2d00      	cmp	r5, #0
10003c24:	d126      	bne.n	10003c74 <__aeabi_fsub+0x2dc>
10003c26:	4665      	mov	r5, ip
10003c28:	2d00      	cmp	r5, #0
10003c2a:	d000      	beq.n	10003c2e <__aeabi_fsub+0x296>
10003c2c:	e07d      	b.n	10003d2a <__aeabi_fsub+0x392>
10003c2e:	1c46      	adds	r6, r0, #1
10003c30:	1c3b      	adds	r3, r7, #0
10003c32:	1c04      	adds	r4, r0, #0
10003c34:	1c15      	adds	r5, r2, #0
10003c36:	e6cd      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003c38:	4665      	mov	r5, ip
10003c3a:	2d00      	cmp	r5, #0
10003c3c:	d140      	bne.n	10003cc0 <__aeabi_fsub+0x328>
10003c3e:	2f00      	cmp	r7, #0
10003c40:	d107      	bne.n	10003c52 <__aeabi_fsub+0x2ba>
10003c42:	2180      	movs	r1, #128	; 0x80
10003c44:	2200      	movs	r2, #0
10003c46:	004e      	lsls	r6, r1, #1
10003c48:	4b1c      	ldr	r3, [pc, #112]	; (10003cbc <__aeabi_fsub+0x324>)
10003c4a:	24ff      	movs	r4, #255	; 0xff
10003c4c:	e6d5      	b.n	100039fa <__aeabi_fsub+0x62>
10003c4e:	28ff      	cmp	r0, #255	; 0xff
10003c50:	d194      	bne.n	10003b7c <__aeabi_fsub+0x1e4>
10003c52:	2080      	movs	r0, #128	; 0x80
10003c54:	1c3b      	adds	r3, r7, #0
10003c56:	1c0d      	adds	r5, r1, #0
10003c58:	0046      	lsls	r6, r0, #1
10003c5a:	24ff      	movs	r4, #255	; 0xff
10003c5c:	e6ba      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003c5e:	3e01      	subs	r6, #1
10003c60:	2e00      	cmp	r6, #0
10003c62:	d1f4      	bne.n	10003c4e <__aeabi_fsub+0x2b6>
10003c64:	1b3b      	subs	r3, r7, r4
10003c66:	1c0d      	adds	r5, r1, #0
10003c68:	1c04      	adds	r4, r0, #0
10003c6a:	e702      	b.n	10003a72 <__aeabi_fsub+0xda>
10003c6c:	2580      	movs	r5, #128	; 0x80
10003c6e:	006e      	lsls	r6, r5, #1
10003c70:	2304      	movs	r3, #4
10003c72:	e6c2      	b.n	100039fa <__aeabi_fsub+0x62>
10003c74:	28ff      	cmp	r0, #255	; 0xff
10003c76:	d052      	beq.n	10003d1e <__aeabi_fsub+0x386>
10003c78:	2480      	movs	r4, #128	; 0x80
10003c7a:	4661      	mov	r1, ip
10003c7c:	04e3      	lsls	r3, r4, #19
10003c7e:	4319      	orrs	r1, r3
10003c80:	468c      	mov	ip, r1
10003c82:	2301      	movs	r3, #1
10003c84:	2e1b      	cmp	r6, #27
10003c86:	dc09      	bgt.n	10003c9c <__aeabi_fsub+0x304>
10003c88:	2120      	movs	r1, #32
10003c8a:	4664      	mov	r4, ip
10003c8c:	40f4      	lsrs	r4, r6
10003c8e:	4665      	mov	r5, ip
10003c90:	1b8e      	subs	r6, r1, r6
10003c92:	40b5      	lsls	r5, r6
10003c94:	1c2b      	adds	r3, r5, #0
10003c96:	1e59      	subs	r1, r3, #1
10003c98:	418b      	sbcs	r3, r1
10003c9a:	4323      	orrs	r3, r4
10003c9c:	19db      	adds	r3, r3, r7
10003c9e:	1c04      	adds	r4, r0, #0
10003ca0:	e6d8      	b.n	10003a54 <__aeabi_fsub+0xbc>
10003ca2:	2f00      	cmp	r7, #0
10003ca4:	d01e      	beq.n	10003ce4 <__aeabi_fsub+0x34c>
10003ca6:	1beb      	subs	r3, r5, r7
10003ca8:	0158      	lsls	r0, r3, #5
10003caa:	d54b      	bpl.n	10003d44 <__aeabi_fsub+0x3ac>
10003cac:	1b7b      	subs	r3, r7, r5
10003cae:	2601      	movs	r6, #1
10003cb0:	1c0d      	adds	r5, r1, #0
10003cb2:	2400      	movs	r4, #0
10003cb4:	e68e      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003cb6:	46c0      	nop			; (mov r8, r8)
10003cb8:	fbffffff 	.word	0xfbffffff
10003cbc:	03fffffc 	.word	0x03fffffc
10003cc0:	2f00      	cmp	r7, #0
10003cc2:	d100      	bne.n	10003cc6 <__aeabi_fsub+0x32e>
10003cc4:	e6fa      	b.n	10003abc <__aeabi_fsub+0x124>
10003cc6:	2080      	movs	r0, #128	; 0x80
10003cc8:	08eb      	lsrs	r3, r5, #3
10003cca:	03c4      	lsls	r4, r0, #15
10003ccc:	4223      	tst	r3, r4
10003cce:	d037      	beq.n	10003d40 <__aeabi_fsub+0x3a8>
10003cd0:	08ff      	lsrs	r7, r7, #3
10003cd2:	4227      	tst	r7, r4
10003cd4:	d134      	bne.n	10003d40 <__aeabi_fsub+0x3a8>
10003cd6:	1c3b      	adds	r3, r7, #0
10003cd8:	1c0d      	adds	r5, r1, #0
10003cda:	2280      	movs	r2, #128	; 0x80
10003cdc:	00db      	lsls	r3, r3, #3
10003cde:	0056      	lsls	r6, r2, #1
10003ce0:	24ff      	movs	r4, #255	; 0xff
10003ce2:	e677      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003ce4:	4663      	mov	r3, ip
10003ce6:	1c15      	adds	r5, r2, #0
10003ce8:	2601      	movs	r6, #1
10003cea:	2400      	movs	r4, #0
10003cec:	e672      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003cee:	4664      	mov	r4, ip
10003cf0:	2c00      	cmp	r4, #0
10003cf2:	d014      	beq.n	10003d1e <__aeabi_fsub+0x386>
10003cf4:	2f00      	cmp	r7, #0
10003cf6:	d100      	bne.n	10003cfa <__aeabi_fsub+0x362>
10003cf8:	e6e0      	b.n	10003abc <__aeabi_fsub+0x124>
10003cfa:	2380      	movs	r3, #128	; 0x80
10003cfc:	08e6      	lsrs	r6, r4, #3
10003cfe:	03d8      	lsls	r0, r3, #15
10003d00:	1c31      	adds	r1, r6, #0
10003d02:	4206      	tst	r6, r0
10003d04:	d003      	beq.n	10003d0e <__aeabi_fsub+0x376>
10003d06:	08f9      	lsrs	r1, r7, #3
10003d08:	4201      	tst	r1, r0
10003d0a:	d000      	beq.n	10003d0e <__aeabi_fsub+0x376>
10003d0c:	1c31      	adds	r1, r6, #0
10003d0e:	1c15      	adds	r5, r2, #0
10003d10:	2280      	movs	r2, #128	; 0x80
10003d12:	00cb      	lsls	r3, r1, #3
10003d14:	0056      	lsls	r6, r2, #1
10003d16:	24ff      	movs	r4, #255	; 0xff
10003d18:	e65c      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003d1a:	28ff      	cmp	r0, #255	; 0xff
10003d1c:	d1b1      	bne.n	10003c82 <__aeabi_fsub+0x2ea>
10003d1e:	2080      	movs	r0, #128	; 0x80
10003d20:	1c3b      	adds	r3, r7, #0
10003d22:	1c15      	adds	r5, r2, #0
10003d24:	0046      	lsls	r6, r0, #1
10003d26:	24ff      	movs	r4, #255	; 0xff
10003d28:	e654      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003d2a:	3e01      	subs	r6, #1
10003d2c:	2e00      	cmp	r6, #0
10003d2e:	d1f4      	bne.n	10003d1a <__aeabi_fsub+0x382>
10003d30:	197b      	adds	r3, r7, r5
10003d32:	1c04      	adds	r4, r0, #0
10003d34:	e68e      	b.n	10003a54 <__aeabi_fsub+0xbc>
10003d36:	1c3b      	adds	r3, r7, #0
10003d38:	1c15      	adds	r5, r2, #0
10003d3a:	2601      	movs	r6, #1
10003d3c:	2400      	movs	r4, #0
10003d3e:	e649      	b.n	100039d4 <__aeabi_fsub+0x3c>
10003d40:	1c15      	adds	r5, r2, #0
10003d42:	e7ca      	b.n	10003cda <__aeabi_fsub+0x342>
10003d44:	2b00      	cmp	r3, #0
10003d46:	d100      	bne.n	10003d4a <__aeabi_fsub+0x3b2>
10003d48:	e72b      	b.n	10003ba2 <__aeabi_fsub+0x20a>
10003d4a:	e7cc      	b.n	10003ce6 <__aeabi_fsub+0x34e>

10003d4c <__aeabi_f2iz>:
10003d4c:	0243      	lsls	r3, r0, #9
10003d4e:	0042      	lsls	r2, r0, #1
10003d50:	0a59      	lsrs	r1, r3, #9
10003d52:	0e13      	lsrs	r3, r2, #24
10003d54:	0fc2      	lsrs	r2, r0, #31
10003d56:	2000      	movs	r0, #0
10003d58:	2b7e      	cmp	r3, #126	; 0x7e
10003d5a:	dd0d      	ble.n	10003d78 <__aeabi_f2iz+0x2c>
10003d5c:	2b9d      	cmp	r3, #157	; 0x9d
10003d5e:	dc0c      	bgt.n	10003d7a <__aeabi_f2iz+0x2e>
10003d60:	2080      	movs	r0, #128	; 0x80
10003d62:	0400      	lsls	r0, r0, #16
10003d64:	4301      	orrs	r1, r0
10003d66:	2b95      	cmp	r3, #149	; 0x95
10003d68:	dc0a      	bgt.n	10003d80 <__aeabi_f2iz+0x34>
10003d6a:	2096      	movs	r0, #150	; 0x96
10003d6c:	1ac3      	subs	r3, r0, r3
10003d6e:	40d9      	lsrs	r1, r3
10003d70:	4248      	negs	r0, r1
10003d72:	2a00      	cmp	r2, #0
10003d74:	d100      	bne.n	10003d78 <__aeabi_f2iz+0x2c>
10003d76:	1c08      	adds	r0, r1, #0
10003d78:	4770      	bx	lr
10003d7a:	4903      	ldr	r1, [pc, #12]	; (10003d88 <__aeabi_f2iz+0x3c>)
10003d7c:	1850      	adds	r0, r2, r1
10003d7e:	e7fb      	b.n	10003d78 <__aeabi_f2iz+0x2c>
10003d80:	3b96      	subs	r3, #150	; 0x96
10003d82:	4099      	lsls	r1, r3
10003d84:	e7f4      	b.n	10003d70 <__aeabi_f2iz+0x24>
10003d86:	46c0      	nop			; (mov r8, r8)
10003d88:	7fffffff 	.word	0x7fffffff

10003d8c <__aeabi_ui2f>:
10003d8c:	b510      	push	{r4, lr}
10003d8e:	1e04      	subs	r4, r0, #0
10003d90:	d034      	beq.n	10003dfc <__aeabi_ui2f+0x70>
10003d92:	f000 f84f 	bl	10003e34 <__clzsi2>
10003d96:	239e      	movs	r3, #158	; 0x9e
10003d98:	1a1b      	subs	r3, r3, r0
10003d9a:	2b96      	cmp	r3, #150	; 0x96
10003d9c:	dc07      	bgt.n	10003dae <__aeabi_ui2f+0x22>
10003d9e:	3808      	subs	r0, #8
10003da0:	4084      	lsls	r4, r0
10003da2:	0264      	lsls	r4, r4, #9
10003da4:	0a61      	lsrs	r1, r4, #9
10003da6:	b2db      	uxtb	r3, r3
10003da8:	05d8      	lsls	r0, r3, #23
10003daa:	4308      	orrs	r0, r1
10003dac:	bd10      	pop	{r4, pc}
10003dae:	2b99      	cmp	r3, #153	; 0x99
10003db0:	dd0a      	ble.n	10003dc8 <__aeabi_ui2f+0x3c>
10003db2:	1c02      	adds	r2, r0, #0
10003db4:	321b      	adds	r2, #27
10003db6:	1c21      	adds	r1, r4, #0
10003db8:	4091      	lsls	r1, r2
10003dba:	1c0a      	adds	r2, r1, #0
10003dbc:	1e51      	subs	r1, r2, #1
10003dbe:	418a      	sbcs	r2, r1
10003dc0:	2105      	movs	r1, #5
10003dc2:	1a09      	subs	r1, r1, r0
10003dc4:	40cc      	lsrs	r4, r1
10003dc6:	4314      	orrs	r4, r2
10003dc8:	2805      	cmp	r0, #5
10003dca:	dc1a      	bgt.n	10003e02 <__aeabi_ui2f+0x76>
10003dcc:	4a18      	ldr	r2, [pc, #96]	; (10003e30 <__aeabi_ui2f+0xa4>)
10003dce:	210f      	movs	r1, #15
10003dd0:	4022      	ands	r2, r4
10003dd2:	400c      	ands	r4, r1
10003dd4:	2c04      	cmp	r4, #4
10003dd6:	d000      	beq.n	10003dda <__aeabi_ui2f+0x4e>
10003dd8:	3204      	adds	r2, #4
10003dda:	0151      	lsls	r1, r2, #5
10003ddc:	d505      	bpl.n	10003dea <__aeabi_ui2f+0x5e>
10003dde:	249f      	movs	r4, #159	; 0x9f
10003de0:	1a23      	subs	r3, r4, r0
10003de2:	2bff      	cmp	r3, #255	; 0xff
10003de4:	d021      	beq.n	10003e2a <__aeabi_ui2f+0x9e>
10003de6:	4812      	ldr	r0, [pc, #72]	; (10003e30 <__aeabi_ui2f+0xa4>)
10003de8:	4002      	ands	r2, r0
10003dea:	1c59      	adds	r1, r3, #1
10003dec:	b2cc      	uxtb	r4, r1
10003dee:	08d2      	lsrs	r2, r2, #3
10003df0:	2c01      	cmp	r4, #1
10003df2:	dd09      	ble.n	10003e08 <__aeabi_ui2f+0x7c>
10003df4:	0250      	lsls	r0, r2, #9
10003df6:	0a41      	lsrs	r1, r0, #9
10003df8:	b2db      	uxtb	r3, r3
10003dfa:	e7d5      	b.n	10003da8 <__aeabi_ui2f+0x1c>
10003dfc:	2300      	movs	r3, #0
10003dfe:	2100      	movs	r1, #0
10003e00:	e7d2      	b.n	10003da8 <__aeabi_ui2f+0x1c>
10003e02:	1f42      	subs	r2, r0, #5
10003e04:	4094      	lsls	r4, r2
10003e06:	e7e1      	b.n	10003dcc <__aeabi_ui2f+0x40>
10003e08:	2a00      	cmp	r2, #0
10003e0a:	d00b      	beq.n	10003e24 <__aeabi_ui2f+0x98>
10003e0c:	2b00      	cmp	r3, #0
10003e0e:	d006      	beq.n	10003e1e <__aeabi_ui2f+0x92>
10003e10:	2180      	movs	r1, #128	; 0x80
10003e12:	03cc      	lsls	r4, r1, #15
10003e14:	4322      	orrs	r2, r4
10003e16:	0252      	lsls	r2, r2, #9
10003e18:	0a51      	lsrs	r1, r2, #9
10003e1a:	b2db      	uxtb	r3, r3
10003e1c:	e7c4      	b.n	10003da8 <__aeabi_ui2f+0x1c>
10003e1e:	0250      	lsls	r0, r2, #9
10003e20:	0a41      	lsrs	r1, r0, #9
10003e22:	e7c1      	b.n	10003da8 <__aeabi_ui2f+0x1c>
10003e24:	b2db      	uxtb	r3, r3
10003e26:	2100      	movs	r1, #0
10003e28:	e7be      	b.n	10003da8 <__aeabi_ui2f+0x1c>
10003e2a:	23ff      	movs	r3, #255	; 0xff
10003e2c:	2100      	movs	r1, #0
10003e2e:	e7bb      	b.n	10003da8 <__aeabi_ui2f+0x1c>
10003e30:	fbffffff 	.word	0xfbffffff

10003e34 <__clzsi2>:
10003e34:	211c      	movs	r1, #28
10003e36:	2301      	movs	r3, #1
10003e38:	041b      	lsls	r3, r3, #16
10003e3a:	4298      	cmp	r0, r3
10003e3c:	d301      	bcc.n	10003e42 <__clzsi2+0xe>
10003e3e:	0c00      	lsrs	r0, r0, #16
10003e40:	3910      	subs	r1, #16
10003e42:	0a1b      	lsrs	r3, r3, #8
10003e44:	4298      	cmp	r0, r3
10003e46:	d301      	bcc.n	10003e4c <__clzsi2+0x18>
10003e48:	0a00      	lsrs	r0, r0, #8
10003e4a:	3908      	subs	r1, #8
10003e4c:	091b      	lsrs	r3, r3, #4
10003e4e:	4298      	cmp	r0, r3
10003e50:	d301      	bcc.n	10003e56 <__clzsi2+0x22>
10003e52:	0900      	lsrs	r0, r0, #4
10003e54:	3904      	subs	r1, #4
10003e56:	a202      	add	r2, pc, #8	; (adr r2, 10003e60 <__clzsi2+0x2c>)
10003e58:	5c10      	ldrb	r0, [r2, r0]
10003e5a:	1840      	adds	r0, r0, r1
10003e5c:	4770      	bx	lr
10003e5e:	46c0      	nop			; (mov r8, r8)
10003e60:	02020304 	.word	0x02020304
10003e64:	01010101 	.word	0x01010101
	...

Disassembly of section .VENEER_Code:

2000000c <HardFault_Veneer>:

/* ==================VENEERS VENEERS VENEERS VENEERS VENEERS=============== */
    .section ".XmcVeneerCode","ax",%progbits
.globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
2000000c:	482c      	ldr	r0, [pc, #176]	; (200000c0 <CCU40_3_Veneer+0x20>)
    MOV PC,R0
2000000e:	4687      	mov	pc, r0
	...

2000002c <SVC_Veneer>:
    .long 0
    
/* ======================================================================== */
.globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
2000002c:	4825      	ldr	r0, [pc, #148]	; (200000c4 <CCU40_3_Veneer+0x24>)
    MOV PC,R0
2000002e:	4687      	mov	pc, r0
	...

20000038 <PendSV_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
.globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
20000038:	4823      	ldr	r0, [pc, #140]	; (200000c8 <CCU40_3_Veneer+0x28>)
    MOV PC,R0
2000003a:	4687      	mov	pc, r0

2000003c <SysTick_Veneer>:
/* ======================================================================== */
.globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
2000003c:	4823      	ldr	r0, [pc, #140]	; (200000cc <CCU40_3_Veneer+0x2c>)
    MOV PC,R0
2000003e:	4687      	mov	pc, r0

20000040 <SCU_0_Veneer>:
/* ======================================================================== */
.globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
20000040:	4823      	ldr	r0, [pc, #140]	; (200000d0 <CCU40_3_Veneer+0x30>)
    MOV PC,R0
20000042:	4687      	mov	pc, r0

20000044 <SCU_1_Veneer>:
/* ======================================================================== */
.globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
20000044:	4823      	ldr	r0, [pc, #140]	; (200000d4 <CCU40_3_Veneer+0x34>)
    MOV PC,R0
20000046:	4687      	mov	pc, r0

20000048 <SCU_2_Veneer>:
/* ======================================================================== */
.globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
20000048:	4823      	ldr	r0, [pc, #140]	; (200000d8 <CCU40_3_Veneer+0x38>)
    MOV PC,R0
2000004a:	4687      	mov	pc, r0

2000004c <SCU_3_Veneer>:
/* ======================================================================== */
.globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
2000004c:	4823      	ldr	r0, [pc, #140]	; (200000dc <CCU40_3_Veneer+0x3c>)
    MOV PC,R0
2000004e:	4687      	mov	pc, r0

20000050 <SCU_4_Veneer>:
/* ======================================================================== */
.globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
20000050:	4823      	ldr	r0, [pc, #140]	; (200000e0 <CCU40_3_Veneer+0x40>)
    MOV PC,R0
20000052:	4687      	mov	pc, r0

20000054 <SCU_5_Veneer>:
/* ======================================================================== */
.globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
20000054:	4823      	ldr	r0, [pc, #140]	; (200000e4 <CCU40_3_Veneer+0x44>)
    MOV PC,R0
20000056:	4687      	mov	pc, r0

20000058 <SCU_6_Veneer>:
/* ======================================================================== */
.globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
20000058:	4823      	ldr	r0, [pc, #140]	; (200000e8 <CCU40_3_Veneer+0x48>)
    MOV PC,R0
2000005a:	4687      	mov	pc, r0
	...

20000064 <USIC0_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
.globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
20000064:	4821      	ldr	r0, [pc, #132]	; (200000ec <CCU40_3_Veneer+0x4c>)
    MOV PC,R0
20000066:	4687      	mov	pc, r0

20000068 <USIC0_1_Veneer>:
/* ======================================================================== */
.globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
20000068:	4821      	ldr	r0, [pc, #132]	; (200000f0 <CCU40_3_Veneer+0x50>)
    MOV PC,R0
2000006a:	4687      	mov	pc, r0

2000006c <USIC0_2_Veneer>:
/* ======================================================================== */
.globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
2000006c:	4821      	ldr	r0, [pc, #132]	; (200000f4 <CCU40_3_Veneer+0x54>)
    MOV PC,R0
2000006e:	4687      	mov	pc, r0

20000070 <USIC0_3_Veneer>:
/* ======================================================================== */
.globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
20000070:	4821      	ldr	r0, [pc, #132]	; (200000f8 <CCU40_3_Veneer+0x58>)
    MOV PC,R0
20000072:	4687      	mov	pc, r0

20000074 <USIC0_4_Veneer>:
/* ======================================================================== */
.globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
20000074:	4821      	ldr	r0, [pc, #132]	; (200000fc <CCU40_3_Veneer+0x5c>)
    MOV PC,R0
20000076:	4687      	mov	pc, r0

20000078 <USIC0_5_Veneer>:
/* ======================================================================== */
.globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000078:	4821      	ldr	r0, [pc, #132]	; (20000100 <CCU40_3_Veneer+0x60>)
    MOV PC,R0
2000007a:	4687      	mov	pc, r0

2000007c <VADC0_C0_0_Veneer>:
/* ======================================================================== */
.globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
2000007c:	4821      	ldr	r0, [pc, #132]	; (20000104 <CCU40_3_Veneer+0x64>)
    MOV PC,R0
2000007e:	4687      	mov	pc, r0

20000080 <VADC0_C0_1_Veneer>:
/* ======================================================================== */
.globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000080:	4821      	ldr	r0, [pc, #132]	; (20000108 <CCU40_3_Veneer+0x68>)
    MOV PC,R0
20000082:	4687      	mov	pc, r0
	...

20000094 <CCU40_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
.globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
20000094:	481d      	ldr	r0, [pc, #116]	; (2000010c <CCU40_3_Veneer+0x6c>)
    MOV PC,R0
20000096:	4687      	mov	pc, r0

20000098 <CCU40_1_Veneer>:
/* ======================================================================== */
.globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000098:	481d      	ldr	r0, [pc, #116]	; (20000110 <CCU40_3_Veneer+0x70>)
    MOV PC,R0
2000009a:	4687      	mov	pc, r0

2000009c <CCU40_2_Veneer>:
/* ======================================================================== */
.globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
2000009c:	481d      	ldr	r0, [pc, #116]	; (20000114 <CCU40_3_Veneer+0x74>)
    MOV PC,R0
2000009e:	4687      	mov	pc, r0

200000a0 <CCU40_3_Veneer>:
/* ======================================================================== */
.globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
200000a0:	481d      	ldr	r0, [pc, #116]	; (20000118 <CCU40_3_Veneer+0x78>)
    MOV PC,R0
200000a2:	4687      	mov	pc, r0
	...

/* ==================VENEERS VENEERS VENEERS VENEERS VENEERS=============== */
    .section ".XmcVeneerCode","ax",%progbits
.globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
200000c0:	100010d7 	.word	0x100010d7
    .long 0
    
/* ======================================================================== */
.globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
200000c4:	100010d9 	.word	0x100010d9
    .long 0
    .long 0
/* ======================================================================== */
.globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
200000c8:	100010db 	.word	0x100010db
    MOV PC,R0
/* ======================================================================== */
.globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
200000cc:	100010dd 	.word	0x100010dd
    MOV PC,R0
/* ======================================================================== */
.globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
200000d0:	100010df 	.word	0x100010df
    MOV PC,R0
/* ======================================================================== */
.globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
200000d4:	100010e1 	.word	0x100010e1
    MOV PC,R0
/* ======================================================================== */
.globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
200000d8:	100010e3 	.word	0x100010e3
    MOV PC,R0
/* ======================================================================== */
.globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
200000dc:	100010e5 	.word	0x100010e5
    MOV PC,R0
/* ======================================================================== */
.globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
200000e0:	100010e7 	.word	0x100010e7
    MOV PC,R0
/* ======================================================================== */
.globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
200000e4:	100010e9 	.word	0x100010e9
    MOV PC,R0
/* ======================================================================== */
.globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
200000e8:	100010eb 	.word	0x100010eb
    .long 0
    .long 0
/* ======================================================================== */
.globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
200000ec:	100010f9 	.word	0x100010f9
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
200000f0:	100010fb 	.word	0x100010fb
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
200000f4:	100010fd 	.word	0x100010fd
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
200000f8:	100010ff 	.word	0x100010ff
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
200000fc:	10001101 	.word	0x10001101
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000100:	10001103 	.word	0x10001103
    MOV PC,R0
/* ======================================================================== */
.globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
20000104:	100010ed 	.word	0x100010ed
    MOV PC,R0
/* ======================================================================== */
.globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000108:	100010ef 	.word	0x100010ef
    .long 0
    .long 0
/* ======================================================================== */
.globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
2000010c:	100010f1 	.word	0x100010f1
    MOV PC,R0
/* ======================================================================== */
.globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000110:	100010f3 	.word	0x100010f3
    MOV PC,R0
/* ======================================================================== */
.globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
20000114:	100010f5 	.word	0x100010f5
    MOV PC,R0
/* ======================================================================== */
.globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
20000118:	1000137d 	.word	0x1000137d
