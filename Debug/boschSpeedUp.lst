
boschSpeedUp.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000008f0  10001000  10001000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000010  100018f0  100018f0  000018f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .rodata       00000004  10001900  10001900  00001900  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .VENEER_Code  00000110  2000000c  10001910  0000800c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .GUARD_Band   00000004  2000011c  00000000  0000011c  2**0
                  ALLOC
  5 Stack         00000800  20000120  00000000  00000120  2**0
                  ALLOC
  6 .bss          0000001c  20000920  20000920  00010920  2**2
                  ALLOC
  7 .data         00000004  20000940  10001a20  00008940  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .debug_aranges 00000218  00000000  00000000  00008948  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0000143a  00000000  00000000  00008b60  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00000639  00000000  00000000  00009f9a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00001eba  00000000  00000000  0000a5d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  0000052c  00000000  00000000  0000c490  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00024e23  00000000  00000000  0000c9bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0000079c  00000000  00000000  000317df  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000001b0  00000000  00000000  00031f80  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .build_attributes 000001d2  00000000  00000000  00032130  2**0
                  CONTENTS, READONLY
 17 .debug_macro  00007331  00000000  00000000  00032302  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

10001000 <__Xmc1100_interrupt_vector_cortex_m>:
10001000:	20 09 00 20 19 10 00 10 d5 10 00 10 d7 10 00 10      .. ............
10001010:	00 00 00 80 00 00 00 80                             ........

10001018 <__Xmc1100_reset_cortex_m>:
__Xmc1100_reset_cortex_m:
    .fnstart

    /* C routines are likely to be called. Setup the stack now */
    /* This is already setup by BootROM,hence this step is optional */ 
    LDR R0,=__Xmc1100_stack
10001018:	4802      	ldr	r0, [pc, #8]	; (10001024 <__Xmc1100_reset_cortex_m+0xc>)
    MOV SP,R0
1000101a:	4685      	mov	sp, r0
    
    /* Launch custom pre-program loading startup procedure */
    LDR R0,=hardware_init_hook
1000101c:	4802      	ldr	r0, [pc, #8]	; (10001028 <__Xmc1100_reset_cortex_m+0x10>)
    BLX R0
1000101e:	4780      	blx	r0

    /* Branch to the program loader now */
    B       __Xmc1100_Program_Loader 
10001020:	e012      	b.n	10001048 <__Xmc1100_Program_Loader>
10001022:	0000      	.short	0x0000
__Xmc1100_reset_cortex_m:
    .fnstart

    /* C routines are likely to be called. Setup the stack now */
    /* This is already setup by BootROM,hence this step is optional */ 
    LDR R0,=__Xmc1100_stack
10001024:	20000920 	.word	0x20000920
    MOV SP,R0
    
    /* Launch custom pre-program loading startup procedure */
    LDR R0,=hardware_init_hook
10001028:	100010d1 	.word	0x100010d1

1000102c <__COPY_FLASH2RAM>:
   to C land is given */
   .section .Xmc1100.postreset,"x",%progbits
 __COPY_FLASH2RAM:
   .fnstart:
   /* Is there anything to be copied? */
   CMP R2,#0
1000102c:	2a00      	cmp	r2, #0
   BEQ SKIPCOPY
1000102e:	d00a      	beq.n	10001046 <SKIPCOPY>
   
   /* For bytecount less than 4, at least 1 word must be copied */
   CMP R2,#4
10001030:	2a04      	cmp	r2, #4
   BCS STARTCOPY
10001032:	d200      	bcs.n	10001036 <STARTCOPY>
   
   /* Byte count < 4 ; so bump it up */
   MOVS R2,#4
10001034:	2204      	movs	r2, #4

10001036 <STARTCOPY>:
STARTCOPY:
   /* 
      R2 contains byte count. Change it to word count. It is ensured in the 
      linker script that the length is always word aligned.
   */
   LSRS R2,R2,#2 /* Divide by 4 to obtain word count */
10001036:	0892      	lsrs	r2, r2, #2

10001038 <COPYLOOP>:

   /* The proverbial loop from the schooldays */
COPYLOOP:
   LDR R3,[R0]
10001038:	6803      	ldr	r3, [r0, #0]
   STR R3,[R1]
1000103a:	600b      	str	r3, [r1, #0]
   SUBS R2,#1
1000103c:	3a01      	subs	r2, #1
   BEQ SKIPCOPY
1000103e:	d002      	beq.n	10001046 <SKIPCOPY>
   ADDS R0,#4
10001040:	3004      	adds	r0, #4
   ADDS R1,#4
10001042:	3104      	adds	r1, #4
   B COPYLOOP
10001044:	e7f8      	b.n	10001038 <COPYLOOP>

10001046 <SKIPCOPY>:
    
SKIPCOPY:
   BX LR
10001046:	4770      	bx	lr

10001048 <__Xmc1100_Program_Loader>:
   .fnstart
   /* Memories are accessible now*/
   
   /* DATA COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =DataLoadAddr
10001048:	4811      	ldr	r0, [pc, #68]	; (10001090 <SKIPCLEAR+0x14>)
   LDR R1, =__Xmc1100_sData
1000104a:	4912      	ldr	r1, [pc, #72]	; (10001094 <SKIPCLEAR+0x18>)
   LDR R2, =__Xmc1100_Data_Size
1000104c:	4a12      	ldr	r2, [pc, #72]	; (10001098 <SKIPCLEAR+0x1c>)
   BL __COPY_FLASH2RAM
1000104e:	f7ff ffed 	bl	1000102c <__COPY_FLASH2RAM>

   /* RAM_CODE COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =__ram_code_load
10001052:	4812      	ldr	r0, [pc, #72]	; (1000109c <SKIPCLEAR+0x20>)
   LDR R1, =__ram_code_start
10001054:	4912      	ldr	r1, [pc, #72]	; (100010a0 <SKIPCLEAR+0x24>)
   LDR R2, =__ram_code_size
10001056:	4a13      	ldr	r2, [pc, #76]	; (100010a4 <SKIPCLEAR+0x28>)
   BL __COPY_FLASH2RAM
10001058:	f7ff ffe8 	bl	1000102c <__COPY_FLASH2RAM>

   /* VENEER COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =VeneerLoadAddr
1000105c:	4812      	ldr	r0, [pc, #72]	; (100010a8 <SKIPCLEAR+0x2c>)
   LDR R1, =VeneerStart
1000105e:	4913      	ldr	r1, [pc, #76]	; (100010ac <SKIPCLEAR+0x30>)
   LDR R2, =VeneerSize
10001060:	4a13      	ldr	r2, [pc, #76]	; (100010b0 <SKIPCLEAR+0x34>)
   BL __COPY_FLASH2RAM
10001062:	f7ff ffe3 	bl	1000102c <__COPY_FLASH2RAM>

   /* BSS CLEAR */
   LDR R0, =__Xmc1100_sBSS     /* Start of BSS */
10001066:	4813      	ldr	r0, [pc, #76]	; (100010b4 <SKIPCLEAR+0x38>)
   LDR R1, =__Xmc1100_BSS_Size /* BSS size in bytes */
10001068:	4913      	ldr	r1, [pc, #76]	; (100010b8 <SKIPCLEAR+0x3c>)

   /* Find out if there are items assigned to BSS */   
   CMP R1,#0 
1000106a:	2900      	cmp	r1, #0
   BEQ SKIPCLEAR
1000106c:	d006      	beq.n	1000107c <SKIPCLEAR>

1000106e <STARTCLEAR>:

STARTCLEAR:
   LSRS R1,R1,#2            /* BSS size in words */
1000106e:	0889      	lsrs	r1, r1, #2
   
   MOVS R2,#0
10001070:	2200      	movs	r2, #0

10001072 <CLEARLOOP>:
CLEARLOOP:
   STR R2,[R0]
10001072:	6002      	str	r2, [r0, #0]
   SUBS R1,#1
10001074:	3901      	subs	r1, #1
   BEQ SKIPCLEAR
10001076:	d001      	beq.n	1000107c <SKIPCLEAR>
   ADDS R0,#4
10001078:	3004      	adds	r0, #4
   B CLEARLOOP
1000107a:	e7fa      	b.n	10001072 <CLEARLOOP>

1000107c <SKIPCLEAR>:
    
SKIPCLEAR:

   /* Reset stack pointer before zipping off to user application, Optional */
   LDR R0,=__Xmc1100_stack 
1000107c:	480f      	ldr	r0, [pc, #60]	; (100010bc <SKIPCLEAR+0x40>)
   MOV SP,R0
1000107e:	4685      	mov	sp, r0

   /* Perform System Initialization */   
   LDR R0,=SystemInit
10001080:	480f      	ldr	r0, [pc, #60]	; (100010c0 <SKIPCLEAR+0x44>)
   BLX R0
10001082:	4780      	blx	r0

   /* Launch custom post-program loading startup procedure */
   LDR R0,=software_init_hook
10001084:	480f      	ldr	r0, [pc, #60]	; (100010c4 <SKIPCLEAR+0x48>)
   BLX R0
10001086:	4780      	blx	r0

   MOVS R0,#0
10001088:	2000      	movs	r0, #0
   MOVS R1,#0
1000108a:	2100      	movs	r1, #0
   LDR R2, =main
1000108c:	4a0e      	ldr	r2, [pc, #56]	; (100010c8 <SKIPCLEAR+0x4c>)
   MOV PC,R2
1000108e:	4697      	mov	pc, r2
   .fnstart
   /* Memories are accessible now*/
   
   /* DATA COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =DataLoadAddr
10001090:	10001a20 	.word	0x10001a20
   LDR R1, =__Xmc1100_sData
10001094:	20000940 	.word	0x20000940
   LDR R2, =__Xmc1100_Data_Size
10001098:	00000004 	.word	0x00000004
   BL __COPY_FLASH2RAM

   /* RAM_CODE COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =__ram_code_load
1000109c:	10001a24 	.word	0x10001a24
   LDR R1, =__ram_code_start
100010a0:	20000944 	.word	0x20000944
   LDR R2, =__ram_code_size
100010a4:	00000000 	.word	0x00000000
   BL __COPY_FLASH2RAM

   /* VENEER COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =VeneerLoadAddr
100010a8:	10001910 	.word	0x10001910
   LDR R1, =VeneerStart
100010ac:	2000000c 	.word	0x2000000c
   LDR R2, =VeneerSize
100010b0:	00000110 	.word	0x00000110
   BL __COPY_FLASH2RAM

   /* BSS CLEAR */
   LDR R0, =__Xmc1100_sBSS     /* Start of BSS */
100010b4:	20000920 	.word	0x20000920
   LDR R1, =__Xmc1100_BSS_Size /* BSS size in bytes */
100010b8:	0000001c 	.word	0x0000001c
   B CLEARLOOP
    
SKIPCLEAR:

   /* Reset stack pointer before zipping off to user application, Optional */
   LDR R0,=__Xmc1100_stack 
100010bc:	20000920 	.word	0x20000920
   MOV SP,R0

   /* Perform System Initialization */   
   LDR R0,=SystemInit
100010c0:	10001105 	.word	0x10001105
   BLX R0

   /* Launch custom post-program loading startup procedure */
   LDR R0,=software_init_hook
100010c4:	100010cd 	.word	0x100010cd
   BLX R0

   MOVS R0,#0
   MOVS R1,#0
   LDR R2, =main
100010c8:	100012a1 	.word	0x100012a1

100010cc <software_init_hook>:
   has not been started.
 */
     .weak software_init_hook
     .type software_init_hook, %function
software_init_hook:
     NOP
100010cc:	46c0      	nop			; (mov r8, r8)
     BX LR
100010ce:	4770      	bx	lr

100010d0 <hardware_init_hook>:
     .size software_init_hook, . - software_init_hook

     .weak hardware_init_hook
     .type hardware_init_hook, %function
hardware_init_hook:
     NOP
100010d0:	46c0      	nop			; (mov r8, r8)
     BX LR
100010d2:	4770      	bx	lr

100010d4 <NMI_Handler>:
/* Default exception Handlers - Users may override this default functionality by
   defining handlers of the same name in their C code */
    .thumb 
    .text

    Insert_ExceptionHandler NMI_Handler
100010d4:	e7fe      	b.n	100010d4 <NMI_Handler>

100010d6 <HardFault_Handler>:
/* ======================================================================== */
    Insert_ExceptionHandler HardFault_Handler
100010d6:	e7fe      	b.n	100010d6 <HardFault_Handler>

100010d8 <SVC_Handler>:
/* ======================================================================== */
    Insert_ExceptionHandler SVC_Handler
100010d8:	e7fe      	b.n	100010d8 <SVC_Handler>

100010da <PendSV_Handler>:
/* ======================================================================== */
    Insert_ExceptionHandler PendSV_Handler
100010da:	e7fe      	b.n	100010da <PendSV_Handler>

100010dc <SysTick_Handler>:
/* ======================================================================== */
    Insert_ExceptionHandler SysTick_Handler
100010dc:	e7fe      	b.n	100010dc <SysTick_Handler>

100010de <SCU_0_IRQHandler>:
/* ============= END OF EXCEPTION HANDLER DEFINITION ======================== */

/* ============= START OF INTERRUPT HANDLER DEFINITION ====================== */

/* IRQ Handlers */
    Insert_ExceptionHandler SCU_0_IRQHandler
100010de:	e7fe      	b.n	100010de <SCU_0_IRQHandler>

100010e0 <SCU_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler SCU_1_IRQHandler
100010e0:	e7fe      	b.n	100010e0 <SCU_1_IRQHandler>

100010e2 <SCU_2_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler SCU_2_IRQHandler
100010e2:	e7fe      	b.n	100010e2 <SCU_2_IRQHandler>

100010e4 <ERU0_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler ERU0_0_IRQHandler
100010e4:	e7fe      	b.n	100010e4 <ERU0_0_IRQHandler>

100010e6 <ERU0_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler ERU0_1_IRQHandler
100010e6:	e7fe      	b.n	100010e6 <ERU0_1_IRQHandler>

100010e8 <ERU0_2_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler ERU0_2_IRQHandler
100010e8:	e7fe      	b.n	100010e8 <ERU0_2_IRQHandler>

100010ea <ERU0_3_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler ERU0_3_IRQHandler
100010ea:	e7fe      	b.n	100010ea <ERU0_3_IRQHandler>

100010ec <VADC0_C0_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler VADC0_C0_0_IRQHandler
100010ec:	e7fe      	b.n	100010ec <VADC0_C0_0_IRQHandler>

100010ee <VADC0_C0_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler VADC0_C0_1_IRQHandler
100010ee:	e7fe      	b.n	100010ee <VADC0_C0_1_IRQHandler>

100010f0 <CCU40_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler CCU40_0_IRQHandler
100010f0:	e7fe      	b.n	100010f0 <CCU40_0_IRQHandler>

100010f2 <CCU40_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler CCU40_1_IRQHandler
100010f2:	e7fe      	b.n	100010f2 <CCU40_1_IRQHandler>

100010f4 <CCU40_2_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler CCU40_2_IRQHandler
100010f4:	e7fe      	b.n	100010f4 <CCU40_2_IRQHandler>

100010f6 <CCU40_3_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler CCU40_3_IRQHandler
100010f6:	e7fe      	b.n	100010f6 <CCU40_3_IRQHandler>

100010f8 <USIC0_0_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_0_IRQHandler
100010f8:	e7fe      	b.n	100010f8 <USIC0_0_IRQHandler>

100010fa <USIC0_1_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_1_IRQHandler
100010fa:	e7fe      	b.n	100010fa <USIC0_1_IRQHandler>

100010fc <USIC0_2_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_2_IRQHandler
100010fc:	e7fe      	b.n	100010fc <USIC0_2_IRQHandler>

100010fe <USIC0_3_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_3_IRQHandler
100010fe:	e7fe      	b.n	100010fe <USIC0_3_IRQHandler>

10001100 <USIC0_4_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_4_IRQHandler
10001100:	e7fe      	b.n	10001100 <USIC0_4_IRQHandler>

10001102 <USIC0_5_IRQHandler>:
/* ======================================================================== */
    Insert_ExceptionHandler USIC0_5_IRQHandler
10001102:	e7fe      	b.n	10001102 <USIC0_5_IRQHandler>

10001104 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{    
10001104:	b580      	push	{r7, lr}
10001106:	af00      	add	r7, sp, #0
   * while((SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk));
   * SCU_GENERAL->PASSWD = 0x000000C3UL; // enable bit protection
   * SystemCoreClockUpdate();
   *
   */
  SystemCoreClockUpdate();
10001108:	f000 f802 	bl	10001110 <SystemCoreClockUpdate>
}
1000110c:	46bd      	mov	sp, r7
1000110e:	bd80      	pop	{r7, pc}

10001110 <SystemCoreClockUpdate>:
  * @note   -  
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
10001110:	b580      	push	{r7, lr}
10001112:	b082      	sub	sp, #8
10001114:	af00      	add	r7, sp, #0
  uint32_t IDIV, FDIV;

  IDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
10001116:	4b11      	ldr	r3, [pc, #68]	; (1000115c <SystemCoreClockUpdate+0x4c>)
10001118:	681a      	ldr	r2, [r3, #0]
1000111a:	23ff      	movs	r3, #255	; 0xff
1000111c:	021b      	lsls	r3, r3, #8
1000111e:	4013      	ands	r3, r2
10001120:	0a1b      	lsrs	r3, r3, #8
10001122:	607b      	str	r3, [r7, #4]
  FDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_FDIV_Msk) >> SCU_CLK_CLKCR_FDIV_Pos;
10001124:	4b0d      	ldr	r3, [pc, #52]	; (1000115c <SystemCoreClockUpdate+0x4c>)
10001126:	681a      	ldr	r2, [r3, #0]
10001128:	23ff      	movs	r3, #255	; 0xff
1000112a:	4013      	ands	r3, r2
1000112c:	603b      	str	r3, [r7, #0]
  
  if(IDIV)
1000112e:	687b      	ldr	r3, [r7, #4]
10001130:	2b00      	cmp	r3, #0
10001132:	d00c      	beq.n	1000114e <SystemCoreClockUpdate+0x3e>
  {
    /* Fractional divider is enabled and used */
    SystemCoreClock = ((MCLK_MHZ << 7) / ((IDIV << 8) + FDIV)) << 1;
10001134:	687b      	ldr	r3, [r7, #4]
10001136:	021a      	lsls	r2, r3, #8
10001138:	683b      	ldr	r3, [r7, #0]
1000113a:	18d3      	adds	r3, r2, r3
1000113c:	4808      	ldr	r0, [pc, #32]	; (10001160 <SystemCoreClockUpdate+0x50>)
1000113e:	1c19      	adds	r1, r3, #0
10001140:	f000 fb26 	bl	10001790 <__aeabi_uidiv>
10001144:	1c03      	adds	r3, r0, #0
10001146:	005a      	lsls	r2, r3, #1
10001148:	4b06      	ldr	r3, [pc, #24]	; (10001164 <SystemCoreClockUpdate+0x54>)
1000114a:	601a      	str	r2, [r3, #0]
1000114c:	e002      	b.n	10001154 <SystemCoreClockUpdate+0x44>
  }
  else
  {
    /* Fractional divider bypassed. Simply divide DCO_DCLK by 2 */
    SystemCoreClock = MCLK_MHZ;
1000114e:	4b05      	ldr	r3, [pc, #20]	; (10001164 <SystemCoreClockUpdate+0x54>)
10001150:	4a05      	ldr	r2, [pc, #20]	; (10001168 <SystemCoreClockUpdate+0x58>)
10001152:	601a      	str	r2, [r3, #0]
  }
}
10001154:	46bd      	mov	sp, r7
10001156:	b002      	add	sp, #8
10001158:	bd80      	pop	{r7, pc}
1000115a:	46c0      	nop			; (mov r8, r8)
1000115c:	40010300 	.word	0x40010300
10001160:	f4240000 	.word	0xf4240000
10001164:	20000938 	.word	0x20000938
10001168:	01e84800 	.word	0x01e84800

1000116c <P0_5_set_mode>:

__STATIC_INLINE void P0_4_disable_pps(void){
    PORT0->PPS &= ~0x00000010UL;
}

__STATIC_INLINE void P0_5_set_mode(uint8_t mode){
1000116c:	b580      	push	{r7, lr}
1000116e:	b082      	sub	sp, #8
10001170:	af00      	add	r7, sp, #0
10001172:	1c02      	adds	r2, r0, #0
10001174:	1dfb      	adds	r3, r7, #7
10001176:	701a      	strb	r2, [r3, #0]
    PORT0->IOCR4 &= ~0x0000f800UL;
10001178:	4b08      	ldr	r3, [pc, #32]	; (1000119c <P0_5_set_mode+0x30>)
1000117a:	4a08      	ldr	r2, [pc, #32]	; (1000119c <P0_5_set_mode+0x30>)
1000117c:	6951      	ldr	r1, [r2, #20]
1000117e:	4a08      	ldr	r2, [pc, #32]	; (100011a0 <P0_5_set_mode+0x34>)
10001180:	400a      	ands	r2, r1
10001182:	615a      	str	r2, [r3, #20]
    PORT0->IOCR4 |= mode << 8;
10001184:	4b05      	ldr	r3, [pc, #20]	; (1000119c <P0_5_set_mode+0x30>)
10001186:	4a05      	ldr	r2, [pc, #20]	; (1000119c <P0_5_set_mode+0x30>)
10001188:	6951      	ldr	r1, [r2, #20]
1000118a:	1dfa      	adds	r2, r7, #7
1000118c:	7812      	ldrb	r2, [r2, #0]
1000118e:	0212      	lsls	r2, r2, #8
10001190:	430a      	orrs	r2, r1
10001192:	615a      	str	r2, [r3, #20]
}
10001194:	46bd      	mov	sp, r7
10001196:	b002      	add	sp, #8
10001198:	bd80      	pop	{r7, pc}
1000119a:	46c0      	nop			; (mov r8, r8)
1000119c:	40040000 	.word	0x40040000
100011a0:	ffff07ff 	.word	0xffff07ff

100011a4 <P0_5_set>:

__STATIC_INLINE void P0_5_set_large_hysteresis(){
    PORT0->PHCR0 |= 0x00400000UL;
}

__STATIC_INLINE void P0_5_set(void){
100011a4:	b580      	push	{r7, lr}
100011a6:	af00      	add	r7, sp, #0
    PORT0->OMR = 0x00000020UL;
100011a8:	4b02      	ldr	r3, [pc, #8]	; (100011b4 <P0_5_set+0x10>)
100011aa:	2220      	movs	r2, #32
100011ac:	605a      	str	r2, [r3, #4]
}
100011ae:	46bd      	mov	sp, r7
100011b0:	bd80      	pop	{r7, pc}
100011b2:	46c0      	nop			; (mov r8, r8)
100011b4:	40040000 	.word	0x40040000

100011b8 <P0_5_toggle>:

__STATIC_INLINE void P0_5_reset(void){
    PORT0->OMR = 0x00200000UL;
}

__STATIC_INLINE void P0_5_toggle(void){
100011b8:	b580      	push	{r7, lr}
100011ba:	af00      	add	r7, sp, #0
    PORT0->OMR = 0x00200020UL;
100011bc:	4b02      	ldr	r3, [pc, #8]	; (100011c8 <P0_5_toggle+0x10>)
100011be:	4a03      	ldr	r2, [pc, #12]	; (100011cc <P0_5_toggle+0x14>)
100011c0:	605a      	str	r2, [r3, #4]
}
100011c2:	46bd      	mov	sp, r7
100011c4:	bd80      	pop	{r7, pc}
100011c6:	46c0      	nop			; (mov r8, r8)
100011c8:	40040000 	.word	0x40040000
100011cc:	00200020 	.word	0x00200020

100011d0 <P0_6_set_mode>:

__STATIC_INLINE void P0_5_disable_pps(void){
    PORT0->PPS &= ~0x00000020UL;
}

__STATIC_INLINE void P0_6_set_mode(uint8_t mode){
100011d0:	b580      	push	{r7, lr}
100011d2:	b082      	sub	sp, #8
100011d4:	af00      	add	r7, sp, #0
100011d6:	1c02      	adds	r2, r0, #0
100011d8:	1dfb      	adds	r3, r7, #7
100011da:	701a      	strb	r2, [r3, #0]
    PORT0->IOCR4 &= ~0x00f80000UL;
100011dc:	4b08      	ldr	r3, [pc, #32]	; (10001200 <P0_6_set_mode+0x30>)
100011de:	4a08      	ldr	r2, [pc, #32]	; (10001200 <P0_6_set_mode+0x30>)
100011e0:	6951      	ldr	r1, [r2, #20]
100011e2:	4a08      	ldr	r2, [pc, #32]	; (10001204 <P0_6_set_mode+0x34>)
100011e4:	400a      	ands	r2, r1
100011e6:	615a      	str	r2, [r3, #20]
    PORT0->IOCR4 |= mode << 16;
100011e8:	4b05      	ldr	r3, [pc, #20]	; (10001200 <P0_6_set_mode+0x30>)
100011ea:	4a05      	ldr	r2, [pc, #20]	; (10001200 <P0_6_set_mode+0x30>)
100011ec:	6951      	ldr	r1, [r2, #20]
100011ee:	1dfa      	adds	r2, r7, #7
100011f0:	7812      	ldrb	r2, [r2, #0]
100011f2:	0412      	lsls	r2, r2, #16
100011f4:	430a      	orrs	r2, r1
100011f6:	615a      	str	r2, [r3, #20]
}
100011f8:	46bd      	mov	sp, r7
100011fa:	b002      	add	sp, #8
100011fc:	bd80      	pop	{r7, pc}
100011fe:	46c0      	nop			; (mov r8, r8)
10001200:	40040000 	.word	0x40040000
10001204:	ff07ffff 	.word	0xff07ffff

10001208 <P0_6_set_large_hysteresis>:

__STATIC_INLINE void P0_6_set_standard_hysteresis(){
    PORT0->PHCR0 &= ~0x04000000UL;
}

__STATIC_INLINE void P0_6_set_large_hysteresis(){
10001208:	b580      	push	{r7, lr}
1000120a:	af00      	add	r7, sp, #0
    PORT0->PHCR0 |= 0x04000000UL;
1000120c:	4b04      	ldr	r3, [pc, #16]	; (10001220 <P0_6_set_large_hysteresis+0x18>)
1000120e:	4a04      	ldr	r2, [pc, #16]	; (10001220 <P0_6_set_large_hysteresis+0x18>)
10001210:	6c12      	ldr	r2, [r2, #64]	; 0x40
10001212:	2180      	movs	r1, #128	; 0x80
10001214:	04c9      	lsls	r1, r1, #19
10001216:	430a      	orrs	r2, r1
10001218:	641a      	str	r2, [r3, #64]	; 0x40
}
1000121a:	46bd      	mov	sp, r7
1000121c:	bd80      	pop	{r7, pc}
1000121e:	46c0      	nop			; (mov r8, r8)
10001220:	40040000 	.word	0x40040000

10001224 <P0_6_read>:

__STATIC_INLINE void P0_6_toggle(void){
    PORT0->OMR = 0x00400040UL;
}

__STATIC_INLINE uint32_t P0_6_read(void){
10001224:	b580      	push	{r7, lr}
10001226:	af00      	add	r7, sp, #0
    return(PORT0->IN & 0x00000040UL);
10001228:	4b03      	ldr	r3, [pc, #12]	; (10001238 <P0_6_read+0x14>)
1000122a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
1000122c:	2340      	movs	r3, #64	; 0x40
1000122e:	4013      	ands	r3, r2
}
10001230:	1c18      	adds	r0, r3, #0
10001232:	46bd      	mov	sp, r7
10001234:	bd80      	pop	{r7, pc}
10001236:	46c0      	nop			; (mov r8, r8)
10001238:	40040000 	.word	0x40040000

1000123c <P1_4_set_mode>:

__STATIC_INLINE void P1_3_disable_pps(void){
    PORT1->PPS &= ~0x00000008UL;
}

__STATIC_INLINE void P1_4_set_mode(uint8_t mode){
1000123c:	b580      	push	{r7, lr}
1000123e:	b082      	sub	sp, #8
10001240:	af00      	add	r7, sp, #0
10001242:	1c02      	adds	r2, r0, #0
10001244:	1dfb      	adds	r3, r7, #7
10001246:	701a      	strb	r2, [r3, #0]
    PORT1->IOCR4 &= ~0x000000f8UL;
10001248:	4b07      	ldr	r3, [pc, #28]	; (10001268 <P1_4_set_mode+0x2c>)
1000124a:	4a07      	ldr	r2, [pc, #28]	; (10001268 <P1_4_set_mode+0x2c>)
1000124c:	6952      	ldr	r2, [r2, #20]
1000124e:	21f8      	movs	r1, #248	; 0xf8
10001250:	438a      	bics	r2, r1
10001252:	615a      	str	r2, [r3, #20]
    PORT1->IOCR4 |= mode << 0;
10001254:	4b04      	ldr	r3, [pc, #16]	; (10001268 <P1_4_set_mode+0x2c>)
10001256:	4a04      	ldr	r2, [pc, #16]	; (10001268 <P1_4_set_mode+0x2c>)
10001258:	6951      	ldr	r1, [r2, #20]
1000125a:	1dfa      	adds	r2, r7, #7
1000125c:	7812      	ldrb	r2, [r2, #0]
1000125e:	430a      	orrs	r2, r1
10001260:	615a      	str	r2, [r3, #20]
}
10001262:	46bd      	mov	sp, r7
10001264:	b002      	add	sp, #8
10001266:	bd80      	pop	{r7, pc}
10001268:	40040100 	.word	0x40040100

1000126c <P1_4_set_large_hysteresis>:

__STATIC_INLINE void P1_4_set_standard_hysteresis(){
    PORT1->PHCR0 &= ~0x00040000UL;
}

__STATIC_INLINE void P1_4_set_large_hysteresis(){
1000126c:	b580      	push	{r7, lr}
1000126e:	af00      	add	r7, sp, #0
    PORT1->PHCR0 |= 0x00040000UL;
10001270:	4b04      	ldr	r3, [pc, #16]	; (10001284 <P1_4_set_large_hysteresis+0x18>)
10001272:	4a04      	ldr	r2, [pc, #16]	; (10001284 <P1_4_set_large_hysteresis+0x18>)
10001274:	6c12      	ldr	r2, [r2, #64]	; 0x40
10001276:	2180      	movs	r1, #128	; 0x80
10001278:	02c9      	lsls	r1, r1, #11
1000127a:	430a      	orrs	r2, r1
1000127c:	641a      	str	r2, [r3, #64]	; 0x40
}
1000127e:	46bd      	mov	sp, r7
10001280:	bd80      	pop	{r7, pc}
10001282:	46c0      	nop			; (mov r8, r8)
10001284:	40040100 	.word	0x40040100

10001288 <P1_4_read>:

__STATIC_INLINE void P1_4_toggle(void){
    PORT1->OMR = 0x00100010UL;
}

__STATIC_INLINE uint32_t P1_4_read(void){
10001288:	b580      	push	{r7, lr}
1000128a:	af00      	add	r7, sp, #0
    return(PORT1->IN & 0x00000010UL);
1000128c:	4b03      	ldr	r3, [pc, #12]	; (1000129c <P1_4_read+0x14>)
1000128e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
10001290:	2310      	movs	r3, #16
10001292:	4013      	ands	r3, r2
}
10001294:	1c18      	adds	r0, r3, #0
10001296:	46bd      	mov	sp, r7
10001298:	bd80      	pop	{r7, pc}
1000129a:	46c0      	nop			; (mov r8, r8)
1000129c:	40040100 	.word	0x40040100

100012a0 <main>:




int main(void)
{
100012a0:	b580      	push	{r7, lr}
100012a2:	b08a      	sub	sp, #40	; 0x28
100012a4:	af00      	add	r7, sp, #0
	//status_t status;		// Declaration of return variable for DAVE3 APIs


	DAVE_Init();			// Initialization of DAVE Apps
100012a6:	f000 fa61 	bl	1000176c <DAVE_Init>
	if(status != DAVEApp_SUCCESS)
	{
		PWMSP001_Stop((PWMSP001_HandleType*)&PWMSP001_Handle0);
	}*/

	PIN_LOW_INIT();
100012aa:	20c0      	movs	r0, #192	; 0xc0
100012ac:	f7ff ff5e 	bl	1000116c <P0_5_set_mode>
100012b0:	f7ff ff78 	bl	100011a4 <P0_5_set>
	PIN_IS_INIT();
100012b4:	2010      	movs	r0, #16
100012b6:	f7ff ff8b 	bl	100011d0 <P0_6_set_mode>
100012ba:	f7ff ffa5 	bl	10001208 <P0_6_set_large_hysteresis>
100012be:	f7ff ffb1 	bl	10001224 <P0_6_read>
	PIN_SW_INIT();
100012c2:	2010      	movs	r0, #16
100012c4:	f7ff ffba 	bl	1000123c <P1_4_set_mode>
100012c8:	f7ff ffd0 	bl	1000126c <P1_4_set_large_hysteresis>
100012cc:	f7ff ffdc 	bl	10001288 <P1_4_read>

	bool lastPinState = PIN_IS_HIGH();
100012d0:	f7ff ffa8 	bl	10001224 <P0_6_read>
100012d4:	1c02      	adds	r2, r0, #0
100012d6:	1c3b      	adds	r3, r7, #0
100012d8:	3327      	adds	r3, #39	; 0x27
100012da:	701a      	strb	r2, [r3, #0]
	bool trigger = FALSE;
100012dc:	1c3b      	adds	r3, r7, #0
100012de:	3326      	adds	r3, #38	; 0x26
100012e0:	2200      	movs	r2, #0
100012e2:	701a      	strb	r2, [r3, #0]
	int noTriggerCnt=0;
100012e4:	2300      	movs	r3, #0
100012e6:	623b      	str	r3, [r7, #32]
	int speed=0;
100012e8:	2300      	movs	r3, #0
100012ea:	61fb      	str	r3, [r7, #28]
	int speedLow=0;
100012ec:	2300      	movs	r3, #0
100012ee:	61bb      	str	r3, [r7, #24]
	int speedLowHigh=0;
100012f0:	2300      	movs	r3, #0
100012f2:	617b      	str	r3, [r7, #20]

	int pinCheckCycles = 100;
100012f4:	2364      	movs	r3, #100	; 0x64
100012f6:	607b      	str	r3, [r7, #4]
100012f8:	e000      	b.n	100012fc <main+0x5c>
			{
				PIN_LOW_TOGGLE();
			}
		}

	}
100012fa:	46c0      	nop			; (mov r8, r8)



	while(1)
	{
		speed++;
100012fc:	69fb      	ldr	r3, [r7, #28]
100012fe:	3301      	adds	r3, #1
10001300:	61fb      	str	r3, [r7, #28]
		speedLow++;
10001302:	69bb      	ldr	r3, [r7, #24]
10001304:	3301      	adds	r3, #1
10001306:	61bb      	str	r3, [r7, #24]
		

		int cnt_high=0;
10001308:	2300      	movs	r3, #0
1000130a:	613b      	str	r3, [r7, #16]
		int cnt_low=0;
1000130c:	2300      	movs	r3, #0
1000130e:	60fb      	str	r3, [r7, #12]
		for (int i = 0; i < pinCheckCycles; i++)
10001310:	2300      	movs	r3, #0
10001312:	60bb      	str	r3, [r7, #8]
10001314:	e00e      	b.n	10001334 <main+0x94>
		{
			if (PIN_IS_HIGH())
10001316:	f7ff ff85 	bl	10001224 <P0_6_read>
1000131a:	1c03      	adds	r3, r0, #0
1000131c:	2b00      	cmp	r3, #0
1000131e:	d003      	beq.n	10001328 <main+0x88>
				cnt_high++;
10001320:	693b      	ldr	r3, [r7, #16]
10001322:	3301      	adds	r3, #1
10001324:	613b      	str	r3, [r7, #16]
10001326:	e002      	b.n	1000132e <main+0x8e>
			else
				cnt_low++;
10001328:	68fb      	ldr	r3, [r7, #12]
1000132a:	3301      	adds	r3, #1
1000132c:	60fb      	str	r3, [r7, #12]
		speedLow++;
		

		int cnt_high=0;
		int cnt_low=0;
		for (int i = 0; i < pinCheckCycles; i++)
1000132e:	68bb      	ldr	r3, [r7, #8]
10001330:	3301      	adds	r3, #1
10001332:	60bb      	str	r3, [r7, #8]
10001334:	68ba      	ldr	r2, [r7, #8]
10001336:	687b      	ldr	r3, [r7, #4]
10001338:	429a      	cmp	r2, r3
1000133a:	dbec      	blt.n	10001316 <main+0x76>
			else
				cnt_low++;
		}
		
		
		if (cnt_low > 0)
1000133c:	68fb      	ldr	r3, [r7, #12]
1000133e:	2b00      	cmp	r3, #0
10001340:	dd20      	ble.n	10001384 <main+0xe4>
		{
			if (lastPinState)
10001342:	1c3b      	adds	r3, r7, #0
10001344:	3327      	adds	r3, #39	; 0x27
10001346:	781b      	ldrb	r3, [r3, #0]
10001348:	2b00      	cmp	r3, #0
1000134a:	d016      	beq.n	1000137a <main+0xda>
			{
				trigger = TRUE;
1000134c:	1c3b      	adds	r3, r7, #0
1000134e:	3326      	adds	r3, #38	; 0x26
10001350:	2201      	movs	r2, #1
10001352:	701a      	strb	r2, [r3, #0]
				if (PIN_SW_HIGH())
10001354:	f7ff ff98 	bl	10001288 <P1_4_read>
10001358:	1c03      	adds	r3, r0, #0
1000135a:	2b00      	cmp	r3, #0
1000135c:	d008      	beq.n	10001370 <main+0xd0>
				{
					speedLowHigh =  (speed<<3)/10; // *16/10/2
1000135e:	69fb      	ldr	r3, [r7, #28]
10001360:	00db      	lsls	r3, r3, #3
10001362:	1c18      	adds	r0, r3, #0
10001364:	210a      	movs	r1, #10
10001366:	f000 fa61 	bl	1000182c <__aeabi_idiv>
1000136a:	1c03      	adds	r3, r0, #0
1000136c:	617b      	str	r3, [r7, #20]
1000136e:	e002      	b.n	10001376 <main+0xd6>
				}
				else
				{
					speedLowHigh =  speed>>1; // /2
10001370:	69fb      	ldr	r3, [r7, #28]
10001372:	105b      	asrs	r3, r3, #1
10001374:	617b      	str	r3, [r7, #20]
				debugSpeedBuffer[debugCount%DEBUG_CNT_BUFFER_SIZE] = speed;
				debugCount++;
				debugSpeedBuffer[debugCount%DEBUG_CNT_BUFFER_SIZE] = speedLowHigh;
				debugCount++;
#endif
				speed=0;
10001376:	2300      	movs	r3, #0
10001378:	61fb      	str	r3, [r7, #28]

			}
			lastPinState = FALSE;
1000137a:	1c3b      	adds	r3, r7, #0
1000137c:	3327      	adds	r3, #39	; 0x27
1000137e:	2200      	movs	r2, #0
10001380:	701a      	strb	r2, [r3, #0]
10001382:	e006      	b.n	10001392 <main+0xf2>
		}
		else if (cnt_high > 0)
10001384:	693b      	ldr	r3, [r7, #16]
10001386:	2b00      	cmp	r3, #0
10001388:	dd03      	ble.n	10001392 <main+0xf2>
		{
			lastPinState = TRUE;
1000138a:	1c3b      	adds	r3, r7, #0
1000138c:	3327      	adds	r3, #39	; 0x27
1000138e:	2201      	movs	r2, #1
10001390:	701a      	strb	r2, [r3, #0]
		}
		
		if (speedLow >= speedLowHigh)
10001392:	69ba      	ldr	r2, [r7, #24]
10001394:	697b      	ldr	r3, [r7, #20]
10001396:	429a      	cmp	r2, r3
10001398:	dbaf      	blt.n	100012fa <main+0x5a>
		{
			speedLow = 0;
1000139a:	2300      	movs	r3, #0
1000139c:	61bb      	str	r3, [r7, #24]
			
			if (!trigger)
1000139e:	1c3b      	adds	r3, r7, #0
100013a0:	3326      	adds	r3, #38	; 0x26
100013a2:	781b      	ldrb	r3, [r3, #0]
100013a4:	2b00      	cmp	r3, #0
100013a6:	d103      	bne.n	100013b0 <main+0x110>
				noTriggerCnt++;
100013a8:	6a3b      	ldr	r3, [r7, #32]
100013aa:	3301      	adds	r3, #1
100013ac:	623b      	str	r3, [r7, #32]
100013ae:	e001      	b.n	100013b4 <main+0x114>
			else
				noTriggerCnt=0;
100013b0:	2300      	movs	r3, #0
100013b2:	623b      	str	r3, [r7, #32]
			trigger = FALSE;
100013b4:	1c3b      	adds	r3, r7, #0
100013b6:	3326      	adds	r3, #38	; 0x26
100013b8:	2200      	movs	r2, #0
100013ba:	701a      	strb	r2, [r3, #0]
			
			if (noTriggerCnt > 1)
100013bc:	6a3b      	ldr	r3, [r7, #32]
100013be:	2b01      	cmp	r3, #1
100013c0:	dd04      	ble.n	100013cc <main+0x12c>
			{
				noTriggerCnt=1;
100013c2:	2301      	movs	r3, #1
100013c4:	623b      	str	r3, [r7, #32]
				PIN_LOW_DEASSERT();
100013c6:	f7ff feed 	bl	100011a4 <P0_5_set>
			{
				PIN_LOW_TOGGLE();
			}
		}

	}
100013ca:	e796      	b.n	100012fa <main+0x5a>
				noTriggerCnt=1;
				PIN_LOW_DEASSERT();
			}
			else
			{
				PIN_LOW_TOGGLE();
100013cc:	f7ff fef4 	bl	100011b8 <P0_5_toggle>
			}
		}

	}
100013d0:	e793      	b.n	100012fa <main+0x5a>
100013d2:	46c0      	nop			; (mov r8, r8)

100013d4 <IRQ_Hdlr_26>:

/*
 * PWM_Period_Interrupt handler: executes every period match of PWMSP001/0.
 */
void PWM_Period_Interrupt(void)
{
100013d4:	b580      	push	{r7, lr}
100013d6:	af00      	add	r7, sp, #0
#define MAXFREQ 7
	static uint32_t state = 0;
	static uint32_t cycles = 0;
	static status_t status = DAVEApp_SUCCESS;
	/* state machine to change the different duty cycle */
	if (cycles == 0)
100013d8:	4b0f      	ldr	r3, [pc, #60]	; (10001418 <IRQ_Hdlr_26+0x44>)
100013da:	681b      	ldr	r3, [r3, #0]
100013dc:	2b00      	cmp	r3, #0
100013de:	d113      	bne.n	10001408 <IRQ_Hdlr_26+0x34>
	{
		cycles = (state%MAXFREQ) + 1;
100013e0:	4b0e      	ldr	r3, [pc, #56]	; (1000141c <IRQ_Hdlr_26+0x48>)
100013e2:	681b      	ldr	r3, [r3, #0]
100013e4:	1c18      	adds	r0, r3, #0
100013e6:	2107      	movs	r1, #7
100013e8:	f000 fa16 	bl	10001818 <__aeabi_uidivmod>
100013ec:	1c0b      	adds	r3, r1, #0
100013ee:	1c5a      	adds	r2, r3, #1
100013f0:	4b09      	ldr	r3, [pc, #36]	; (10001418 <IRQ_Hdlr_26+0x44>)
100013f2:	601a      	str	r2, [r3, #0]
		//status = PWMSP001_SetPwmFreqAndDutyCycle((PWMSP001_HandleType*)&PWMSP001_Handle0, cycles, 50);
		cycles = cycles<<2;
100013f4:	4b08      	ldr	r3, [pc, #32]	; (10001418 <IRQ_Hdlr_26+0x44>)
100013f6:	681b      	ldr	r3, [r3, #0]
100013f8:	009a      	lsls	r2, r3, #2
100013fa:	4b07      	ldr	r3, [pc, #28]	; (10001418 <IRQ_Hdlr_26+0x44>)
100013fc:	601a      	str	r2, [r3, #0]

		state++;
100013fe:	4b07      	ldr	r3, [pc, #28]	; (1000141c <IRQ_Hdlr_26+0x48>)
10001400:	681b      	ldr	r3, [r3, #0]
10001402:	1c5a      	adds	r2, r3, #1
10001404:	4b05      	ldr	r3, [pc, #20]	; (1000141c <IRQ_Hdlr_26+0x48>)
10001406:	601a      	str	r2, [r3, #0]
		if(status != DAVEApp_SUCCESS)
		{
			//PWMSP001_Stop((PWMSP001_HandleType*)&PWMSP001_Handle0);
		}
	}
	cycles--;
10001408:	4b03      	ldr	r3, [pc, #12]	; (10001418 <IRQ_Hdlr_26+0x44>)
1000140a:	681b      	ldr	r3, [r3, #0]
1000140c:	1e5a      	subs	r2, r3, #1
1000140e:	4b02      	ldr	r3, [pc, #8]	; (10001418 <IRQ_Hdlr_26+0x44>)
10001410:	601a      	str	r2, [r3, #0]
}
10001412:	46bd      	mov	sp, r7
10001414:	bd80      	pop	{r7, pc}
10001416:	46c0      	nop			; (mov r8, r8)
10001418:	20000920 	.word	0x20000920
1000141c:	20000924 	.word	0x20000924

10001420 <_open>:
/* ========================================================================= */
/*
 * File open
 */
__attribute__((weak)) int _open(const char *name, int flags, int mode)
{
10001420:	b580      	push	{r7, lr}
10001422:	b084      	sub	sp, #16
10001424:	af00      	add	r7, sp, #0
10001426:	60f8      	str	r0, [r7, #12]
10001428:	60b9      	str	r1, [r7, #8]
1000142a:	607a      	str	r2, [r7, #4]
 flags = flags;
 mode = mode;
 return -1;
1000142c:	2301      	movs	r3, #1
1000142e:	425b      	negs	r3, r3
}
10001430:	1c18      	adds	r0, r3, #0
10001432:	46bd      	mov	sp, r7
10001434:	b004      	add	sp, #16
10001436:	bd80      	pop	{r7, pc}

10001438 <_lseek>:

/*
 * File position seek
 */
__attribute__((weak)) int _lseek(int file, int offset, int whence)
{
10001438:	b580      	push	{r7, lr}
1000143a:	b084      	sub	sp, #16
1000143c:	af00      	add	r7, sp, #0
1000143e:	60f8      	str	r0, [r7, #12]
10001440:	60b9      	str	r1, [r7, #8]
10001442:	607a      	str	r2, [r7, #4]
 file = file;
 offset = offset;
 whence = whence;
 return -1;
10001444:	2301      	movs	r3, #1
10001446:	425b      	negs	r3, r3
}
10001448:	1c18      	adds	r0, r3, #0
1000144a:	46bd      	mov	sp, r7
1000144c:	b004      	add	sp, #16
1000144e:	bd80      	pop	{r7, pc}

10001450 <_read>:

/*
 * File read
 */
__attribute__((weak)) int _read(int file, char *ptr, int len)
{
10001450:	b580      	push	{r7, lr}
10001452:	b084      	sub	sp, #16
10001454:	af00      	add	r7, sp, #0
10001456:	60f8      	str	r0, [r7, #12]
10001458:	60b9      	str	r1, [r7, #8]
1000145a:	607a      	str	r2, [r7, #4]
 file = file;
 len  = len;
 return 0;
1000145c:	2300      	movs	r3, #0
}
1000145e:	1c18      	adds	r0, r3, #0
10001460:	46bd      	mov	sp, r7
10001462:	b004      	add	sp, #16
10001464:	bd80      	pop	{r7, pc}
10001466:	46c0      	nop			; (mov r8, r8)

10001468 <_write>:

/*
 * File write
 */
__attribute__((weak)) int _write(int file, char *buf, int nbytes)
{
10001468:	b580      	push	{r7, lr}
1000146a:	b084      	sub	sp, #16
1000146c:	af00      	add	r7, sp, #0
1000146e:	60f8      	str	r0, [r7, #12]
10001470:	60b9      	str	r1, [r7, #8]
10001472:	607a      	str	r2, [r7, #4]
 return -1;
10001474:	2301      	movs	r3, #1
10001476:	425b      	negs	r3, r3
}
10001478:	1c18      	adds	r0, r3, #0
1000147a:	46bd      	mov	sp, r7
1000147c:	b004      	add	sp, #16
1000147e:	bd80      	pop	{r7, pc}

10001480 <_close>:

/*
 * File close
 */
__attribute__((weak)) int _close(void)
{
10001480:	b580      	push	{r7, lr}
10001482:	af00      	add	r7, sp, #0
 return -1;
10001484:	2301      	movs	r3, #1
10001486:	425b      	negs	r3, r3
}
10001488:	1c18      	adds	r0, r3, #0
1000148a:	46bd      	mov	sp, r7
1000148c:	bd80      	pop	{r7, pc}
1000148e:	46c0      	nop			; (mov r8, r8)

10001490 <_fstat>:

/*
 * File status
 */
__attribute__((weak)) int _fstat(int file, struct stat *st)
{
10001490:	b580      	push	{r7, lr}
10001492:	b082      	sub	sp, #8
10001494:	af00      	add	r7, sp, #0
10001496:	6078      	str	r0, [r7, #4]
10001498:	6039      	str	r1, [r7, #0]
 file = file;
 if(st)
1000149a:	683b      	ldr	r3, [r7, #0]
1000149c:	2b00      	cmp	r3, #0
1000149e:	d002      	beq.n	100014a6 <_fstat+0x16>
  return -1;
100014a0:	2301      	movs	r3, #1
100014a2:	425b      	negs	r3, r3
100014a4:	e001      	b.n	100014aa <_fstat+0x1a>
 else
  return -2;
100014a6:	2302      	movs	r3, #2
100014a8:	425b      	negs	r3, r3
}
100014aa:	1c18      	adds	r0, r3, #0
100014ac:	46bd      	mov	sp, r7
100014ae:	b002      	add	sp, #8
100014b0:	bd80      	pop	{r7, pc}
100014b2:	46c0      	nop			; (mov r8, r8)

100014b4 <_link>:
/*
 * File linking
 */
__attribute__((weak)) int _link (char *old, char *new)
{
100014b4:	b580      	push	{r7, lr}
100014b6:	b082      	sub	sp, #8
100014b8:	af00      	add	r7, sp, #0
100014ba:	6078      	str	r0, [r7, #4]
100014bc:	6039      	str	r1, [r7, #0]
 if (old == new)
100014be:	687a      	ldr	r2, [r7, #4]
100014c0:	683b      	ldr	r3, [r7, #0]
100014c2:	429a      	cmp	r2, r3
100014c4:	d102      	bne.n	100014cc <_link+0x18>
  return -1;
100014c6:	2301      	movs	r3, #1
100014c8:	425b      	negs	r3, r3
100014ca:	e001      	b.n	100014d0 <_link+0x1c>
 else
  return -2;
100014cc:	2302      	movs	r3, #2
100014ce:	425b      	negs	r3, r3
}
100014d0:	1c18      	adds	r0, r3, #0
100014d2:	46bd      	mov	sp, r7
100014d4:	b002      	add	sp, #8
100014d6:	bd80      	pop	{r7, pc}

100014d8 <_unlink>:

/*
 * Unlinking directory entry
 */
__attribute__((weak)) int _unlink(char *name)
{
100014d8:	b580      	push	{r7, lr}
100014da:	b082      	sub	sp, #8
100014dc:	af00      	add	r7, sp, #0
100014de:	6078      	str	r0, [r7, #4]
 return -1;
100014e0:	2301      	movs	r3, #1
100014e2:	425b      	negs	r3, r3
}
100014e4:	1c18      	adds	r0, r3, #0
100014e6:	46bd      	mov	sp, r7
100014e8:	b002      	add	sp, #8
100014ea:	bd80      	pop	{r7, pc}

100014ec <_sbrk>:
/* ========================================================================= */
/*
 * Heap break (position)
 */
__attribute__((weak)) void *_sbrk(int RequestedSize)
{
100014ec:	b580      	push	{r7, lr}
100014ee:	b086      	sub	sp, #24
100014f0:	af00      	add	r7, sp, #0
100014f2:	6078      	str	r0, [r7, #4]
 unsigned int  HeapSize;
 static unsigned char *HeapBound;
 static unsigned char * heap= (unsigned char *)NULL;


 HeapSize   = (unsigned int)(&Heap_Bank1_Size);
100014f4:	4b14      	ldr	r3, [pc, #80]	; (10001548 <_sbrk+0x5c>)
100014f6:	617b      	str	r3, [r7, #20]

 /*
  * If this is the first time malloc() was invoked, we start with the
  * begining of the heap.
  */
 if(heap == (unsigned char *)NULL)
100014f8:	4b14      	ldr	r3, [pc, #80]	; (1000154c <_sbrk+0x60>)
100014fa:	681b      	ldr	r3, [r3, #0]
100014fc:	2b00      	cmp	r3, #0
100014fe:	d108      	bne.n	10001512 <_sbrk+0x26>
  {
   heap = (unsigned char *)&Heap_Bank1_Start;
10001500:	4b12      	ldr	r3, [pc, #72]	; (1000154c <_sbrk+0x60>)
10001502:	4a13      	ldr	r2, [pc, #76]	; (10001550 <_sbrk+0x64>)
10001504:	601a      	str	r2, [r3, #0]
   HeapBound  = (unsigned char *) (heap + HeapSize);
10001506:	4b11      	ldr	r3, [pc, #68]	; (1000154c <_sbrk+0x60>)
10001508:	681a      	ldr	r2, [r3, #0]
1000150a:	697b      	ldr	r3, [r7, #20]
1000150c:	18d2      	adds	r2, r2, r3
1000150e:	4b11      	ldr	r3, [pc, #68]	; (10001554 <_sbrk+0x68>)
10001510:	601a      	str	r2, [r3, #0]
  }

 /* Super duper algo to find out if we have memory for the latest request */
 /* Given conditions are: */
 /* 1. Latest break */
 CurrBreak = heap;
10001512:	4b0e      	ldr	r3, [pc, #56]	; (1000154c <_sbrk+0x60>)
10001514:	681b      	ldr	r3, [r3, #0]
10001516:	613b      	str	r3, [r7, #16]

 /* And 2. Potential break based on requested size */
 NextBreak = (unsigned char *)( (((unsigned int)(heap)) + RequestedSize + 7)
10001518:	4b0c      	ldr	r3, [pc, #48]	; (1000154c <_sbrk+0x60>)
1000151a:	681b      	ldr	r3, [r3, #0]
1000151c:	1c1a      	adds	r2, r3, #0
1000151e:	687b      	ldr	r3, [r7, #4]
10001520:	18d3      	adds	r3, r2, r3
10001522:	3307      	adds	r3, #7
                                          & 0xFFFFFFF8);
10001524:	2207      	movs	r2, #7
10001526:	4393      	bics	r3, r2
 /* Given conditions are: */
 /* 1. Latest break */
 CurrBreak = heap;

 /* And 2. Potential break based on requested size */
 NextBreak = (unsigned char *)( (((unsigned int)(heap)) + RequestedSize + 7)
10001528:	60fb      	str	r3, [r7, #12]
                                          & 0xFFFFFFF8);

 /* Return no memory condition if we sense we are crossing the limit */
 if (NextBreak >=  HeapBound )
1000152a:	4b0a      	ldr	r3, [pc, #40]	; (10001554 <_sbrk+0x68>)
1000152c:	681b      	ldr	r3, [r3, #0]
1000152e:	68fa      	ldr	r2, [r7, #12]
10001530:	429a      	cmp	r2, r3
10001532:	d301      	bcc.n	10001538 <_sbrk+0x4c>
  return ((unsigned char *)NULL);
10001534:	2300      	movs	r3, #0
10001536:	e003      	b.n	10001540 <_sbrk+0x54>
 else
 {
  heap = NextBreak;
10001538:	4b04      	ldr	r3, [pc, #16]	; (1000154c <_sbrk+0x60>)
1000153a:	68fa      	ldr	r2, [r7, #12]
1000153c:	601a      	str	r2, [r3, #0]
  return CurrBreak;
1000153e:	693b      	ldr	r3, [r7, #16]
 }
}
10001540:	1c18      	adds	r0, r3, #0
10001542:	46bd      	mov	sp, r7
10001544:	b006      	add	sp, #24
10001546:	bd80      	pop	{r7, pc}
10001548:	000036b8 	.word	0x000036b8
1000154c:	20000930 	.word	0x20000930
10001550:	20000948 	.word	0x20000948
10001554:	20000934 	.word	0x20000934

10001558 <_times>:
/* ========================================================================= */
/*
 * Process timing information
 */
__attribute__((weak)) int _times(struct tms *buf)
{
10001558:	b580      	push	{r7, lr}
1000155a:	b082      	sub	sp, #8
1000155c:	af00      	add	r7, sp, #0
1000155e:	6078      	str	r0, [r7, #4]
 return -1;
10001560:	2301      	movs	r3, #1
10001562:	425b      	negs	r3, r3
}
10001564:	1c18      	adds	r0, r3, #0
10001566:	46bd      	mov	sp, r7
10001568:	b002      	add	sp, #8
1000156a:	bd80      	pop	{r7, pc}

1000156c <_wait>:
/*
 * Waiting for a child process to complete
 */
__attribute__((weak)) int _wait(int *status)
{
1000156c:	b580      	push	{r7, lr}
1000156e:	b082      	sub	sp, #8
10001570:	af00      	add	r7, sp, #0
10001572:	6078      	str	r0, [r7, #4]
 return -1;
10001574:	2301      	movs	r3, #1
10001576:	425b      	negs	r3, r3
}
10001578:	1c18      	adds	r0, r3, #0
1000157a:	46bd      	mov	sp, r7
1000157c:	b002      	add	sp, #8
1000157e:	bd80      	pop	{r7, pc}

10001580 <_kill>:

/*
 * Kill a process
 */
__attribute__((weak)) int _kill(int pid,int sig)
{
10001580:	b580      	push	{r7, lr}
10001582:	b082      	sub	sp, #8
10001584:	af00      	add	r7, sp, #0
10001586:	6078      	str	r0, [r7, #4]
10001588:	6039      	str	r1, [r7, #0]
 pid = pid;
 sig = sig;
 return -1;
1000158a:	2301      	movs	r3, #1
1000158c:	425b      	negs	r3, r3
}
1000158e:	1c18      	adds	r0, r3, #0
10001590:	46bd      	mov	sp, r7
10001592:	b002      	add	sp, #8
10001594:	bd80      	pop	{r7, pc}
10001596:	46c0      	nop			; (mov r8, r8)

10001598 <_fork>:

/*
 * Forking a child process
 */
__attribute__((weak)) int _fork(void)
{
10001598:	b580      	push	{r7, lr}
1000159a:	af00      	add	r7, sp, #0
 return -1;
1000159c:	2301      	movs	r3, #1
1000159e:	425b      	negs	r3, r3
}
100015a0:	1c18      	adds	r0, r3, #0
100015a2:	46bd      	mov	sp, r7
100015a4:	bd80      	pop	{r7, pc}
100015a6:	46c0      	nop			; (mov r8, r8)

100015a8 <_getpid>:

/*
 * Process ID
 */
__attribute__((weak)) int _getpid(void)
{
100015a8:	b580      	push	{r7, lr}
100015aa:	af00      	add	r7, sp, #0
 return -1;
100015ac:	2301      	movs	r3, #1
100015ae:	425b      	negs	r3, r3
}
100015b0:	1c18      	adds	r0, r3, #0
100015b2:	46bd      	mov	sp, r7
100015b4:	bd80      	pop	{r7, pc}
100015b6:	46c0      	nop			; (mov r8, r8)

100015b8 <_exit>:

/*
 * Program/process exit
 */
__attribute__((weak)) void _exit(int rc)
{
100015b8:	b580      	push	{r7, lr}
100015ba:	b082      	sub	sp, #8
100015bc:	af00      	add	r7, sp, #0
100015be:	6078      	str	r0, [r7, #4]
 rc = rc;
 while(1){}
100015c0:	e7fe      	b.n	100015c0 <_exit+0x8>
100015c2:	46c0      	nop			; (mov r8, r8)

100015c4 <_init>:
}

/* Init */
__attribute__((weak)) void _init(void)
{}
100015c4:	b580      	push	{r7, lr}
100015c6:	af00      	add	r7, sp, #0
100015c8:	46bd      	mov	sp, r7
100015ca:	bd80      	pop	{r7, pc}

100015cc <_isatty>:

/*
 * Terminal type evaluation
 */
__attribute__((weak)) int _isatty(int file)
{
100015cc:	b580      	push	{r7, lr}
100015ce:	b082      	sub	sp, #8
100015d0:	af00      	add	r7, sp, #0
100015d2:	6078      	str	r0, [r7, #4]
 file = file;
 return -1;
100015d4:	2301      	movs	r3, #1
100015d6:	425b      	negs	r3, r3
}
100015d8:	1c18      	adds	r0, r3, #0
100015da:	46bd      	mov	sp, r7
100015dc:	b002      	add	sp, #8
100015de:	bd80      	pop	{r7, pc}

100015e0 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
100015e0:	b580      	push	{r7, lr}
100015e2:	b082      	sub	sp, #8
100015e4:	af00      	add	r7, sp, #0
100015e6:	1c02      	adds	r2, r0, #0
100015e8:	1dfb      	adds	r3, r7, #7
100015ea:	701a      	strb	r2, [r3, #0]
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
100015ec:	4b06      	ldr	r3, [pc, #24]	; (10001608 <NVIC_EnableIRQ+0x28>)
100015ee:	1dfa      	adds	r2, r7, #7
100015f0:	7812      	ldrb	r2, [r2, #0]
100015f2:	1c11      	adds	r1, r2, #0
100015f4:	221f      	movs	r2, #31
100015f6:	400a      	ands	r2, r1
100015f8:	2101      	movs	r1, #1
100015fa:	1c08      	adds	r0, r1, #0
100015fc:	4090      	lsls	r0, r2
100015fe:	1c02      	adds	r2, r0, #0
10001600:	601a      	str	r2, [r3, #0]
}
10001602:	46bd      	mov	sp, r7
10001604:	b002      	add	sp, #8
10001606:	bd80      	pop	{r7, pc}
10001608:	e000e100 	.word	0xe000e100

1000160c <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
1000160c:	b5b0      	push	{r4, r5, r7, lr}
1000160e:	b082      	sub	sp, #8
10001610:	af00      	add	r7, sp, #0
10001612:	1c02      	adds	r2, r0, #0
10001614:	6039      	str	r1, [r7, #0]
10001616:	1dfb      	adds	r3, r7, #7
10001618:	701a      	strb	r2, [r3, #0]
  if(IRQn < 0) {
1000161a:	1dfb      	adds	r3, r7, #7
1000161c:	781b      	ldrb	r3, [r3, #0]
1000161e:	2b7f      	cmp	r3, #127	; 0x7f
10001620:	d932      	bls.n	10001688 <NVIC_SetPriority+0x7c>
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
10001622:	4930      	ldr	r1, [pc, #192]	; (100016e4 <NVIC_SetPriority+0xd8>)
10001624:	1dfb      	adds	r3, r7, #7
10001626:	781b      	ldrb	r3, [r3, #0]
10001628:	1c1a      	adds	r2, r3, #0
1000162a:	230f      	movs	r3, #15
1000162c:	4013      	ands	r3, r2
1000162e:	3b08      	subs	r3, #8
10001630:	0898      	lsrs	r0, r3, #2
10001632:	4a2c      	ldr	r2, [pc, #176]	; (100016e4 <NVIC_SetPriority+0xd8>)
10001634:	1dfb      	adds	r3, r7, #7
10001636:	781b      	ldrb	r3, [r3, #0]
10001638:	1c1c      	adds	r4, r3, #0
1000163a:	230f      	movs	r3, #15
1000163c:	4023      	ands	r3, r4
1000163e:	3b08      	subs	r3, #8
10001640:	089b      	lsrs	r3, r3, #2
10001642:	3306      	adds	r3, #6
10001644:	009b      	lsls	r3, r3, #2
10001646:	18d3      	adds	r3, r2, r3
10001648:	685b      	ldr	r3, [r3, #4]
1000164a:	1dfa      	adds	r2, r7, #7
1000164c:	7812      	ldrb	r2, [r2, #0]
1000164e:	1c14      	adds	r4, r2, #0
10001650:	2203      	movs	r2, #3
10001652:	4022      	ands	r2, r4
10001654:	00d2      	lsls	r2, r2, #3
10001656:	24ff      	movs	r4, #255	; 0xff
10001658:	1c25      	adds	r5, r4, #0
1000165a:	4095      	lsls	r5, r2
1000165c:	1c2a      	adds	r2, r5, #0
1000165e:	43d2      	mvns	r2, r2
10001660:	401a      	ands	r2, r3
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
10001662:	683b      	ldr	r3, [r7, #0]
10001664:	019c      	lsls	r4, r3, #6
10001666:	23ff      	movs	r3, #255	; 0xff
10001668:	401c      	ands	r4, r3
1000166a:	1dfb      	adds	r3, r7, #7
1000166c:	781b      	ldrb	r3, [r3, #0]
1000166e:	1c1d      	adds	r5, r3, #0
10001670:	2303      	movs	r3, #3
10001672:	402b      	ands	r3, r5
10001674:	00db      	lsls	r3, r3, #3
10001676:	1c25      	adds	r5, r4, #0
10001678:	409d      	lsls	r5, r3
1000167a:	1c2b      	adds	r3, r5, #0
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
1000167c:	431a      	orrs	r2, r3
1000167e:	1d83      	adds	r3, r0, #6
10001680:	009b      	lsls	r3, r3, #2
10001682:	18cb      	adds	r3, r1, r3
10001684:	605a      	str	r2, [r3, #4]
10001686:	e029      	b.n	100016dc <NVIC_SetPriority+0xd0>
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
  else {
    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
10001688:	4b17      	ldr	r3, [pc, #92]	; (100016e8 <NVIC_SetPriority+0xdc>)
1000168a:	1dfa      	adds	r2, r7, #7
1000168c:	7812      	ldrb	r2, [r2, #0]
1000168e:	b252      	sxtb	r2, r2
10001690:	0892      	lsrs	r2, r2, #2
10001692:	4915      	ldr	r1, [pc, #84]	; (100016e8 <NVIC_SetPriority+0xdc>)
10001694:	1df8      	adds	r0, r7, #7
10001696:	7800      	ldrb	r0, [r0, #0]
10001698:	b240      	sxtb	r0, r0
1000169a:	0880      	lsrs	r0, r0, #2
1000169c:	30c0      	adds	r0, #192	; 0xc0
1000169e:	0080      	lsls	r0, r0, #2
100016a0:	5841      	ldr	r1, [r0, r1]
100016a2:	1df8      	adds	r0, r7, #7
100016a4:	7800      	ldrb	r0, [r0, #0]
100016a6:	1c04      	adds	r4, r0, #0
100016a8:	2003      	movs	r0, #3
100016aa:	4020      	ands	r0, r4
100016ac:	00c0      	lsls	r0, r0, #3
100016ae:	24ff      	movs	r4, #255	; 0xff
100016b0:	1c25      	adds	r5, r4, #0
100016b2:	4085      	lsls	r5, r0
100016b4:	1c28      	adds	r0, r5, #0
100016b6:	43c0      	mvns	r0, r0
100016b8:	4008      	ands	r0, r1
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
100016ba:	6839      	ldr	r1, [r7, #0]
100016bc:	018c      	lsls	r4, r1, #6
100016be:	21ff      	movs	r1, #255	; 0xff
100016c0:	400c      	ands	r4, r1
100016c2:	1df9      	adds	r1, r7, #7
100016c4:	7809      	ldrb	r1, [r1, #0]
100016c6:	1c0d      	adds	r5, r1, #0
100016c8:	2103      	movs	r1, #3
100016ca:	4029      	ands	r1, r5
100016cc:	00c9      	lsls	r1, r1, #3
100016ce:	1c25      	adds	r5, r4, #0
100016d0:	408d      	lsls	r5, r1
100016d2:	1c29      	adds	r1, r5, #0
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
  else {
    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
100016d4:	4301      	orrs	r1, r0
100016d6:	32c0      	adds	r2, #192	; 0xc0
100016d8:	0092      	lsls	r2, r2, #2
100016da:	50d1      	str	r1, [r2, r3]
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
}
100016dc:	46bd      	mov	sp, r7
100016de:	b002      	add	sp, #8
100016e0:	bdb0      	pop	{r4, r5, r7, pc}
100016e2:	46c0      	nop			; (mov r8, r8)
100016e4:	e000ed00 	.word	0xe000ed00
100016e8:	e000e100 	.word	0xe000e100

100016ec <NVIC002_EnableIRQ>:
 *    NVIC002_EnableIRQ(&NVIC002_Handle0);
 *    return 0;
 *  }
 * @endcode<BR> </p>
 */
__STATIC_INLINE void NVIC002_EnableIRQ (const NVIC002_HandleType *const Handle) {
100016ec:	b580      	push	{r7, lr}
100016ee:	b082      	sub	sp, #8
100016f0:	af00      	add	r7, sp, #0
100016f2:	6078      	str	r0, [r7, #4]
    NVIC_EnableIRQ((IRQn_Type)(Handle->NodeID));
100016f4:	687b      	ldr	r3, [r7, #4]
100016f6:	781b      	ldrb	r3, [r3, #0]
100016f8:	b2db      	uxtb	r3, r3
100016fa:	b25b      	sxtb	r3, r3
100016fc:	1c18      	adds	r0, r3, #0
100016fe:	f7ff ff6f 	bl	100015e0 <NVIC_EnableIRQ>
}
10001702:	46bd      	mov	sp, r7
10001704:	b002      	add	sp, #8
10001706:	bd80      	pop	{r7, pc}

10001708 <NVIC002_Init>:

/**  Function to initialize the NVIC node parameters based on 
 *  UI configuration.
 */
void NVIC002_Init(void)
{
10001708:	b580      	push	{r7, lr}
1000170a:	b082      	sub	sp, #8
1000170c:	af00      	add	r7, sp, #0
  uint32_t Count;
  for (Count = 0U; Count<(uint32_t)NVIC002_NUM_INSTANCES; Count++)
1000170e:	2300      	movs	r3, #0
10001710:	607b      	str	r3, [r7, #4]
10001712:	e009      	b.n	10001728 <NVIC002_Init+0x20>
  {
	  NVIC002_lInit(NVIC002_HandleArray[Count]);
10001714:	4b07      	ldr	r3, [pc, #28]	; (10001734 <NVIC002_Init+0x2c>)
10001716:	687a      	ldr	r2, [r7, #4]
10001718:	0092      	lsls	r2, r2, #2
1000171a:	58d3      	ldr	r3, [r2, r3]
1000171c:	1c18      	adds	r0, r3, #0
1000171e:	f000 f80b 	bl	10001738 <NVIC002_lInit>
 *  UI configuration.
 */
void NVIC002_Init(void)
{
  uint32_t Count;
  for (Count = 0U; Count<(uint32_t)NVIC002_NUM_INSTANCES; Count++)
10001722:	687b      	ldr	r3, [r7, #4]
10001724:	3301      	adds	r3, #1
10001726:	607b      	str	r3, [r7, #4]
10001728:	687b      	ldr	r3, [r7, #4]
1000172a:	2b00      	cmp	r3, #0
1000172c:	d0f2      	beq.n	10001714 <NVIC002_Init+0xc>
  {
	  NVIC002_lInit(NVIC002_HandleArray[Count]);
  }
}
1000172e:	46bd      	mov	sp, r7
10001730:	b002      	add	sp, #8
10001732:	bd80      	pop	{r7, pc}
10001734:	20000940 	.word	0x20000940

10001738 <NVIC002_lInit>:

static void NVIC002_lInit(const NVIC002_HandleType * Handle)
{
10001738:	b580      	push	{r7, lr}
1000173a:	b082      	sub	sp, #8
1000173c:	af00      	add	r7, sp, #0
1000173e:	6078      	str	r0, [r7, #4]
   /* Set Interrupt Priority for NVIC <%=NodeID%> 
      Node App Instance <%=appInst%>  */
	#if (UC_FAMILY == XMC1) 
	   NVIC_SetPriority((IRQn_Type)Handle->NodeID, 
10001740:	687b      	ldr	r3, [r7, #4]
10001742:	781b      	ldrb	r3, [r3, #0]
10001744:	b2da      	uxtb	r2, r3
			             Handle->Priority);
10001746:	687b      	ldr	r3, [r7, #4]
10001748:	785b      	ldrb	r3, [r3, #1]
static void NVIC002_lInit(const NVIC002_HandleType * Handle)
{
   /* Set Interrupt Priority for NVIC <%=NodeID%> 
      Node App Instance <%=appInst%>  */
	#if (UC_FAMILY == XMC1) 
	   NVIC_SetPriority((IRQn_Type)Handle->NodeID, 
1000174a:	b252      	sxtb	r2, r2
1000174c:	1c10      	adds	r0, r2, #0
1000174e:	1c19      	adds	r1, r3, #0
10001750:	f7ff ff5c 	bl	1000160c <NVIC_SetPriority>
	   NVIC_SetPriority((IRQn_Type)Handle->NodeID, 
			   	   	     NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
			   	   	     Handle->Priority,
			   	   	     Handle->SubPriority));
	#endif
	if(Handle->InterruptEnable == 1)
10001754:	687b      	ldr	r3, [r7, #4]
10001756:	78db      	ldrb	r3, [r3, #3]
10001758:	2b01      	cmp	r3, #1
1000175a:	d103      	bne.n	10001764 <NVIC002_lInit+0x2c>
	{
	   /* Enable Interrupt */
		NVIC002_EnableIRQ(Handle);
1000175c:	687b      	ldr	r3, [r7, #4]
1000175e:	1c18      	adds	r0, r3, #0
10001760:	f7ff ffc4 	bl	100016ec <NVIC002_EnableIRQ>
	}
   
}
10001764:	46bd      	mov	sp, r7
10001766:	b002      	add	sp, #8
10001768:	bd80      	pop	{r7, pc}
1000176a:	46c0      	nop			; (mov r8, r8)

1000176c <DAVE_Init>:
// @Parameters    None
//
//****************************************************************************

void DAVE_Init(void)
{
1000176c:	b580      	push	{r7, lr}
1000176e:	af00      	add	r7, sp, #0

//****************************************************************************
// @Initialization of APPs Init Functions
//****************************************************************************
	//  MUX configurations
	DAVE_MUX_PreInit(); 
10001770:	f000 f80a 	bl	10001788 <DAVE_MUX_PreInit>
	//  Initialization of app 'NVIC002'		     
	NVIC002_Init();
10001774:	f7ff ffc8 	bl	10001708 <NVIC002_Init>
	
      
	//  MUX configurations
	DAVE_MUX_Init();	
10001778:	f000 f802 	bl	10001780 <DAVE_MUX_Init>
} //  End of function DAVE_Init
1000177c:	46bd      	mov	sp, r7
1000177e:	bd80      	pop	{r7, pc}

10001780 <DAVE_MUX_Init>:
** Description      : This is the Mux configuration                           **
**                                                                            **
*******************************************************************************/
           
void DAVE_MUX_Init(void)
{  
10001780:	b580      	push	{r7, lr}
10001782:	af00      	add	r7, sp, #0
   	 
            	         
                                                     
}
10001784:	46bd      	mov	sp, r7
10001786:	bd80      	pop	{r7, pc}

10001788 <DAVE_MUX_PreInit>:
** Description      : This is the Mux configuration                           **
**                                                                            **
*******************************************************************************/
 
void DAVE_MUX_PreInit(void)
{    
10001788:	b580      	push	{r7, lr}
1000178a:	af00      	add	r7, sp, #0
}
1000178c:	46bd      	mov	sp, r7
1000178e:	bd80      	pop	{r7, pc}

10001790 <__aeabi_uidiv>:
10001790:	2900      	cmp	r1, #0
10001792:	d034      	beq.n	100017fe <.udivsi3_skip_div0_test+0x6a>

10001794 <.udivsi3_skip_div0_test>:
10001794:	2301      	movs	r3, #1
10001796:	2200      	movs	r2, #0
10001798:	b410      	push	{r4}
1000179a:	4288      	cmp	r0, r1
1000179c:	d32c      	bcc.n	100017f8 <.udivsi3_skip_div0_test+0x64>
1000179e:	2401      	movs	r4, #1
100017a0:	0724      	lsls	r4, r4, #28
100017a2:	42a1      	cmp	r1, r4
100017a4:	d204      	bcs.n	100017b0 <.udivsi3_skip_div0_test+0x1c>
100017a6:	4281      	cmp	r1, r0
100017a8:	d202      	bcs.n	100017b0 <.udivsi3_skip_div0_test+0x1c>
100017aa:	0109      	lsls	r1, r1, #4
100017ac:	011b      	lsls	r3, r3, #4
100017ae:	e7f8      	b.n	100017a2 <.udivsi3_skip_div0_test+0xe>
100017b0:	00e4      	lsls	r4, r4, #3
100017b2:	42a1      	cmp	r1, r4
100017b4:	d204      	bcs.n	100017c0 <.udivsi3_skip_div0_test+0x2c>
100017b6:	4281      	cmp	r1, r0
100017b8:	d202      	bcs.n	100017c0 <.udivsi3_skip_div0_test+0x2c>
100017ba:	0049      	lsls	r1, r1, #1
100017bc:	005b      	lsls	r3, r3, #1
100017be:	e7f8      	b.n	100017b2 <.udivsi3_skip_div0_test+0x1e>
100017c0:	4288      	cmp	r0, r1
100017c2:	d301      	bcc.n	100017c8 <.udivsi3_skip_div0_test+0x34>
100017c4:	1a40      	subs	r0, r0, r1
100017c6:	431a      	orrs	r2, r3
100017c8:	084c      	lsrs	r4, r1, #1
100017ca:	42a0      	cmp	r0, r4
100017cc:	d302      	bcc.n	100017d4 <.udivsi3_skip_div0_test+0x40>
100017ce:	1b00      	subs	r0, r0, r4
100017d0:	085c      	lsrs	r4, r3, #1
100017d2:	4322      	orrs	r2, r4
100017d4:	088c      	lsrs	r4, r1, #2
100017d6:	42a0      	cmp	r0, r4
100017d8:	d302      	bcc.n	100017e0 <.udivsi3_skip_div0_test+0x4c>
100017da:	1b00      	subs	r0, r0, r4
100017dc:	089c      	lsrs	r4, r3, #2
100017de:	4322      	orrs	r2, r4
100017e0:	08cc      	lsrs	r4, r1, #3
100017e2:	42a0      	cmp	r0, r4
100017e4:	d302      	bcc.n	100017ec <.udivsi3_skip_div0_test+0x58>
100017e6:	1b00      	subs	r0, r0, r4
100017e8:	08dc      	lsrs	r4, r3, #3
100017ea:	4322      	orrs	r2, r4
100017ec:	2800      	cmp	r0, #0
100017ee:	d003      	beq.n	100017f8 <.udivsi3_skip_div0_test+0x64>
100017f0:	091b      	lsrs	r3, r3, #4
100017f2:	d001      	beq.n	100017f8 <.udivsi3_skip_div0_test+0x64>
100017f4:	0909      	lsrs	r1, r1, #4
100017f6:	e7e3      	b.n	100017c0 <.udivsi3_skip_div0_test+0x2c>
100017f8:	1c10      	adds	r0, r2, #0
100017fa:	bc10      	pop	{r4}
100017fc:	4770      	bx	lr
100017fe:	2800      	cmp	r0, #0
10001800:	d001      	beq.n	10001806 <.udivsi3_skip_div0_test+0x72>
10001802:	2000      	movs	r0, #0
10001804:	43c0      	mvns	r0, r0
10001806:	b407      	push	{r0, r1, r2}
10001808:	4802      	ldr	r0, [pc, #8]	; (10001814 <.udivsi3_skip_div0_test+0x80>)
1000180a:	a102      	add	r1, pc, #8	; (adr r1, 10001814 <.udivsi3_skip_div0_test+0x80>)
1000180c:	1840      	adds	r0, r0, r1
1000180e:	9002      	str	r0, [sp, #8]
10001810:	bd03      	pop	{r0, r1, pc}
10001812:	46c0      	nop			; (mov r8, r8)
10001814:	000000d9 	.word	0x000000d9

10001818 <__aeabi_uidivmod>:
10001818:	2900      	cmp	r1, #0
1000181a:	d0f0      	beq.n	100017fe <.udivsi3_skip_div0_test+0x6a>
1000181c:	b503      	push	{r0, r1, lr}
1000181e:	f7ff ffb9 	bl	10001794 <.udivsi3_skip_div0_test>
10001822:	bc0e      	pop	{r1, r2, r3}
10001824:	4342      	muls	r2, r0
10001826:	1a89      	subs	r1, r1, r2
10001828:	4718      	bx	r3
1000182a:	46c0      	nop			; (mov r8, r8)

1000182c <__aeabi_idiv>:
1000182c:	2900      	cmp	r1, #0
1000182e:	d041      	beq.n	100018b4 <.divsi3_skip_div0_test+0x84>

10001830 <.divsi3_skip_div0_test>:
10001830:	b410      	push	{r4}
10001832:	1c04      	adds	r4, r0, #0
10001834:	404c      	eors	r4, r1
10001836:	46a4      	mov	ip, r4
10001838:	2301      	movs	r3, #1
1000183a:	2200      	movs	r2, #0
1000183c:	2900      	cmp	r1, #0
1000183e:	d500      	bpl.n	10001842 <.divsi3_skip_div0_test+0x12>
10001840:	4249      	negs	r1, r1
10001842:	2800      	cmp	r0, #0
10001844:	d500      	bpl.n	10001848 <.divsi3_skip_div0_test+0x18>
10001846:	4240      	negs	r0, r0
10001848:	4288      	cmp	r0, r1
1000184a:	d32c      	bcc.n	100018a6 <.divsi3_skip_div0_test+0x76>
1000184c:	2401      	movs	r4, #1
1000184e:	0724      	lsls	r4, r4, #28
10001850:	42a1      	cmp	r1, r4
10001852:	d204      	bcs.n	1000185e <.divsi3_skip_div0_test+0x2e>
10001854:	4281      	cmp	r1, r0
10001856:	d202      	bcs.n	1000185e <.divsi3_skip_div0_test+0x2e>
10001858:	0109      	lsls	r1, r1, #4
1000185a:	011b      	lsls	r3, r3, #4
1000185c:	e7f8      	b.n	10001850 <.divsi3_skip_div0_test+0x20>
1000185e:	00e4      	lsls	r4, r4, #3
10001860:	42a1      	cmp	r1, r4
10001862:	d204      	bcs.n	1000186e <.divsi3_skip_div0_test+0x3e>
10001864:	4281      	cmp	r1, r0
10001866:	d202      	bcs.n	1000186e <.divsi3_skip_div0_test+0x3e>
10001868:	0049      	lsls	r1, r1, #1
1000186a:	005b      	lsls	r3, r3, #1
1000186c:	e7f8      	b.n	10001860 <.divsi3_skip_div0_test+0x30>
1000186e:	4288      	cmp	r0, r1
10001870:	d301      	bcc.n	10001876 <.divsi3_skip_div0_test+0x46>
10001872:	1a40      	subs	r0, r0, r1
10001874:	431a      	orrs	r2, r3
10001876:	084c      	lsrs	r4, r1, #1
10001878:	42a0      	cmp	r0, r4
1000187a:	d302      	bcc.n	10001882 <.divsi3_skip_div0_test+0x52>
1000187c:	1b00      	subs	r0, r0, r4
1000187e:	085c      	lsrs	r4, r3, #1
10001880:	4322      	orrs	r2, r4
10001882:	088c      	lsrs	r4, r1, #2
10001884:	42a0      	cmp	r0, r4
10001886:	d302      	bcc.n	1000188e <.divsi3_skip_div0_test+0x5e>
10001888:	1b00      	subs	r0, r0, r4
1000188a:	089c      	lsrs	r4, r3, #2
1000188c:	4322      	orrs	r2, r4
1000188e:	08cc      	lsrs	r4, r1, #3
10001890:	42a0      	cmp	r0, r4
10001892:	d302      	bcc.n	1000189a <.divsi3_skip_div0_test+0x6a>
10001894:	1b00      	subs	r0, r0, r4
10001896:	08dc      	lsrs	r4, r3, #3
10001898:	4322      	orrs	r2, r4
1000189a:	2800      	cmp	r0, #0
1000189c:	d003      	beq.n	100018a6 <.divsi3_skip_div0_test+0x76>
1000189e:	091b      	lsrs	r3, r3, #4
100018a0:	d001      	beq.n	100018a6 <.divsi3_skip_div0_test+0x76>
100018a2:	0909      	lsrs	r1, r1, #4
100018a4:	e7e3      	b.n	1000186e <.divsi3_skip_div0_test+0x3e>
100018a6:	1c10      	adds	r0, r2, #0
100018a8:	4664      	mov	r4, ip
100018aa:	2c00      	cmp	r4, #0
100018ac:	d500      	bpl.n	100018b0 <.divsi3_skip_div0_test+0x80>
100018ae:	4240      	negs	r0, r0
100018b0:	bc10      	pop	{r4}
100018b2:	4770      	bx	lr
100018b4:	2800      	cmp	r0, #0
100018b6:	d006      	beq.n	100018c6 <.divsi3_skip_div0_test+0x96>
100018b8:	db03      	blt.n	100018c2 <.divsi3_skip_div0_test+0x92>
100018ba:	2000      	movs	r0, #0
100018bc:	43c0      	mvns	r0, r0
100018be:	0840      	lsrs	r0, r0, #1
100018c0:	e001      	b.n	100018c6 <.divsi3_skip_div0_test+0x96>
100018c2:	2080      	movs	r0, #128	; 0x80
100018c4:	0600      	lsls	r0, r0, #24
100018c6:	b407      	push	{r0, r1, r2}
100018c8:	4802      	ldr	r0, [pc, #8]	; (100018d4 <.divsi3_skip_div0_test+0xa4>)
100018ca:	a102      	add	r1, pc, #8	; (adr r1, 100018d4 <.divsi3_skip_div0_test+0xa4>)
100018cc:	1840      	adds	r0, r0, r1
100018ce:	9002      	str	r0, [sp, #8]
100018d0:	bd03      	pop	{r0, r1, pc}
100018d2:	46c0      	nop			; (mov r8, r8)
100018d4:	00000019 	.word	0x00000019

100018d8 <__aeabi_idivmod>:
100018d8:	2900      	cmp	r1, #0
100018da:	d0eb      	beq.n	100018b4 <.divsi3_skip_div0_test+0x84>
100018dc:	b503      	push	{r0, r1, lr}
100018de:	f7ff ffa7 	bl	10001830 <.divsi3_skip_div0_test>
100018e2:	bc0e      	pop	{r1, r2, r3}
100018e4:	4342      	muls	r2, r0
100018e6:	1a89      	subs	r1, r1, r2
100018e8:	4718      	bx	r3
100018ea:	46c0      	nop			; (mov r8, r8)

100018ec <__aeabi_idiv0>:
100018ec:	4770      	bx	lr
100018ee:	46c0      	nop			; (mov r8, r8)

Disassembly of section .VENEER_Code:

2000000c <HardFault_Veneer>:

/* ==================VENEERS VENEERS VENEERS VENEERS VENEERS=============== */
    .section ".XmcVeneerCode","ax",%progbits
.globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
2000000c:	482c      	ldr	r0, [pc, #176]	; (200000c0 <CCU40_3_Veneer+0x20>)
    MOV PC,R0
2000000e:	4687      	mov	pc, r0
	...

2000002c <SVC_Veneer>:
    .long 0
    
/* ======================================================================== */
.globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
2000002c:	4825      	ldr	r0, [pc, #148]	; (200000c4 <CCU40_3_Veneer+0x24>)
    MOV PC,R0
2000002e:	4687      	mov	pc, r0
	...

20000038 <PendSV_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
.globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
20000038:	4823      	ldr	r0, [pc, #140]	; (200000c8 <CCU40_3_Veneer+0x28>)
    MOV PC,R0
2000003a:	4687      	mov	pc, r0

2000003c <SysTick_Veneer>:
/* ======================================================================== */
.globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
2000003c:	4823      	ldr	r0, [pc, #140]	; (200000cc <CCU40_3_Veneer+0x2c>)
    MOV PC,R0
2000003e:	4687      	mov	pc, r0

20000040 <SCU_0_Veneer>:
/* ======================================================================== */
.globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
20000040:	4823      	ldr	r0, [pc, #140]	; (200000d0 <CCU40_3_Veneer+0x30>)
    MOV PC,R0
20000042:	4687      	mov	pc, r0

20000044 <SCU_1_Veneer>:
/* ======================================================================== */
.globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
20000044:	4823      	ldr	r0, [pc, #140]	; (200000d4 <CCU40_3_Veneer+0x34>)
    MOV PC,R0
20000046:	4687      	mov	pc, r0

20000048 <SCU_2_Veneer>:
/* ======================================================================== */
.globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
20000048:	4823      	ldr	r0, [pc, #140]	; (200000d8 <CCU40_3_Veneer+0x38>)
    MOV PC,R0
2000004a:	4687      	mov	pc, r0

2000004c <SCU_3_Veneer>:
/* ======================================================================== */
.globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
2000004c:	4823      	ldr	r0, [pc, #140]	; (200000dc <CCU40_3_Veneer+0x3c>)
    MOV PC,R0
2000004e:	4687      	mov	pc, r0

20000050 <SCU_4_Veneer>:
/* ======================================================================== */
.globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
20000050:	4823      	ldr	r0, [pc, #140]	; (200000e0 <CCU40_3_Veneer+0x40>)
    MOV PC,R0
20000052:	4687      	mov	pc, r0

20000054 <SCU_5_Veneer>:
/* ======================================================================== */
.globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
20000054:	4823      	ldr	r0, [pc, #140]	; (200000e4 <CCU40_3_Veneer+0x44>)
    MOV PC,R0
20000056:	4687      	mov	pc, r0

20000058 <SCU_6_Veneer>:
/* ======================================================================== */
.globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
20000058:	4823      	ldr	r0, [pc, #140]	; (200000e8 <CCU40_3_Veneer+0x48>)
    MOV PC,R0
2000005a:	4687      	mov	pc, r0
	...

20000064 <USIC0_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
.globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
20000064:	4821      	ldr	r0, [pc, #132]	; (200000ec <CCU40_3_Veneer+0x4c>)
    MOV PC,R0
20000066:	4687      	mov	pc, r0

20000068 <USIC0_1_Veneer>:
/* ======================================================================== */
.globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
20000068:	4821      	ldr	r0, [pc, #132]	; (200000f0 <CCU40_3_Veneer+0x50>)
    MOV PC,R0
2000006a:	4687      	mov	pc, r0

2000006c <USIC0_2_Veneer>:
/* ======================================================================== */
.globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
2000006c:	4821      	ldr	r0, [pc, #132]	; (200000f4 <CCU40_3_Veneer+0x54>)
    MOV PC,R0
2000006e:	4687      	mov	pc, r0

20000070 <USIC0_3_Veneer>:
/* ======================================================================== */
.globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
20000070:	4821      	ldr	r0, [pc, #132]	; (200000f8 <CCU40_3_Veneer+0x58>)
    MOV PC,R0
20000072:	4687      	mov	pc, r0

20000074 <USIC0_4_Veneer>:
/* ======================================================================== */
.globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
20000074:	4821      	ldr	r0, [pc, #132]	; (200000fc <CCU40_3_Veneer+0x5c>)
    MOV PC,R0
20000076:	4687      	mov	pc, r0

20000078 <USIC0_5_Veneer>:
/* ======================================================================== */
.globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000078:	4821      	ldr	r0, [pc, #132]	; (20000100 <CCU40_3_Veneer+0x60>)
    MOV PC,R0
2000007a:	4687      	mov	pc, r0

2000007c <VADC0_C0_0_Veneer>:
/* ======================================================================== */
.globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
2000007c:	4821      	ldr	r0, [pc, #132]	; (20000104 <CCU40_3_Veneer+0x64>)
    MOV PC,R0
2000007e:	4687      	mov	pc, r0

20000080 <VADC0_C0_1_Veneer>:
/* ======================================================================== */
.globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000080:	4821      	ldr	r0, [pc, #132]	; (20000108 <CCU40_3_Veneer+0x68>)
    MOV PC,R0
20000082:	4687      	mov	pc, r0
	...

20000094 <CCU40_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
.globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
20000094:	481d      	ldr	r0, [pc, #116]	; (2000010c <CCU40_3_Veneer+0x6c>)
    MOV PC,R0
20000096:	4687      	mov	pc, r0

20000098 <CCU40_1_Veneer>:
/* ======================================================================== */
.globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000098:	481d      	ldr	r0, [pc, #116]	; (20000110 <CCU40_3_Veneer+0x70>)
    MOV PC,R0
2000009a:	4687      	mov	pc, r0

2000009c <CCU40_2_Veneer>:
/* ======================================================================== */
.globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
2000009c:	481d      	ldr	r0, [pc, #116]	; (20000114 <CCU40_3_Veneer+0x74>)
    MOV PC,R0
2000009e:	4687      	mov	pc, r0

200000a0 <CCU40_3_Veneer>:
/* ======================================================================== */
.globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
200000a0:	481d      	ldr	r0, [pc, #116]	; (20000118 <CCU40_3_Veneer+0x78>)
    MOV PC,R0
200000a2:	4687      	mov	pc, r0
	...

/* ==================VENEERS VENEERS VENEERS VENEERS VENEERS=============== */
    .section ".XmcVeneerCode","ax",%progbits
.globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
200000c0:	100010d7 	.word	0x100010d7
    .long 0
    
/* ======================================================================== */
.globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
200000c4:	100010d9 	.word	0x100010d9
    .long 0
    .long 0
/* ======================================================================== */
.globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
200000c8:	100010db 	.word	0x100010db
    MOV PC,R0
/* ======================================================================== */
.globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
200000cc:	100010dd 	.word	0x100010dd
    MOV PC,R0
/* ======================================================================== */
.globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
200000d0:	100010df 	.word	0x100010df
    MOV PC,R0
/* ======================================================================== */
.globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
200000d4:	100010e1 	.word	0x100010e1
    MOV PC,R0
/* ======================================================================== */
.globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
200000d8:	100010e3 	.word	0x100010e3
    MOV PC,R0
/* ======================================================================== */
.globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
200000dc:	100010e5 	.word	0x100010e5
    MOV PC,R0
/* ======================================================================== */
.globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
200000e0:	100010e7 	.word	0x100010e7
    MOV PC,R0
/* ======================================================================== */
.globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
200000e4:	100010e9 	.word	0x100010e9
    MOV PC,R0
/* ======================================================================== */
.globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
200000e8:	100010eb 	.word	0x100010eb
    .long 0
    .long 0
/* ======================================================================== */
.globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
200000ec:	100010f9 	.word	0x100010f9
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
200000f0:	100010fb 	.word	0x100010fb
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
200000f4:	100010fd 	.word	0x100010fd
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
200000f8:	100010ff 	.word	0x100010ff
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
200000fc:	10001101 	.word	0x10001101
    MOV PC,R0
/* ======================================================================== */
.globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000100:	10001103 	.word	0x10001103
    MOV PC,R0
/* ======================================================================== */
.globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
20000104:	100010ed 	.word	0x100010ed
    MOV PC,R0
/* ======================================================================== */
.globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000108:	100010ef 	.word	0x100010ef
    .long 0
    .long 0
/* ======================================================================== */
.globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
2000010c:	100010f1 	.word	0x100010f1
    MOV PC,R0
/* ======================================================================== */
.globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000110:	100010f3 	.word	0x100010f3
    MOV PC,R0
/* ======================================================================== */
.globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
20000114:	100010f5 	.word	0x100010f5
    MOV PC,R0
/* ======================================================================== */
.globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
20000118:	100010f7 	.word	0x100010f7
