   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"Main.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.P0_5_set_mode,"ax",%progbits
  18              		.align	2
  19              		.code	16
  20              		.thumb_func
  22              	P0_5_set_mode:
  23              	.LFB88:
  24              		.file 1 "../GPIO.h"
   1:../GPIO.h     **** #ifndef __GPIO_H__
   2:../GPIO.h     **** #define __GPIO_H__
   3:../GPIO.h     **** 
   4:../GPIO.h     **** /* Generated for XMC1100_TSSOP38 on: Wed Feb 13 23:11:00 2013*/
   5:../GPIO.h     **** 
   6:../GPIO.h     **** #include <XMC1100.h>
   7:../GPIO.h     **** 
   8:../GPIO.h     **** #define INPUT           0x00U
   9:../GPIO.h     **** #define INPUT_PD        0x08U
  10:../GPIO.h     **** #define INPUT_PU        0x10U
  11:../GPIO.h     **** #define INPUT_PPS       0x18U
  12:../GPIO.h     **** #define INPUT_INV       0x20U
  13:../GPIO.h     **** #define INPUT_INV_PD    0x28U
  14:../GPIO.h     **** #define INPUT_INV_PU    0x30U
  15:../GPIO.h     **** #define INPUT_INV_PPS   0x38U
  16:../GPIO.h     **** #define OUTPUT_PP_GP    0x80U
  17:../GPIO.h     **** #define OUTPUT_PP_AF1   0x88U
  18:../GPIO.h     **** #define OUTPUT_PP_AF2   0x90U
  19:../GPIO.h     **** #define OUTPUT_PP_AF3   0x98U
  20:../GPIO.h     **** #define OUTPUT_PP_AF4   0xA0U
  21:../GPIO.h     **** #define OUTPUT_PP_AF5   0xA8U
  22:../GPIO.h     **** #define OUTPUT_PP_AF6   0xB0U
  23:../GPIO.h     **** #define OUTPUT_PP_AF7   0xB8U
  24:../GPIO.h     **** #define OUTPUT_OD_GP    0xC0U
  25:../GPIO.h     **** #define OUTPUT_OD_AF1   0xC8U
  26:../GPIO.h     **** #define OUTPUT_OD_AF2   0xD0U
  27:../GPIO.h     **** #define OUTPUT_OD_AF3   0xD8U
  28:../GPIO.h     **** #define OUTPUT_OD_AF4   0XE0U
  29:../GPIO.h     **** #define OUTPUT_OD_AF5   0xE8U
  30:../GPIO.h     **** #define OUTPUT_OD_AF6   0xF0U
  31:../GPIO.h     **** #define OUTPUT_OD_AF7   0XF8U
  32:../GPIO.h     **** 
  33:../GPIO.h     **** #define SOFTWARE        0x0UL
  34:../GPIO.h     **** #define HW0             0x1UL
  35:../GPIO.h     **** #define HW1             0x2UL
  36:../GPIO.h     **** 
  37:../GPIO.h     **** __STATIC_INLINE void P0_0_set_mode(uint8_t mode){
  38:../GPIO.h     ****     PORT0->IOCR0 &= ~0x000000f8UL;
  39:../GPIO.h     ****     PORT0->IOCR0 |= mode << 0;
  40:../GPIO.h     **** }
  41:../GPIO.h     **** 
  42:../GPIO.h     **** __STATIC_INLINE void P0_0_set_hwsel(uint32_t config){
  43:../GPIO.h     ****     PORT0->HWSEL &= ~0x00000003UL;
  44:../GPIO.h     ****     PORT0->HWSEL |= config << 0;
  45:../GPIO.h     **** }
  46:../GPIO.h     **** 
  47:../GPIO.h     **** __STATIC_INLINE void P0_0_set_standard_hysteresis(){
  48:../GPIO.h     ****     PORT0->PHCR0 &= ~0x00000004UL;
  49:../GPIO.h     **** }
  50:../GPIO.h     **** 
  51:../GPIO.h     **** __STATIC_INLINE void P0_0_set_large_hysteresis(){
  52:../GPIO.h     ****     PORT0->PHCR0 |= 0x00000004UL;
  53:../GPIO.h     **** }
  54:../GPIO.h     **** 
  55:../GPIO.h     **** __STATIC_INLINE void P0_0_set(void){
  56:../GPIO.h     ****     PORT0->OMR = 0x00000001UL;
  57:../GPIO.h     **** }
  58:../GPIO.h     **** 
  59:../GPIO.h     **** __STATIC_INLINE void P0_0_reset(void){
  60:../GPIO.h     ****     PORT0->OMR = 0x00010000UL;
  61:../GPIO.h     **** }
  62:../GPIO.h     **** 
  63:../GPIO.h     **** __STATIC_INLINE void P0_0_toggle(void){
  64:../GPIO.h     ****     PORT0->OMR = 0x00010001UL;
  65:../GPIO.h     **** }
  66:../GPIO.h     **** 
  67:../GPIO.h     **** __STATIC_INLINE uint32_t P0_0_read(void){
  68:../GPIO.h     ****     return(PORT0->IN & 0x00000001UL);
  69:../GPIO.h     **** }
  70:../GPIO.h     **** 
  71:../GPIO.h     **** __STATIC_INLINE void P0_0_enable_pps(void){
  72:../GPIO.h     ****     PORT0->PPS |= 0x00000001UL;
  73:../GPIO.h     **** }
  74:../GPIO.h     **** 
  75:../GPIO.h     **** __STATIC_INLINE void P0_0_disable_pps(void){
  76:../GPIO.h     ****     PORT0->PPS &= ~0x00000001UL;
  77:../GPIO.h     **** }
  78:../GPIO.h     **** 
  79:../GPIO.h     **** __STATIC_INLINE void P0_1_set_mode(uint8_t mode){
  80:../GPIO.h     ****     PORT0->IOCR0 &= ~0x0000f800UL;
  81:../GPIO.h     ****     PORT0->IOCR0 |= mode << 8;
  82:../GPIO.h     **** }
  83:../GPIO.h     **** 
  84:../GPIO.h     **** __STATIC_INLINE void P0_1_set_hwsel(uint32_t config){
  85:../GPIO.h     ****     PORT0->HWSEL &= ~0x0000000cUL;
  86:../GPIO.h     ****     PORT0->HWSEL |= config << 2;
  87:../GPIO.h     **** }
  88:../GPIO.h     **** 
  89:../GPIO.h     **** __STATIC_INLINE void P0_1_set_standard_hysteresis(){
  90:../GPIO.h     ****     PORT0->PHCR0 &= ~0x00000040UL;
  91:../GPIO.h     **** }
  92:../GPIO.h     **** 
  93:../GPIO.h     **** __STATIC_INLINE void P0_1_set_large_hysteresis(){
  94:../GPIO.h     ****     PORT0->PHCR0 |= 0x00000040UL;
  95:../GPIO.h     **** }
  96:../GPIO.h     **** 
  97:../GPIO.h     **** __STATIC_INLINE void P0_1_set(void){
  98:../GPIO.h     ****     PORT0->OMR = 0x00000002UL;
  99:../GPIO.h     **** }
 100:../GPIO.h     **** 
 101:../GPIO.h     **** __STATIC_INLINE void P0_1_reset(void){
 102:../GPIO.h     ****     PORT0->OMR = 0x00020000UL;
 103:../GPIO.h     **** }
 104:../GPIO.h     **** 
 105:../GPIO.h     **** __STATIC_INLINE void P0_1_toggle(void){
 106:../GPIO.h     ****     PORT0->OMR = 0x00020002UL;
 107:../GPIO.h     **** }
 108:../GPIO.h     **** 
 109:../GPIO.h     **** __STATIC_INLINE uint32_t P0_1_read(void){
 110:../GPIO.h     ****     return(PORT0->IN & 0x00000002UL);
 111:../GPIO.h     **** }
 112:../GPIO.h     **** 
 113:../GPIO.h     **** __STATIC_INLINE void P0_1_enable_pps(void){
 114:../GPIO.h     ****     PORT0->PPS |= 0x00000002UL;
 115:../GPIO.h     **** }
 116:../GPIO.h     **** 
 117:../GPIO.h     **** __STATIC_INLINE void P0_1_disable_pps(void){
 118:../GPIO.h     ****     PORT0->PPS &= ~0x00000002UL;
 119:../GPIO.h     **** }
 120:../GPIO.h     **** 
 121:../GPIO.h     **** __STATIC_INLINE void P0_2_set_mode(uint8_t mode){
 122:../GPIO.h     ****     PORT0->IOCR0 &= ~0x00f80000UL;
 123:../GPIO.h     ****     PORT0->IOCR0 |= mode << 16;
 124:../GPIO.h     **** }
 125:../GPIO.h     **** 
 126:../GPIO.h     **** __STATIC_INLINE void P0_2_set_hwsel(uint32_t config){
 127:../GPIO.h     ****     PORT0->HWSEL &= ~0x00000030UL;
 128:../GPIO.h     ****     PORT0->HWSEL |= config << 4;
 129:../GPIO.h     **** }
 130:../GPIO.h     **** 
 131:../GPIO.h     **** __STATIC_INLINE void P0_2_set_standard_hysteresis(){
 132:../GPIO.h     ****     PORT0->PHCR0 &= ~0x00000400UL;
 133:../GPIO.h     **** }
 134:../GPIO.h     **** 
 135:../GPIO.h     **** __STATIC_INLINE void P0_2_set_large_hysteresis(){
 136:../GPIO.h     ****     PORT0->PHCR0 |= 0x00000400UL;
 137:../GPIO.h     **** }
 138:../GPIO.h     **** 
 139:../GPIO.h     **** __STATIC_INLINE void P0_2_set(void){
 140:../GPIO.h     ****     PORT0->OMR = 0x00000004UL;
 141:../GPIO.h     **** }
 142:../GPIO.h     **** 
 143:../GPIO.h     **** __STATIC_INLINE void P0_2_reset(void){
 144:../GPIO.h     ****     PORT0->OMR = 0x00040000UL;
 145:../GPIO.h     **** }
 146:../GPIO.h     **** 
 147:../GPIO.h     **** __STATIC_INLINE void P0_2_toggle(void){
 148:../GPIO.h     ****     PORT0->OMR = 0x00040004UL;
 149:../GPIO.h     **** }
 150:../GPIO.h     **** 
 151:../GPIO.h     **** __STATIC_INLINE uint32_t P0_2_read(void){
 152:../GPIO.h     ****     return(PORT0->IN & 0x00000004UL);
 153:../GPIO.h     **** }
 154:../GPIO.h     **** 
 155:../GPIO.h     **** __STATIC_INLINE void P0_2_enable_pps(void){
 156:../GPIO.h     ****     PORT0->PPS |= 0x00000004UL;
 157:../GPIO.h     **** }
 158:../GPIO.h     **** 
 159:../GPIO.h     **** __STATIC_INLINE void P0_2_disable_pps(void){
 160:../GPIO.h     ****     PORT0->PPS &= ~0x00000004UL;
 161:../GPIO.h     **** }
 162:../GPIO.h     **** 
 163:../GPIO.h     **** __STATIC_INLINE void P0_3_set_mode(uint8_t mode){
 164:../GPIO.h     ****     PORT0->IOCR0 &= ~0xf8000000UL;
 165:../GPIO.h     ****     PORT0->IOCR0 |= mode << 24;
 166:../GPIO.h     **** }
 167:../GPIO.h     **** 
 168:../GPIO.h     **** __STATIC_INLINE void P0_3_set_hwsel(uint32_t config){
 169:../GPIO.h     ****     PORT0->HWSEL &= ~0x000000c0UL;
 170:../GPIO.h     ****     PORT0->HWSEL |= config << 6;
 171:../GPIO.h     **** }
 172:../GPIO.h     **** 
 173:../GPIO.h     **** __STATIC_INLINE void P0_3_set_standard_hysteresis(){
 174:../GPIO.h     ****     PORT0->PHCR0 &= ~0x00004000UL;
 175:../GPIO.h     **** }
 176:../GPIO.h     **** 
 177:../GPIO.h     **** __STATIC_INLINE void P0_3_set_large_hysteresis(){
 178:../GPIO.h     ****     PORT0->PHCR0 |= 0x00004000UL;
 179:../GPIO.h     **** }
 180:../GPIO.h     **** 
 181:../GPIO.h     **** __STATIC_INLINE void P0_3_set(void){
 182:../GPIO.h     ****     PORT0->OMR = 0x00000008UL;
 183:../GPIO.h     **** }
 184:../GPIO.h     **** 
 185:../GPIO.h     **** __STATIC_INLINE void P0_3_reset(void){
 186:../GPIO.h     ****     PORT0->OMR = 0x00080000UL;
 187:../GPIO.h     **** }
 188:../GPIO.h     **** 
 189:../GPIO.h     **** __STATIC_INLINE void P0_3_toggle(void){
 190:../GPIO.h     ****     PORT0->OMR = 0x00080008UL;
 191:../GPIO.h     **** }
 192:../GPIO.h     **** 
 193:../GPIO.h     **** __STATIC_INLINE uint32_t P0_3_read(void){
 194:../GPIO.h     ****     return(PORT0->IN & 0x00000008UL);
 195:../GPIO.h     **** }
 196:../GPIO.h     **** 
 197:../GPIO.h     **** __STATIC_INLINE void P0_3_enable_pps(void){
 198:../GPIO.h     ****     PORT0->PPS |= 0x00000008UL;
 199:../GPIO.h     **** }
 200:../GPIO.h     **** 
 201:../GPIO.h     **** __STATIC_INLINE void P0_3_disable_pps(void){
 202:../GPIO.h     ****     PORT0->PPS &= ~0x00000008UL;
 203:../GPIO.h     **** }
 204:../GPIO.h     **** 
 205:../GPIO.h     **** __STATIC_INLINE void P0_4_set_mode(uint8_t mode){
 206:../GPIO.h     ****     PORT0->IOCR4 &= ~0x000000f8UL;
 207:../GPIO.h     ****     PORT0->IOCR4 |= mode << 0;
 208:../GPIO.h     **** }
 209:../GPIO.h     **** 
 210:../GPIO.h     **** __STATIC_INLINE void P0_4_set_hwsel(uint32_t config){
 211:../GPIO.h     ****     PORT0->HWSEL &= ~0x00000300UL;
 212:../GPIO.h     ****     PORT0->HWSEL |= config << 8;
 213:../GPIO.h     **** }
 214:../GPIO.h     **** 
 215:../GPIO.h     **** __STATIC_INLINE void P0_4_set_standard_hysteresis(){
 216:../GPIO.h     ****     PORT0->PHCR0 &= ~0x00040000UL;
 217:../GPIO.h     **** }
 218:../GPIO.h     **** 
 219:../GPIO.h     **** __STATIC_INLINE void P0_4_set_large_hysteresis(){
 220:../GPIO.h     ****     PORT0->PHCR0 |= 0x00040000UL;
 221:../GPIO.h     **** }
 222:../GPIO.h     **** 
 223:../GPIO.h     **** __STATIC_INLINE void P0_4_set(void){
 224:../GPIO.h     ****     PORT0->OMR = 0x00000010UL;
 225:../GPIO.h     **** }
 226:../GPIO.h     **** 
 227:../GPIO.h     **** __STATIC_INLINE void P0_4_reset(void){
 228:../GPIO.h     ****     PORT0->OMR = 0x00100000UL;
 229:../GPIO.h     **** }
 230:../GPIO.h     **** 
 231:../GPIO.h     **** __STATIC_INLINE void P0_4_toggle(void){
 232:../GPIO.h     ****     PORT0->OMR = 0x00100010UL;
 233:../GPIO.h     **** }
 234:../GPIO.h     **** 
 235:../GPIO.h     **** __STATIC_INLINE uint32_t P0_4_read(void){
 236:../GPIO.h     ****     return(PORT0->IN & 0x00000010UL);
 237:../GPIO.h     **** }
 238:../GPIO.h     **** 
 239:../GPIO.h     **** __STATIC_INLINE void P0_4_enable_pps(void){
 240:../GPIO.h     ****     PORT0->PPS |= 0x00000010UL;
 241:../GPIO.h     **** }
 242:../GPIO.h     **** 
 243:../GPIO.h     **** __STATIC_INLINE void P0_4_disable_pps(void){
 244:../GPIO.h     ****     PORT0->PPS &= ~0x00000010UL;
 245:../GPIO.h     **** }
 246:../GPIO.h     **** 
 247:../GPIO.h     **** __STATIC_INLINE void P0_5_set_mode(uint8_t mode){
  25              		.loc 1 247 0
  26              		.cfi_startproc
  27 0000 80B5     		push	{r7, lr}
  28              	.LCFI0:
  29              		.cfi_def_cfa_offset 8
  30              		.cfi_offset 7, -8
  31              		.cfi_offset 14, -4
  32 0002 82B0     		sub	sp, sp, #8
  33              	.LCFI1:
  34              		.cfi_def_cfa_offset 16
  35 0004 00AF     		add	r7, sp, #0
  36              	.LCFI2:
  37              		.cfi_def_cfa_register 7
  38 0006 021C     		mov	r2, r0
  39 0008 FB1D     		add	r3, r7, #7
  40 000a 1A70     		strb	r2, [r3]
 248:../GPIO.h     ****     PORT0->IOCR4 &= ~0x0000f800UL;
  41              		.loc 1 248 0
  42 000c 084B     		ldr	r3, .L2
  43 000e 084A     		ldr	r2, .L2
  44 0010 5169     		ldr	r1, [r2, #20]
  45 0012 084A     		ldr	r2, .L2+4
  46 0014 0A40     		and	r2, r1
  47 0016 5A61     		str	r2, [r3, #20]
 249:../GPIO.h     ****     PORT0->IOCR4 |= mode << 8;
  48              		.loc 1 249 0
  49 0018 054B     		ldr	r3, .L2
  50 001a 054A     		ldr	r2, .L2
  51 001c 5169     		ldr	r1, [r2, #20]
  52 001e FA1D     		add	r2, r7, #7
  53 0020 1278     		ldrb	r2, [r2]
  54 0022 1202     		lsl	r2, r2, #8
  55 0024 0A43     		orr	r2, r1
  56 0026 5A61     		str	r2, [r3, #20]
 250:../GPIO.h     **** }
  57              		.loc 1 250 0
  58 0028 BD46     		mov	sp, r7
  59 002a 02B0     		add	sp, sp, #8
  60              		@ sp needed for prologue
  61 002c 80BD     		pop	{r7, pc}
  62              	.L3:
  63 002e C046     		.align	2
  64              	.L2:
  65 0030 00000440 		.word	1074003968
  66 0034 FF07FFFF 		.word	-63489
  67              		.cfi_endproc
  68              	.LFE88:
  70              		.section	.text.P0_5_set,"ax",%progbits
  71              		.align	2
  72              		.code	16
  73              		.thumb_func
  75              	P0_5_set:
  76              	.LFB92:
 251:../GPIO.h     **** 
 252:../GPIO.h     **** __STATIC_INLINE void P0_5_set_hwsel(uint32_t config){
 253:../GPIO.h     ****     PORT0->HWSEL &= ~0x00000c00UL;
 254:../GPIO.h     ****     PORT0->HWSEL |= config << 10;
 255:../GPIO.h     **** }
 256:../GPIO.h     **** 
 257:../GPIO.h     **** __STATIC_INLINE void P0_5_set_standard_hysteresis(){
 258:../GPIO.h     ****     PORT0->PHCR0 &= ~0x00400000UL;
 259:../GPIO.h     **** }
 260:../GPIO.h     **** 
 261:../GPIO.h     **** __STATIC_INLINE void P0_5_set_large_hysteresis(){
 262:../GPIO.h     ****     PORT0->PHCR0 |= 0x00400000UL;
 263:../GPIO.h     **** }
 264:../GPIO.h     **** 
 265:../GPIO.h     **** __STATIC_INLINE void P0_5_set(void){
  77              		.loc 1 265 0
  78              		.cfi_startproc
  79 0000 80B5     		push	{r7, lr}
  80              	.LCFI3:
  81              		.cfi_def_cfa_offset 8
  82              		.cfi_offset 7, -8
  83              		.cfi_offset 14, -4
  84 0002 00AF     		add	r7, sp, #0
  85              	.LCFI4:
  86              		.cfi_def_cfa_register 7
 266:../GPIO.h     ****     PORT0->OMR = 0x00000020UL;
  87              		.loc 1 266 0
  88 0004 024B     		ldr	r3, .L5
  89 0006 2022     		mov	r2, #32
  90 0008 5A60     		str	r2, [r3, #4]
 267:../GPIO.h     **** }
  91              		.loc 1 267 0
  92 000a BD46     		mov	sp, r7
  93              		@ sp needed for prologue
  94 000c 80BD     		pop	{r7, pc}
  95              	.L6:
  96 000e C046     		.align	2
  97              	.L5:
  98 0010 00000440 		.word	1074003968
  99              		.cfi_endproc
 100              	.LFE92:
 102              		.section	.text.P0_5_toggle,"ax",%progbits
 103              		.align	2
 104              		.code	16
 105              		.thumb_func
 107              	P0_5_toggle:
 108              	.LFB94:
 268:../GPIO.h     **** 
 269:../GPIO.h     **** __STATIC_INLINE void P0_5_reset(void){
 270:../GPIO.h     ****     PORT0->OMR = 0x00200000UL;
 271:../GPIO.h     **** }
 272:../GPIO.h     **** 
 273:../GPIO.h     **** __STATIC_INLINE void P0_5_toggle(void){
 109              		.loc 1 273 0
 110              		.cfi_startproc
 111 0000 80B5     		push	{r7, lr}
 112              	.LCFI5:
 113              		.cfi_def_cfa_offset 8
 114              		.cfi_offset 7, -8
 115              		.cfi_offset 14, -4
 116 0002 00AF     		add	r7, sp, #0
 117              	.LCFI6:
 118              		.cfi_def_cfa_register 7
 274:../GPIO.h     ****     PORT0->OMR = 0x00200020UL;
 119              		.loc 1 274 0
 120 0004 024B     		ldr	r3, .L8
 121 0006 034A     		ldr	r2, .L8+4
 122 0008 5A60     		str	r2, [r3, #4]
 275:../GPIO.h     **** }
 123              		.loc 1 275 0
 124 000a BD46     		mov	sp, r7
 125              		@ sp needed for prologue
 126 000c 80BD     		pop	{r7, pc}
 127              	.L9:
 128 000e C046     		.align	2
 129              	.L8:
 130 0010 00000440 		.word	1074003968
 131 0014 20002000 		.word	2097184
 132              		.cfi_endproc
 133              	.LFE94:
 135              		.section	.text.P0_6_set_mode,"ax",%progbits
 136              		.align	2
 137              		.code	16
 138              		.thumb_func
 140              	P0_6_set_mode:
 141              	.LFB98:
 276:../GPIO.h     **** 
 277:../GPIO.h     **** __STATIC_INLINE uint32_t P0_5_read(void){
 278:../GPIO.h     ****     return(PORT0->IN & 0x00000020UL);
 279:../GPIO.h     **** }
 280:../GPIO.h     **** 
 281:../GPIO.h     **** __STATIC_INLINE void P0_5_enable_pps(void){
 282:../GPIO.h     ****     PORT0->PPS |= 0x00000020UL;
 283:../GPIO.h     **** }
 284:../GPIO.h     **** 
 285:../GPIO.h     **** __STATIC_INLINE void P0_5_disable_pps(void){
 286:../GPIO.h     ****     PORT0->PPS &= ~0x00000020UL;
 287:../GPIO.h     **** }
 288:../GPIO.h     **** 
 289:../GPIO.h     **** __STATIC_INLINE void P0_6_set_mode(uint8_t mode){
 142              		.loc 1 289 0
 143              		.cfi_startproc
 144 0000 80B5     		push	{r7, lr}
 145              	.LCFI7:
 146              		.cfi_def_cfa_offset 8
 147              		.cfi_offset 7, -8
 148              		.cfi_offset 14, -4
 149 0002 82B0     		sub	sp, sp, #8
 150              	.LCFI8:
 151              		.cfi_def_cfa_offset 16
 152 0004 00AF     		add	r7, sp, #0
 153              	.LCFI9:
 154              		.cfi_def_cfa_register 7
 155 0006 021C     		mov	r2, r0
 156 0008 FB1D     		add	r3, r7, #7
 157 000a 1A70     		strb	r2, [r3]
 290:../GPIO.h     ****     PORT0->IOCR4 &= ~0x00f80000UL;
 158              		.loc 1 290 0
 159 000c 084B     		ldr	r3, .L11
 160 000e 084A     		ldr	r2, .L11
 161 0010 5169     		ldr	r1, [r2, #20]
 162 0012 084A     		ldr	r2, .L11+4
 163 0014 0A40     		and	r2, r1
 164 0016 5A61     		str	r2, [r3, #20]
 291:../GPIO.h     ****     PORT0->IOCR4 |= mode << 16;
 165              		.loc 1 291 0
 166 0018 054B     		ldr	r3, .L11
 167 001a 054A     		ldr	r2, .L11
 168 001c 5169     		ldr	r1, [r2, #20]
 169 001e FA1D     		add	r2, r7, #7
 170 0020 1278     		ldrb	r2, [r2]
 171 0022 1204     		lsl	r2, r2, #16
 172 0024 0A43     		orr	r2, r1
 173 0026 5A61     		str	r2, [r3, #20]
 292:../GPIO.h     **** }
 174              		.loc 1 292 0
 175 0028 BD46     		mov	sp, r7
 176 002a 02B0     		add	sp, sp, #8
 177              		@ sp needed for prologue
 178 002c 80BD     		pop	{r7, pc}
 179              	.L12:
 180 002e C046     		.align	2
 181              	.L11:
 182 0030 00000440 		.word	1074003968
 183 0034 FFFF07FF 		.word	-16252929
 184              		.cfi_endproc
 185              	.LFE98:
 187              		.section	.text.P0_6_set_large_hysteresis,"ax",%progbits
 188              		.align	2
 189              		.code	16
 190              		.thumb_func
 192              	P0_6_set_large_hysteresis:
 193              	.LFB101:
 293:../GPIO.h     **** 
 294:../GPIO.h     **** __STATIC_INLINE void P0_6_set_hwsel(uint32_t config){
 295:../GPIO.h     ****     PORT0->HWSEL &= ~0x00003000UL;
 296:../GPIO.h     ****     PORT0->HWSEL |= config << 12;
 297:../GPIO.h     **** }
 298:../GPIO.h     **** 
 299:../GPIO.h     **** __STATIC_INLINE void P0_6_set_standard_hysteresis(){
 300:../GPIO.h     ****     PORT0->PHCR0 &= ~0x04000000UL;
 301:../GPIO.h     **** }
 302:../GPIO.h     **** 
 303:../GPIO.h     **** __STATIC_INLINE void P0_6_set_large_hysteresis(){
 194              		.loc 1 303 0
 195              		.cfi_startproc
 196 0000 80B5     		push	{r7, lr}
 197              	.LCFI10:
 198              		.cfi_def_cfa_offset 8
 199              		.cfi_offset 7, -8
 200              		.cfi_offset 14, -4
 201 0002 00AF     		add	r7, sp, #0
 202              	.LCFI11:
 203              		.cfi_def_cfa_register 7
 304:../GPIO.h     ****     PORT0->PHCR0 |= 0x04000000UL;
 204              		.loc 1 304 0
 205 0004 044B     		ldr	r3, .L14
 206 0006 044A     		ldr	r2, .L14
 207 0008 126C     		ldr	r2, [r2, #64]
 208 000a 8021     		mov	r1, #128
 209 000c C904     		lsl	r1, r1, #19
 210 000e 0A43     		orr	r2, r1
 211 0010 1A64     		str	r2, [r3, #64]
 305:../GPIO.h     **** }
 212              		.loc 1 305 0
 213 0012 BD46     		mov	sp, r7
 214              		@ sp needed for prologue
 215 0014 80BD     		pop	{r7, pc}
 216              	.L15:
 217 0016 C046     		.align	2
 218              	.L14:
 219 0018 00000440 		.word	1074003968
 220              		.cfi_endproc
 221              	.LFE101:
 223              		.section	.text.P0_6_read,"ax",%progbits
 224              		.align	2
 225              		.code	16
 226              		.thumb_func
 228              	P0_6_read:
 229              	.LFB105:
 306:../GPIO.h     **** 
 307:../GPIO.h     **** __STATIC_INLINE void P0_6_set(void){
 308:../GPIO.h     ****     PORT0->OMR = 0x00000040UL;
 309:../GPIO.h     **** }
 310:../GPIO.h     **** 
 311:../GPIO.h     **** __STATIC_INLINE void P0_6_reset(void){
 312:../GPIO.h     ****     PORT0->OMR = 0x00400000UL;
 313:../GPIO.h     **** }
 314:../GPIO.h     **** 
 315:../GPIO.h     **** __STATIC_INLINE void P0_6_toggle(void){
 316:../GPIO.h     ****     PORT0->OMR = 0x00400040UL;
 317:../GPIO.h     **** }
 318:../GPIO.h     **** 
 319:../GPIO.h     **** __STATIC_INLINE uint32_t P0_6_read(void){
 230              		.loc 1 319 0
 231              		.cfi_startproc
 232 0000 80B5     		push	{r7, lr}
 233              	.LCFI12:
 234              		.cfi_def_cfa_offset 8
 235              		.cfi_offset 7, -8
 236              		.cfi_offset 14, -4
 237 0002 00AF     		add	r7, sp, #0
 238              	.LCFI13:
 239              		.cfi_def_cfa_register 7
 320:../GPIO.h     ****     return(PORT0->IN & 0x00000040UL);
 240              		.loc 1 320 0
 241 0004 034B     		ldr	r3, .L18
 242 0006 5A6A     		ldr	r2, [r3, #36]
 243 0008 4023     		mov	r3, #64
 244 000a 1340     		and	r3, r2
 321:../GPIO.h     **** }
 245              		.loc 1 321 0
 246 000c 181C     		mov	r0, r3
 247 000e BD46     		mov	sp, r7
 248              		@ sp needed for prologue
 249 0010 80BD     		pop	{r7, pc}
 250              	.L19:
 251 0012 C046     		.align	2
 252              	.L18:
 253 0014 00000440 		.word	1074003968
 254              		.cfi_endproc
 255              	.LFE105:
 257              		.section	.text.P1_4_set_mode,"ax",%progbits
 258              		.align	2
 259              		.code	16
 260              		.thumb_func
 262              	P1_4_set_mode:
 263              	.LFB238:
 322:../GPIO.h     **** 
 323:../GPIO.h     **** __STATIC_INLINE void P0_6_enable_pps(void){
 324:../GPIO.h     ****     PORT0->PPS |= 0x00000040UL;
 325:../GPIO.h     **** }
 326:../GPIO.h     **** 
 327:../GPIO.h     **** __STATIC_INLINE void P0_6_disable_pps(void){
 328:../GPIO.h     ****     PORT0->PPS &= ~0x00000040UL;
 329:../GPIO.h     **** }
 330:../GPIO.h     **** 
 331:../GPIO.h     **** __STATIC_INLINE void P0_7_set_mode(uint8_t mode){
 332:../GPIO.h     ****     PORT0->IOCR4 &= ~0xf8000000UL;
 333:../GPIO.h     ****     PORT0->IOCR4 |= mode << 24;
 334:../GPIO.h     **** }
 335:../GPIO.h     **** 
 336:../GPIO.h     **** __STATIC_INLINE void P0_7_set_hwsel(uint32_t config){
 337:../GPIO.h     ****     PORT0->HWSEL &= ~0x0000c000UL;
 338:../GPIO.h     ****     PORT0->HWSEL |= config << 14;
 339:../GPIO.h     **** }
 340:../GPIO.h     **** 
 341:../GPIO.h     **** __STATIC_INLINE void P0_7_set_standard_hysteresis(){
 342:../GPIO.h     ****     PORT0->PHCR0 &= ~0x40000000UL;
 343:../GPIO.h     **** }
 344:../GPIO.h     **** 
 345:../GPIO.h     **** __STATIC_INLINE void P0_7_set_large_hysteresis(){
 346:../GPIO.h     ****     PORT0->PHCR0 |= 0x40000000UL;
 347:../GPIO.h     **** }
 348:../GPIO.h     **** 
 349:../GPIO.h     **** __STATIC_INLINE void P0_7_set(void){
 350:../GPIO.h     ****     PORT0->OMR = 0x00000080UL;
 351:../GPIO.h     **** }
 352:../GPIO.h     **** 
 353:../GPIO.h     **** __STATIC_INLINE void P0_7_reset(void){
 354:../GPIO.h     ****     PORT0->OMR = 0x00800000UL;
 355:../GPIO.h     **** }
 356:../GPIO.h     **** 
 357:../GPIO.h     **** __STATIC_INLINE void P0_7_toggle(void){
 358:../GPIO.h     ****     PORT0->OMR = 0x00800080UL;
 359:../GPIO.h     **** }
 360:../GPIO.h     **** 
 361:../GPIO.h     **** __STATIC_INLINE uint32_t P0_7_read(void){
 362:../GPIO.h     ****     return(PORT0->IN & 0x00000080UL);
 363:../GPIO.h     **** }
 364:../GPIO.h     **** 
 365:../GPIO.h     **** __STATIC_INLINE void P0_7_enable_pps(void){
 366:../GPIO.h     ****     PORT0->PPS |= 0x00000080UL;
 367:../GPIO.h     **** }
 368:../GPIO.h     **** 
 369:../GPIO.h     **** __STATIC_INLINE void P0_7_disable_pps(void){
 370:../GPIO.h     ****     PORT0->PPS &= ~0x00000080UL;
 371:../GPIO.h     **** }
 372:../GPIO.h     **** 
 373:../GPIO.h     **** __STATIC_INLINE void P0_8_set_mode(uint8_t mode){
 374:../GPIO.h     ****     PORT0->IOCR8 &= ~0x000000f8UL;
 375:../GPIO.h     ****     PORT0->IOCR8 |= mode << 0;
 376:../GPIO.h     **** }
 377:../GPIO.h     **** 
 378:../GPIO.h     **** __STATIC_INLINE void P0_8_set_hwsel(uint32_t config){
 379:../GPIO.h     ****     PORT0->HWSEL &= ~0x00030000UL;
 380:../GPIO.h     ****     PORT0->HWSEL |= config << 16;
 381:../GPIO.h     **** }
 382:../GPIO.h     **** 
 383:../GPIO.h     **** __STATIC_INLINE void P0_8_set_standard_hysteresis(){
 384:../GPIO.h     ****     PORT0->PHCR1 &= ~0x00000004UL;
 385:../GPIO.h     **** }
 386:../GPIO.h     **** 
 387:../GPIO.h     **** __STATIC_INLINE void P0_8_set_large_hysteresis(){
 388:../GPIO.h     ****     PORT0->PHCR1 |= 0x00000004UL;
 389:../GPIO.h     **** }
 390:../GPIO.h     **** 
 391:../GPIO.h     **** __STATIC_INLINE void P0_8_set(void){
 392:../GPIO.h     ****     PORT0->OMR = 0x00000100UL;
 393:../GPIO.h     **** }
 394:../GPIO.h     **** 
 395:../GPIO.h     **** __STATIC_INLINE void P0_8_reset(void){
 396:../GPIO.h     ****     PORT0->OMR = 0x01000000UL;
 397:../GPIO.h     **** }
 398:../GPIO.h     **** 
 399:../GPIO.h     **** __STATIC_INLINE void P0_8_toggle(void){
 400:../GPIO.h     ****     PORT0->OMR = 0x01000100UL;
 401:../GPIO.h     **** }
 402:../GPIO.h     **** 
 403:../GPIO.h     **** __STATIC_INLINE uint32_t P0_8_read(void){
 404:../GPIO.h     ****     return(PORT0->IN & 0x00000100UL);
 405:../GPIO.h     **** }
 406:../GPIO.h     **** 
 407:../GPIO.h     **** __STATIC_INLINE void P0_8_enable_pps(void){
 408:../GPIO.h     ****     PORT0->PPS |= 0x00000100UL;
 409:../GPIO.h     **** }
 410:../GPIO.h     **** 
 411:../GPIO.h     **** __STATIC_INLINE void P0_8_disable_pps(void){
 412:../GPIO.h     ****     PORT0->PPS &= ~0x00000100UL;
 413:../GPIO.h     **** }
 414:../GPIO.h     **** 
 415:../GPIO.h     **** __STATIC_INLINE void P0_9_set_mode(uint8_t mode){
 416:../GPIO.h     ****     PORT0->IOCR8 &= ~0x0000f800UL;
 417:../GPIO.h     ****     PORT0->IOCR8 |= mode << 8;
 418:../GPIO.h     **** }
 419:../GPIO.h     **** 
 420:../GPIO.h     **** __STATIC_INLINE void P0_9_set_hwsel(uint32_t config){
 421:../GPIO.h     ****     PORT0->HWSEL &= ~0x000c0000UL;
 422:../GPIO.h     ****     PORT0->HWSEL |= config << 18;
 423:../GPIO.h     **** }
 424:../GPIO.h     **** 
 425:../GPIO.h     **** __STATIC_INLINE void P0_9_set_standard_hysteresis(){
 426:../GPIO.h     ****     PORT0->PHCR1 &= ~0x00000040UL;
 427:../GPIO.h     **** }
 428:../GPIO.h     **** 
 429:../GPIO.h     **** __STATIC_INLINE void P0_9_set_large_hysteresis(){
 430:../GPIO.h     ****     PORT0->PHCR1 |= 0x00000040UL;
 431:../GPIO.h     **** }
 432:../GPIO.h     **** 
 433:../GPIO.h     **** __STATIC_INLINE void P0_9_set(void){
 434:../GPIO.h     ****     PORT0->OMR = 0x00000200UL;
 435:../GPIO.h     **** }
 436:../GPIO.h     **** 
 437:../GPIO.h     **** __STATIC_INLINE void P0_9_reset(void){
 438:../GPIO.h     ****     PORT0->OMR = 0x02000000UL;
 439:../GPIO.h     **** }
 440:../GPIO.h     **** 
 441:../GPIO.h     **** __STATIC_INLINE void P0_9_toggle(void){
 442:../GPIO.h     ****     PORT0->OMR = 0x02000200UL;
 443:../GPIO.h     **** }
 444:../GPIO.h     **** 
 445:../GPIO.h     **** __STATIC_INLINE uint32_t P0_9_read(void){
 446:../GPIO.h     ****     return(PORT0->IN & 0x00000200UL);
 447:../GPIO.h     **** }
 448:../GPIO.h     **** 
 449:../GPIO.h     **** __STATIC_INLINE void P0_9_enable_pps(void){
 450:../GPIO.h     ****     PORT0->PPS |= 0x00000200UL;
 451:../GPIO.h     **** }
 452:../GPIO.h     **** 
 453:../GPIO.h     **** __STATIC_INLINE void P0_9_disable_pps(void){
 454:../GPIO.h     ****     PORT0->PPS &= ~0x00000200UL;
 455:../GPIO.h     **** }
 456:../GPIO.h     **** 
 457:../GPIO.h     **** __STATIC_INLINE void P0_10_set_mode(uint8_t mode){
 458:../GPIO.h     ****     PORT0->IOCR8 &= ~0x00f80000UL;
 459:../GPIO.h     ****     PORT0->IOCR8 |= mode << 16;
 460:../GPIO.h     **** }
 461:../GPIO.h     **** 
 462:../GPIO.h     **** __STATIC_INLINE void P0_10_set_hwsel(uint32_t config){
 463:../GPIO.h     ****     PORT0->HWSEL &= ~0x00300000UL;
 464:../GPIO.h     ****     PORT0->HWSEL |= config << 20;
 465:../GPIO.h     **** }
 466:../GPIO.h     **** 
 467:../GPIO.h     **** __STATIC_INLINE void P0_10_set_standard_hysteresis(){
 468:../GPIO.h     ****     PORT0->PHCR1 &= ~0x00000400UL;
 469:../GPIO.h     **** }
 470:../GPIO.h     **** 
 471:../GPIO.h     **** __STATIC_INLINE void P0_10_set_large_hysteresis(){
 472:../GPIO.h     ****     PORT0->PHCR1 |= 0x00000400UL;
 473:../GPIO.h     **** }
 474:../GPIO.h     **** 
 475:../GPIO.h     **** __STATIC_INLINE void P0_10_set(void){
 476:../GPIO.h     ****     PORT0->OMR = 0x00000400UL;
 477:../GPIO.h     **** }
 478:../GPIO.h     **** 
 479:../GPIO.h     **** __STATIC_INLINE void P0_10_reset(void){
 480:../GPIO.h     ****     PORT0->OMR = 0x04000000UL;
 481:../GPIO.h     **** }
 482:../GPIO.h     **** 
 483:../GPIO.h     **** __STATIC_INLINE void P0_10_toggle(void){
 484:../GPIO.h     ****     PORT0->OMR = 0x04000400UL;
 485:../GPIO.h     **** }
 486:../GPIO.h     **** 
 487:../GPIO.h     **** __STATIC_INLINE uint32_t P0_10_read(void){
 488:../GPIO.h     ****     return(PORT0->IN & 0x00000400UL);
 489:../GPIO.h     **** }
 490:../GPIO.h     **** 
 491:../GPIO.h     **** __STATIC_INLINE void P0_10_enable_pps(void){
 492:../GPIO.h     ****     PORT0->PPS |= 0x00000400UL;
 493:../GPIO.h     **** }
 494:../GPIO.h     **** 
 495:../GPIO.h     **** __STATIC_INLINE void P0_10_disable_pps(void){
 496:../GPIO.h     ****     PORT0->PPS &= ~0x00000400UL;
 497:../GPIO.h     **** }
 498:../GPIO.h     **** 
 499:../GPIO.h     **** __STATIC_INLINE void P0_11_set_mode(uint8_t mode){
 500:../GPIO.h     ****     PORT0->IOCR8 &= ~0xf8000000UL;
 501:../GPIO.h     ****     PORT0->IOCR8 |= mode << 24;
 502:../GPIO.h     **** }
 503:../GPIO.h     **** 
 504:../GPIO.h     **** __STATIC_INLINE void P0_11_set_hwsel(uint32_t config){
 505:../GPIO.h     ****     PORT0->HWSEL &= ~0x00c00000UL;
 506:../GPIO.h     ****     PORT0->HWSEL |= config << 22;
 507:../GPIO.h     **** }
 508:../GPIO.h     **** 
 509:../GPIO.h     **** __STATIC_INLINE void P0_11_set_standard_hysteresis(){
 510:../GPIO.h     ****     PORT0->PHCR1 &= ~0x00004000UL;
 511:../GPIO.h     **** }
 512:../GPIO.h     **** 
 513:../GPIO.h     **** __STATIC_INLINE void P0_11_set_large_hysteresis(){
 514:../GPIO.h     ****     PORT0->PHCR1 |= 0x00004000UL;
 515:../GPIO.h     **** }
 516:../GPIO.h     **** 
 517:../GPIO.h     **** __STATIC_INLINE void P0_11_set(void){
 518:../GPIO.h     ****     PORT0->OMR = 0x00000800UL;
 519:../GPIO.h     **** }
 520:../GPIO.h     **** 
 521:../GPIO.h     **** __STATIC_INLINE void P0_11_reset(void){
 522:../GPIO.h     ****     PORT0->OMR = 0x08000000UL;
 523:../GPIO.h     **** }
 524:../GPIO.h     **** 
 525:../GPIO.h     **** __STATIC_INLINE void P0_11_toggle(void){
 526:../GPIO.h     ****     PORT0->OMR = 0x08000800UL;
 527:../GPIO.h     **** }
 528:../GPIO.h     **** 
 529:../GPIO.h     **** __STATIC_INLINE uint32_t P0_11_read(void){
 530:../GPIO.h     ****     return(PORT0->IN & 0x00000800UL);
 531:../GPIO.h     **** }
 532:../GPIO.h     **** 
 533:../GPIO.h     **** __STATIC_INLINE void P0_11_enable_pps(void){
 534:../GPIO.h     ****     PORT0->PPS |= 0x00000800UL;
 535:../GPIO.h     **** }
 536:../GPIO.h     **** 
 537:../GPIO.h     **** __STATIC_INLINE void P0_11_disable_pps(void){
 538:../GPIO.h     ****     PORT0->PPS &= ~0x00000800UL;
 539:../GPIO.h     **** }
 540:../GPIO.h     **** 
 541:../GPIO.h     **** __STATIC_INLINE void P0_12_set_mode(uint8_t mode){
 542:../GPIO.h     ****     PORT0->IOCR12 &= ~0x000000f8UL;
 543:../GPIO.h     ****     PORT0->IOCR12 |= mode << 0;
 544:../GPIO.h     **** }
 545:../GPIO.h     **** 
 546:../GPIO.h     **** __STATIC_INLINE void P0_12_set_hwsel(uint32_t config){
 547:../GPIO.h     ****     PORT0->HWSEL &= ~0x03000000UL;
 548:../GPIO.h     ****     PORT0->HWSEL |= config << 24;
 549:../GPIO.h     **** }
 550:../GPIO.h     **** 
 551:../GPIO.h     **** __STATIC_INLINE void P0_12_set_standard_hysteresis(){
 552:../GPIO.h     ****     PORT0->PHCR1 &= ~0x00040000UL;
 553:../GPIO.h     **** }
 554:../GPIO.h     **** 
 555:../GPIO.h     **** __STATIC_INLINE void P0_12_set_large_hysteresis(){
 556:../GPIO.h     ****     PORT0->PHCR1 |= 0x00040000UL;
 557:../GPIO.h     **** }
 558:../GPIO.h     **** 
 559:../GPIO.h     **** __STATIC_INLINE void P0_12_set(void){
 560:../GPIO.h     ****     PORT0->OMR = 0x00001000UL;
 561:../GPIO.h     **** }
 562:../GPIO.h     **** 
 563:../GPIO.h     **** __STATIC_INLINE void P0_12_reset(void){
 564:../GPIO.h     ****     PORT0->OMR = 0x10000000UL;
 565:../GPIO.h     **** }
 566:../GPIO.h     **** 
 567:../GPIO.h     **** __STATIC_INLINE void P0_12_toggle(void){
 568:../GPIO.h     ****     PORT0->OMR = 0x10001000UL;
 569:../GPIO.h     **** }
 570:../GPIO.h     **** 
 571:../GPIO.h     **** __STATIC_INLINE uint32_t P0_12_read(void){
 572:../GPIO.h     ****     return(PORT0->IN & 0x00001000UL);
 573:../GPIO.h     **** }
 574:../GPIO.h     **** 
 575:../GPIO.h     **** __STATIC_INLINE void P0_12_enable_pps(void){
 576:../GPIO.h     ****     PORT0->PPS |= 0x00001000UL;
 577:../GPIO.h     **** }
 578:../GPIO.h     **** 
 579:../GPIO.h     **** __STATIC_INLINE void P0_12_disable_pps(void){
 580:../GPIO.h     ****     PORT0->PPS &= ~0x00001000UL;
 581:../GPIO.h     **** }
 582:../GPIO.h     **** 
 583:../GPIO.h     **** __STATIC_INLINE void P0_13_set_mode(uint8_t mode){
 584:../GPIO.h     ****     PORT0->IOCR12 &= ~0x0000f800UL;
 585:../GPIO.h     ****     PORT0->IOCR12 |= mode << 8;
 586:../GPIO.h     **** }
 587:../GPIO.h     **** 
 588:../GPIO.h     **** __STATIC_INLINE void P0_13_set_hwsel(uint32_t config){
 589:../GPIO.h     ****     PORT0->HWSEL &= ~0x0c000000UL;
 590:../GPIO.h     ****     PORT0->HWSEL |= config << 26;
 591:../GPIO.h     **** }
 592:../GPIO.h     **** 
 593:../GPIO.h     **** __STATIC_INLINE void P0_13_set_standard_hysteresis(){
 594:../GPIO.h     ****     PORT0->PHCR1 &= ~0x00400000UL;
 595:../GPIO.h     **** }
 596:../GPIO.h     **** 
 597:../GPIO.h     **** __STATIC_INLINE void P0_13_set_large_hysteresis(){
 598:../GPIO.h     ****     PORT0->PHCR1 |= 0x00400000UL;
 599:../GPIO.h     **** }
 600:../GPIO.h     **** 
 601:../GPIO.h     **** __STATIC_INLINE void P0_13_set(void){
 602:../GPIO.h     ****     PORT0->OMR = 0x00002000UL;
 603:../GPIO.h     **** }
 604:../GPIO.h     **** 
 605:../GPIO.h     **** __STATIC_INLINE void P0_13_reset(void){
 606:../GPIO.h     ****     PORT0->OMR = 0x20000000UL;
 607:../GPIO.h     **** }
 608:../GPIO.h     **** 
 609:../GPIO.h     **** __STATIC_INLINE void P0_13_toggle(void){
 610:../GPIO.h     ****     PORT0->OMR = 0x20002000UL;
 611:../GPIO.h     **** }
 612:../GPIO.h     **** 
 613:../GPIO.h     **** __STATIC_INLINE uint32_t P0_13_read(void){
 614:../GPIO.h     ****     return(PORT0->IN & 0x00002000UL);
 615:../GPIO.h     **** }
 616:../GPIO.h     **** 
 617:../GPIO.h     **** __STATIC_INLINE void P0_13_enable_pps(void){
 618:../GPIO.h     ****     PORT0->PPS |= 0x00002000UL;
 619:../GPIO.h     **** }
 620:../GPIO.h     **** 
 621:../GPIO.h     **** __STATIC_INLINE void P0_13_disable_pps(void){
 622:../GPIO.h     ****     PORT0->PPS &= ~0x00002000UL;
 623:../GPIO.h     **** }
 624:../GPIO.h     **** 
 625:../GPIO.h     **** __STATIC_INLINE void P0_14_set_mode(uint8_t mode){
 626:../GPIO.h     ****     PORT0->IOCR12 &= ~0x00f80000UL;
 627:../GPIO.h     ****     PORT0->IOCR12 |= mode << 16;
 628:../GPIO.h     **** }
 629:../GPIO.h     **** 
 630:../GPIO.h     **** __STATIC_INLINE void P0_14_set_hwsel(uint32_t config){
 631:../GPIO.h     ****     PORT0->HWSEL &= ~0x30000000UL;
 632:../GPIO.h     ****     PORT0->HWSEL |= config << 28;
 633:../GPIO.h     **** }
 634:../GPIO.h     **** 
 635:../GPIO.h     **** __STATIC_INLINE void P0_14_set_standard_hysteresis(){
 636:../GPIO.h     ****     PORT0->PHCR1 &= ~0x04000000UL;
 637:../GPIO.h     **** }
 638:../GPIO.h     **** 
 639:../GPIO.h     **** __STATIC_INLINE void P0_14_set_large_hysteresis(){
 640:../GPIO.h     ****     PORT0->PHCR1 |= 0x04000000UL;
 641:../GPIO.h     **** }
 642:../GPIO.h     **** 
 643:../GPIO.h     **** __STATIC_INLINE void P0_14_set(void){
 644:../GPIO.h     ****     PORT0->OMR = 0x00004000UL;
 645:../GPIO.h     **** }
 646:../GPIO.h     **** 
 647:../GPIO.h     **** __STATIC_INLINE void P0_14_reset(void){
 648:../GPIO.h     ****     PORT0->OMR = 0x40000000UL;
 649:../GPIO.h     **** }
 650:../GPIO.h     **** 
 651:../GPIO.h     **** __STATIC_INLINE void P0_14_toggle(void){
 652:../GPIO.h     ****     PORT0->OMR = 0x40004000UL;
 653:../GPIO.h     **** }
 654:../GPIO.h     **** 
 655:../GPIO.h     **** __STATIC_INLINE uint32_t P0_14_read(void){
 656:../GPIO.h     ****     return(PORT0->IN & 0x00004000UL);
 657:../GPIO.h     **** }
 658:../GPIO.h     **** 
 659:../GPIO.h     **** __STATIC_INLINE void P0_14_enable_pps(void){
 660:../GPIO.h     ****     PORT0->PPS |= 0x00004000UL;
 661:../GPIO.h     **** }
 662:../GPIO.h     **** 
 663:../GPIO.h     **** __STATIC_INLINE void P0_14_disable_pps(void){
 664:../GPIO.h     ****     PORT0->PPS &= ~0x00004000UL;
 665:../GPIO.h     **** }
 666:../GPIO.h     **** 
 667:../GPIO.h     **** __STATIC_INLINE void P0_15_set_mode(uint8_t mode){
 668:../GPIO.h     ****     PORT0->IOCR12 &= ~0xf8000000UL;
 669:../GPIO.h     ****     PORT0->IOCR12 |= mode << 24;
 670:../GPIO.h     **** }
 671:../GPIO.h     **** 
 672:../GPIO.h     **** __STATIC_INLINE void P0_15_set_hwsel(uint32_t config){
 673:../GPIO.h     ****     PORT0->HWSEL &= ~0xc0000000UL;
 674:../GPIO.h     ****     PORT0->HWSEL |= config << 30;
 675:../GPIO.h     **** }
 676:../GPIO.h     **** 
 677:../GPIO.h     **** __STATIC_INLINE void P0_15_set_standard_hysteresis(){
 678:../GPIO.h     ****     PORT0->PHCR1 &= ~0x40000000UL;
 679:../GPIO.h     **** }
 680:../GPIO.h     **** 
 681:../GPIO.h     **** __STATIC_INLINE void P0_15_set_large_hysteresis(){
 682:../GPIO.h     ****     PORT0->PHCR1 |= 0x40000000UL;
 683:../GPIO.h     **** }
 684:../GPIO.h     **** 
 685:../GPIO.h     **** __STATIC_INLINE void P0_15_set(void){
 686:../GPIO.h     ****     PORT0->OMR = 0x00008000UL;
 687:../GPIO.h     **** }
 688:../GPIO.h     **** 
 689:../GPIO.h     **** __STATIC_INLINE void P0_15_reset(void){
 690:../GPIO.h     ****     PORT0->OMR = 0x80000000UL;
 691:../GPIO.h     **** }
 692:../GPIO.h     **** 
 693:../GPIO.h     **** __STATIC_INLINE void P0_15_toggle(void){
 694:../GPIO.h     ****     PORT0->OMR = 0x80008000UL;
 695:../GPIO.h     **** }
 696:../GPIO.h     **** 
 697:../GPIO.h     **** __STATIC_INLINE uint32_t P0_15_read(void){
 698:../GPIO.h     ****     return(PORT0->IN & 0x00008000UL);
 699:../GPIO.h     **** }
 700:../GPIO.h     **** 
 701:../GPIO.h     **** __STATIC_INLINE void P0_15_enable_pps(void){
 702:../GPIO.h     ****     PORT0->PPS |= 0x00008000UL;
 703:../GPIO.h     **** }
 704:../GPIO.h     **** 
 705:../GPIO.h     **** __STATIC_INLINE void P0_15_disable_pps(void){
 706:../GPIO.h     ****     PORT0->PPS &= ~0x00008000UL;
 707:../GPIO.h     **** }
 708:../GPIO.h     **** 
 709:../GPIO.h     **** __STATIC_INLINE void P1_0_set_mode(uint8_t mode){
 710:../GPIO.h     ****     PORT1->IOCR0 &= ~0x000000f8UL;
 711:../GPIO.h     ****     PORT1->IOCR0 |= mode << 0;
 712:../GPIO.h     **** }
 713:../GPIO.h     **** 
 714:../GPIO.h     **** __STATIC_INLINE void P1_0_set_hwsel(uint32_t config){
 715:../GPIO.h     ****     PORT1->HWSEL &= ~0x00000003UL;
 716:../GPIO.h     ****     PORT1->HWSEL |= config << 0;
 717:../GPIO.h     **** }
 718:../GPIO.h     **** 
 719:../GPIO.h     **** __STATIC_INLINE void P1_0_set_standard_hysteresis(){
 720:../GPIO.h     ****     PORT1->PHCR0 &= ~0x00000004UL;
 721:../GPIO.h     **** }
 722:../GPIO.h     **** 
 723:../GPIO.h     **** __STATIC_INLINE void P1_0_set_large_hysteresis(){
 724:../GPIO.h     ****     PORT1->PHCR0 |= 0x00000004UL;
 725:../GPIO.h     **** }
 726:../GPIO.h     **** 
 727:../GPIO.h     **** __STATIC_INLINE void P1_0_set(void){
 728:../GPIO.h     ****     PORT1->OMR = 0x00000001UL;
 729:../GPIO.h     **** }
 730:../GPIO.h     **** 
 731:../GPIO.h     **** __STATIC_INLINE void P1_0_reset(void){
 732:../GPIO.h     ****     PORT1->OMR = 0x00010000UL;
 733:../GPIO.h     **** }
 734:../GPIO.h     **** 
 735:../GPIO.h     **** __STATIC_INLINE void P1_0_toggle(void){
 736:../GPIO.h     ****     PORT1->OMR = 0x00010001UL;
 737:../GPIO.h     **** }
 738:../GPIO.h     **** 
 739:../GPIO.h     **** __STATIC_INLINE uint32_t P1_0_read(void){
 740:../GPIO.h     ****     return(PORT1->IN & 0x00000001UL);
 741:../GPIO.h     **** }
 742:../GPIO.h     **** 
 743:../GPIO.h     **** __STATIC_INLINE void P1_0_enable_pps(void){
 744:../GPIO.h     ****     PORT1->PPS |= 0x00000001UL;
 745:../GPIO.h     **** }
 746:../GPIO.h     **** 
 747:../GPIO.h     **** __STATIC_INLINE void P1_0_disable_pps(void){
 748:../GPIO.h     ****     PORT1->PPS &= ~0x00000001UL;
 749:../GPIO.h     **** }
 750:../GPIO.h     **** 
 751:../GPIO.h     **** __STATIC_INLINE void P1_1_set_mode(uint8_t mode){
 752:../GPIO.h     ****     PORT1->IOCR0 &= ~0x0000f800UL;
 753:../GPIO.h     ****     PORT1->IOCR0 |= mode << 8;
 754:../GPIO.h     **** }
 755:../GPIO.h     **** 
 756:../GPIO.h     **** __STATIC_INLINE void P1_1_set_hwsel(uint32_t config){
 757:../GPIO.h     ****     PORT1->HWSEL &= ~0x0000000cUL;
 758:../GPIO.h     ****     PORT1->HWSEL |= config << 2;
 759:../GPIO.h     **** }
 760:../GPIO.h     **** 
 761:../GPIO.h     **** __STATIC_INLINE void P1_1_set_standard_hysteresis(){
 762:../GPIO.h     ****     PORT1->PHCR0 &= ~0x00000040UL;
 763:../GPIO.h     **** }
 764:../GPIO.h     **** 
 765:../GPIO.h     **** __STATIC_INLINE void P1_1_set_large_hysteresis(){
 766:../GPIO.h     ****     PORT1->PHCR0 |= 0x00000040UL;
 767:../GPIO.h     **** }
 768:../GPIO.h     **** 
 769:../GPIO.h     **** __STATIC_INLINE void P1_1_set(void){
 770:../GPIO.h     ****     PORT1->OMR = 0x00000002UL;
 771:../GPIO.h     **** }
 772:../GPIO.h     **** 
 773:../GPIO.h     **** __STATIC_INLINE void P1_1_reset(void){
 774:../GPIO.h     ****     PORT1->OMR = 0x00020000UL;
 775:../GPIO.h     **** }
 776:../GPIO.h     **** 
 777:../GPIO.h     **** __STATIC_INLINE void P1_1_toggle(void){
 778:../GPIO.h     ****     PORT1->OMR = 0x00020002UL;
 779:../GPIO.h     **** }
 780:../GPIO.h     **** 
 781:../GPIO.h     **** __STATIC_INLINE uint32_t P1_1_read(void){
 782:../GPIO.h     ****     return(PORT1->IN & 0x00000002UL);
 783:../GPIO.h     **** }
 784:../GPIO.h     **** 
 785:../GPIO.h     **** __STATIC_INLINE void P1_1_enable_pps(void){
 786:../GPIO.h     ****     PORT1->PPS |= 0x00000002UL;
 787:../GPIO.h     **** }
 788:../GPIO.h     **** 
 789:../GPIO.h     **** __STATIC_INLINE void P1_1_disable_pps(void){
 790:../GPIO.h     ****     PORT1->PPS &= ~0x00000002UL;
 791:../GPIO.h     **** }
 792:../GPIO.h     **** 
 793:../GPIO.h     **** __STATIC_INLINE void P1_2_set_mode(uint8_t mode){
 794:../GPIO.h     ****     PORT1->IOCR0 &= ~0x00f80000UL;
 795:../GPIO.h     ****     PORT1->IOCR0 |= mode << 16;
 796:../GPIO.h     **** }
 797:../GPIO.h     **** 
 798:../GPIO.h     **** __STATIC_INLINE void P1_2_set_hwsel(uint32_t config){
 799:../GPIO.h     ****     PORT1->HWSEL &= ~0x00000030UL;
 800:../GPIO.h     ****     PORT1->HWSEL |= config << 4;
 801:../GPIO.h     **** }
 802:../GPIO.h     **** 
 803:../GPIO.h     **** __STATIC_INLINE void P1_2_set_standard_hysteresis(){
 804:../GPIO.h     ****     PORT1->PHCR0 &= ~0x00000400UL;
 805:../GPIO.h     **** }
 806:../GPIO.h     **** 
 807:../GPIO.h     **** __STATIC_INLINE void P1_2_set_large_hysteresis(){
 808:../GPIO.h     ****     PORT1->PHCR0 |= 0x00000400UL;
 809:../GPIO.h     **** }
 810:../GPIO.h     **** 
 811:../GPIO.h     **** __STATIC_INLINE void P1_2_set(void){
 812:../GPIO.h     ****     PORT1->OMR = 0x00000004UL;
 813:../GPIO.h     **** }
 814:../GPIO.h     **** 
 815:../GPIO.h     **** __STATIC_INLINE void P1_2_reset(void){
 816:../GPIO.h     ****     PORT1->OMR = 0x00040000UL;
 817:../GPIO.h     **** }
 818:../GPIO.h     **** 
 819:../GPIO.h     **** __STATIC_INLINE void P1_2_toggle(void){
 820:../GPIO.h     ****     PORT1->OMR = 0x00040004UL;
 821:../GPIO.h     **** }
 822:../GPIO.h     **** 
 823:../GPIO.h     **** __STATIC_INLINE uint32_t P1_2_read(void){
 824:../GPIO.h     ****     return(PORT1->IN & 0x00000004UL);
 825:../GPIO.h     **** }
 826:../GPIO.h     **** 
 827:../GPIO.h     **** __STATIC_INLINE void P1_2_enable_pps(void){
 828:../GPIO.h     ****     PORT1->PPS |= 0x00000004UL;
 829:../GPIO.h     **** }
 830:../GPIO.h     **** 
 831:../GPIO.h     **** __STATIC_INLINE void P1_2_disable_pps(void){
 832:../GPIO.h     ****     PORT1->PPS &= ~0x00000004UL;
 833:../GPIO.h     **** }
 834:../GPIO.h     **** 
 835:../GPIO.h     **** __STATIC_INLINE void P1_3_set_mode(uint8_t mode){
 836:../GPIO.h     ****     PORT1->IOCR0 &= ~0xf8000000UL;
 837:../GPIO.h     ****     PORT1->IOCR0 |= mode << 24;
 838:../GPIO.h     **** }
 839:../GPIO.h     **** 
 840:../GPIO.h     **** __STATIC_INLINE void P1_3_set_hwsel(uint32_t config){
 841:../GPIO.h     ****     PORT1->HWSEL &= ~0x000000c0UL;
 842:../GPIO.h     ****     PORT1->HWSEL |= config << 6;
 843:../GPIO.h     **** }
 844:../GPIO.h     **** 
 845:../GPIO.h     **** __STATIC_INLINE void P1_3_set_standard_hysteresis(){
 846:../GPIO.h     ****     PORT1->PHCR0 &= ~0x00004000UL;
 847:../GPIO.h     **** }
 848:../GPIO.h     **** 
 849:../GPIO.h     **** __STATIC_INLINE void P1_3_set_large_hysteresis(){
 850:../GPIO.h     ****     PORT1->PHCR0 |= 0x00004000UL;
 851:../GPIO.h     **** }
 852:../GPIO.h     **** 
 853:../GPIO.h     **** __STATIC_INLINE void P1_3_set(void){
 854:../GPIO.h     ****     PORT1->OMR = 0x00000008UL;
 855:../GPIO.h     **** }
 856:../GPIO.h     **** 
 857:../GPIO.h     **** __STATIC_INLINE void P1_3_reset(void){
 858:../GPIO.h     ****     PORT1->OMR = 0x00080000UL;
 859:../GPIO.h     **** }
 860:../GPIO.h     **** 
 861:../GPIO.h     **** __STATIC_INLINE void P1_3_toggle(void){
 862:../GPIO.h     ****     PORT1->OMR = 0x00080008UL;
 863:../GPIO.h     **** }
 864:../GPIO.h     **** 
 865:../GPIO.h     **** __STATIC_INLINE uint32_t P1_3_read(void){
 866:../GPIO.h     ****     return(PORT1->IN & 0x00000008UL);
 867:../GPIO.h     **** }
 868:../GPIO.h     **** 
 869:../GPIO.h     **** __STATIC_INLINE void P1_3_enable_pps(void){
 870:../GPIO.h     ****     PORT1->PPS |= 0x00000008UL;
 871:../GPIO.h     **** }
 872:../GPIO.h     **** 
 873:../GPIO.h     **** __STATIC_INLINE void P1_3_disable_pps(void){
 874:../GPIO.h     ****     PORT1->PPS &= ~0x00000008UL;
 875:../GPIO.h     **** }
 876:../GPIO.h     **** 
 877:../GPIO.h     **** __STATIC_INLINE void P1_4_set_mode(uint8_t mode){
 264              		.loc 1 877 0
 265              		.cfi_startproc
 266 0000 80B5     		push	{r7, lr}
 267              	.LCFI14:
 268              		.cfi_def_cfa_offset 8
 269              		.cfi_offset 7, -8
 270              		.cfi_offset 14, -4
 271 0002 82B0     		sub	sp, sp, #8
 272              	.LCFI15:
 273              		.cfi_def_cfa_offset 16
 274 0004 00AF     		add	r7, sp, #0
 275              	.LCFI16:
 276              		.cfi_def_cfa_register 7
 277 0006 021C     		mov	r2, r0
 278 0008 FB1D     		add	r3, r7, #7
 279 000a 1A70     		strb	r2, [r3]
 878:../GPIO.h     ****     PORT1->IOCR4 &= ~0x000000f8UL;
 280              		.loc 1 878 0
 281 000c 074B     		ldr	r3, .L21
 282 000e 074A     		ldr	r2, .L21
 283 0010 5269     		ldr	r2, [r2, #20]
 284 0012 F821     		mov	r1, #248
 285 0014 8A43     		bic	r2, r1
 286 0016 5A61     		str	r2, [r3, #20]
 879:../GPIO.h     ****     PORT1->IOCR4 |= mode << 0;
 287              		.loc 1 879 0
 288 0018 044B     		ldr	r3, .L21
 289 001a 044A     		ldr	r2, .L21
 290 001c 5169     		ldr	r1, [r2, #20]
 291 001e FA1D     		add	r2, r7, #7
 292 0020 1278     		ldrb	r2, [r2]
 293 0022 0A43     		orr	r2, r1
 294 0024 5A61     		str	r2, [r3, #20]
 880:../GPIO.h     **** }
 295              		.loc 1 880 0
 296 0026 BD46     		mov	sp, r7
 297 0028 02B0     		add	sp, sp, #8
 298              		@ sp needed for prologue
 299 002a 80BD     		pop	{r7, pc}
 300              	.L22:
 301              		.align	2
 302              	.L21:
 303 002c 00010440 		.word	1074004224
 304              		.cfi_endproc
 305              	.LFE238:
 307              		.section	.text.P1_4_set_large_hysteresis,"ax",%progbits
 308              		.align	2
 309              		.code	16
 310              		.thumb_func
 312              	P1_4_set_large_hysteresis:
 313              	.LFB241:
 881:../GPIO.h     **** 
 882:../GPIO.h     **** __STATIC_INLINE void P1_4_set_hwsel(uint32_t config){
 883:../GPIO.h     ****     PORT1->HWSEL &= ~0x00000300UL;
 884:../GPIO.h     ****     PORT1->HWSEL |= config << 8;
 885:../GPIO.h     **** }
 886:../GPIO.h     **** 
 887:../GPIO.h     **** __STATIC_INLINE void P1_4_set_standard_hysteresis(){
 888:../GPIO.h     ****     PORT1->PHCR0 &= ~0x00040000UL;
 889:../GPIO.h     **** }
 890:../GPIO.h     **** 
 891:../GPIO.h     **** __STATIC_INLINE void P1_4_set_large_hysteresis(){
 314              		.loc 1 891 0
 315              		.cfi_startproc
 316 0000 80B5     		push	{r7, lr}
 317              	.LCFI17:
 318              		.cfi_def_cfa_offset 8
 319              		.cfi_offset 7, -8
 320              		.cfi_offset 14, -4
 321 0002 00AF     		add	r7, sp, #0
 322              	.LCFI18:
 323              		.cfi_def_cfa_register 7
 892:../GPIO.h     ****     PORT1->PHCR0 |= 0x00040000UL;
 324              		.loc 1 892 0
 325 0004 044B     		ldr	r3, .L24
 326 0006 044A     		ldr	r2, .L24
 327 0008 126C     		ldr	r2, [r2, #64]
 328 000a 8021     		mov	r1, #128
 329 000c C902     		lsl	r1, r1, #11
 330 000e 0A43     		orr	r2, r1
 331 0010 1A64     		str	r2, [r3, #64]
 893:../GPIO.h     **** }
 332              		.loc 1 893 0
 333 0012 BD46     		mov	sp, r7
 334              		@ sp needed for prologue
 335 0014 80BD     		pop	{r7, pc}
 336              	.L25:
 337 0016 C046     		.align	2
 338              	.L24:
 339 0018 00010440 		.word	1074004224
 340              		.cfi_endproc
 341              	.LFE241:
 343              		.section	.text.P1_4_read,"ax",%progbits
 344              		.align	2
 345              		.code	16
 346              		.thumb_func
 348              	P1_4_read:
 349              	.LFB245:
 894:../GPIO.h     **** 
 895:../GPIO.h     **** __STATIC_INLINE void P1_4_set(void){
 896:../GPIO.h     ****     PORT1->OMR = 0x00000010UL;
 897:../GPIO.h     **** }
 898:../GPIO.h     **** 
 899:../GPIO.h     **** __STATIC_INLINE void P1_4_reset(void){
 900:../GPIO.h     ****     PORT1->OMR = 0x00100000UL;
 901:../GPIO.h     **** }
 902:../GPIO.h     **** 
 903:../GPIO.h     **** __STATIC_INLINE void P1_4_toggle(void){
 904:../GPIO.h     ****     PORT1->OMR = 0x00100010UL;
 905:../GPIO.h     **** }
 906:../GPIO.h     **** 
 907:../GPIO.h     **** __STATIC_INLINE uint32_t P1_4_read(void){
 350              		.loc 1 907 0
 351              		.cfi_startproc
 352 0000 80B5     		push	{r7, lr}
 353              	.LCFI19:
 354              		.cfi_def_cfa_offset 8
 355              		.cfi_offset 7, -8
 356              		.cfi_offset 14, -4
 357 0002 00AF     		add	r7, sp, #0
 358              	.LCFI20:
 359              		.cfi_def_cfa_register 7
 908:../GPIO.h     ****     return(PORT1->IN & 0x00000010UL);
 360              		.loc 1 908 0
 361 0004 034B     		ldr	r3, .L28
 362 0006 5A6A     		ldr	r2, [r3, #36]
 363 0008 1023     		mov	r3, #16
 364 000a 1340     		and	r3, r2
 909:../GPIO.h     **** }
 365              		.loc 1 909 0
 366 000c 181C     		mov	r0, r3
 367 000e BD46     		mov	sp, r7
 368              		@ sp needed for prologue
 369 0010 80BD     		pop	{r7, pc}
 370              	.L29:
 371 0012 C046     		.align	2
 372              	.L28:
 373 0014 00010440 		.word	1074004224
 374              		.cfi_endproc
 375              	.LFE245:
 377              		.global	__aeabi_idiv
 378              		.section	.text.main,"ax",%progbits
 379              		.align	2
 380              		.global	main
 381              		.code	16
 382              		.thumb_func
 384              	main:
 385              	.LFB402:
 386              		.file 2 "../Main.c"
   1:../Main.c     **** /*=========================================================================== *
   2:../Main.c     ****  * Copyright (c) 2014, Infineon Technologies AG                                *
   3:../Main.c     ****  * All rights reserved.                                                        *
   4:../Main.c     ****  *                                                                             *
   5:../Main.c     ****  * Redistribution and use in source and binary forms, with or without          *
   6:../Main.c     ****  * modification, are permitted provided that the following conditions are met: *
   7:../Main.c     ****  * Redistributions of source code must retain the above copyright notice, this *
   8:../Main.c     ****  * list of conditions and the following disclaimer. Redistributions in binary  *
   9:../Main.c     ****  * form must reproduce the above copyright notice, this list of conditions and *
  10:../Main.c     ****  * the following disclaimer in the documentation and/or other materials        *
  11:../Main.c     ****  * provided with the distribution. Neither the name of the copyright holders   *
  12:../Main.c     ****  * nor the names of its contributors may be used to endorse or promote         *
  13:../Main.c     ****  * products derived from this software without specific prior written          *
  14:../Main.c     ****  * permission.                                                                 *
  15:../Main.c     ****  *                                                                                                 
  16:../Main.c     ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" *
  17:../Main.c     ****  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,       *
  18:../Main.c     ****  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR      *
  19:../Main.c     ****  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR           *
  20:../Main.c     ****  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,       *
  21:../Main.c     ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,         *
  22:../Main.c     ****  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; *
  23:../Main.c     ****  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,    *
  24:../Main.c     ****  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR     *
  25:../Main.c     ****  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF      *
  26:../Main.c     ****  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                                  *
  27:../Main.c     ****  * To improve the quality of the software, users are encouraged to share       *
  28:../Main.c     ****  * modifications, enhancements or bug fixes with                               *
  29:../Main.c     ****  * Infineon Technologies AG (dave@infineon.com).                               *
  30:../Main.c     ****  *                                                                             *
  31:../Main.c     ****  * ========================================================================== */
  32:../Main.c     **** 
  33:../Main.c     **** /********************************************************************************
  34:../Main.c     **** **                                                                            **
  35:../Main.c     **** ** PLATFORM : Infineon XMC1000 Series                                         **
  36:../Main.c     **** **                                                                            **
  37:../Main.c     **** ** AUTHOR : Application Engineering Team                                      **
  38:../Main.c     **** **                                                                            **
  39:../Main.c     **** ** Project version update to v 1.0.0 (Initial version)                        **
  40:../Main.c     **** **                           v 1.0.2 (Updated with latest Dave apps,linker and**
  41:../Main.c     **** **                                    startup files)                          **
  42:../Main.c     **** **                                                                            **
  43:../Main.c     **** ** MODIFICATION DATE : May 27, 2014                                           **
  44:../Main.c     **** **                                                                            **
  45:../Main.c     **** *******************************************************************************/
  46:../Main.c     **** 
  47:../Main.c     **** 
  48:../Main.c     **** /*
  49:../Main.c     ****  *  Main source file for this PWMSP001 demo. This file contains the main
  50:../Main.c     ****  *  tasks of the demo and is responsible for the initial application hardware
  51:../Main.c     ****  *  configuration
  52:../Main.c     ****  */
  53:../Main.c     **** 
  54:../Main.c     **** /*******************************************************************************
  55:../Main.c     ****  ** INCLUDE FILES                                                             **
  56:../Main.c     ****  ******************************************************************************/
  57:../Main.c     **** 
  58:../Main.c     **** #include <DAVE3.h>			//Declarations from DAVE3 Code Generation
  59:../Main.c     **** #include "XMC1100.h"
  60:../Main.c     **** #include "GPIO.h"
  61:../Main.c     **** 
  62:../Main.c     **** 
  63:../Main.c     **** #define PIN_SW_HIGH()      P1_4_read()
  64:../Main.c     **** #define PIN_IS_HIGH()      P0_6_read()
  65:../Main.c     **** #define PIN_LOW_DEASSERT() P0_5_set()
  66:../Main.c     **** #define PIN_LOW_ASSERT()   P0_5_reset()
  67:../Main.c     **** #define PIN_LOW_TOGGLE()   P0_5_toggle()
  68:../Main.c     **** 
  69:../Main.c     **** #define PIN_LOW_INIT() \
  70:../Main.c     **** 	P0_5_set_mode(OUTPUT_OD_GP); \
  71:../Main.c     **** 	P0_5_set();
  72:../Main.c     **** 
  73:../Main.c     **** #define PIN_IS_INIT() \
  74:../Main.c     ****     P0_6_set_mode(INPUT_PU); \
  75:../Main.c     **** 	P0_6_set_large_hysteresis(); \
  76:../Main.c     **** 	P0_6_read(); \
  77:../Main.c     **** 
  78:../Main.c     **** #define PIN_SW_INIT() \
  79:../Main.c     ****     P1_4_set_mode(INPUT_PU); \
  80:../Main.c     **** 	P1_4_set_large_hysteresis(); \
  81:../Main.c     **** 	P1_4_read(); \
  82:../Main.c     **** 
  83:../Main.c     **** 
  84:../Main.c     **** 
  85:../Main.c     **** 
  86:../Main.c     **** int main(void)
  87:../Main.c     **** {
 387              		.loc 2 87 0
 388              		.cfi_startproc
 389 0000 80B5     		push	{r7, lr}
 390              	.LCFI21:
 391              		.cfi_def_cfa_offset 8
 392              		.cfi_offset 7, -8
 393              		.cfi_offset 14, -4
 394 0002 8AB0     		sub	sp, sp, #40
 395              	.LCFI22:
 396              		.cfi_def_cfa_offset 48
 397 0004 00AF     		add	r7, sp, #0
 398              	.LCFI23:
 399              		.cfi_def_cfa_register 7
  88:../Main.c     **** 	//status_t status;		// Declaration of return variable for DAVE3 APIs
  89:../Main.c     **** 
  90:../Main.c     **** 
  91:../Main.c     **** 	DAVE_Init();			// Initialization of DAVE Apps
 400              		.loc 2 91 0
 401 0006 FFF7FEFF 		bl	DAVE_Init
  92:../Main.c     **** 
  93:../Main.c     **** 	//PWMSP001_Stop((PWMSP001_HandleType*)&PWMSP001_Handle0);
  94:../Main.c     **** 
  95:../Main.c     **** 	
  96:../Main.c     **** 	/* Starts the PWMSP001 App (LED)
  97:../Main.c     **** 	status = PWMSP001_Start((PWMSP001_HandleType*)&PWMSP001_Handle0);
  98:../Main.c     **** 	if(status != DAVEApp_SUCCESS)
  99:../Main.c     **** 	{
 100:../Main.c     **** 		PWMSP001_Stop((PWMSP001_HandleType*)&PWMSP001_Handle0);
 101:../Main.c     **** 	}*/
 102:../Main.c     **** 
 103:../Main.c     **** 	PIN_LOW_INIT();
 402              		.loc 2 103 0
 403 000a C020     		mov	r0, #192
 404 000c FFF7FEFF 		bl	P0_5_set_mode
 405 0010 FFF7FEFF 		bl	P0_5_set
 104:../Main.c     **** 	PIN_IS_INIT();
 406              		.loc 2 104 0
 407 0014 1020     		mov	r0, #16
 408 0016 FFF7FEFF 		bl	P0_6_set_mode
 409 001a FFF7FEFF 		bl	P0_6_set_large_hysteresis
 410 001e FFF7FEFF 		bl	P0_6_read
 105:../Main.c     **** 	PIN_SW_INIT();
 411              		.loc 2 105 0
 412 0022 1020     		mov	r0, #16
 413 0024 FFF7FEFF 		bl	P1_4_set_mode
 414 0028 FFF7FEFF 		bl	P1_4_set_large_hysteresis
 415 002c FFF7FEFF 		bl	P1_4_read
 106:../Main.c     **** 
 107:../Main.c     **** 	bool lastPinState = PIN_IS_HIGH();
 416              		.loc 2 107 0
 417 0030 FFF7FEFF 		bl	P0_6_read
 418 0034 021C     		mov	r2, r0
 419 0036 3B1C     		mov	r3, r7
 420 0038 2733     		add	r3, r3, #39
 421 003a 1A70     		strb	r2, [r3]
 108:../Main.c     **** 	bool trigger = FALSE;
 422              		.loc 2 108 0
 423 003c 3B1C     		mov	r3, r7
 424 003e 2633     		add	r3, r3, #38
 425 0040 0022     		mov	r2, #0
 426 0042 1A70     		strb	r2, [r3]
 109:../Main.c     **** 	int noTriggerCnt=0;
 427              		.loc 2 109 0
 428 0044 0023     		mov	r3, #0
 429 0046 3B62     		str	r3, [r7, #32]
 110:../Main.c     **** 	int speed=0;
 430              		.loc 2 110 0
 431 0048 0023     		mov	r3, #0
 432 004a FB61     		str	r3, [r7, #28]
 111:../Main.c     **** 	int speedLow=0;
 433              		.loc 2 111 0
 434 004c 0023     		mov	r3, #0
 435 004e BB61     		str	r3, [r7, #24]
 112:../Main.c     **** 	int speedLowHigh=0;
 436              		.loc 2 112 0
 437 0050 0023     		mov	r3, #0
 438 0052 7B61     		str	r3, [r7, #20]
 113:../Main.c     **** 
 114:../Main.c     **** 	int pinCheckCycles = 100;
 439              		.loc 2 114 0
 440 0054 6423     		mov	r3, #100
 441 0056 7B60     		str	r3, [r7, #4]
 442 0058 00E0     		b	.L44
 443              	.L45:
 115:../Main.c     **** 
 116:../Main.c     **** #ifdef DEBUG
 117:../Main.c     **** 
 118:../Main.c     **** #define DEBUG_CNT_BUFFER_SIZE 100
 119:../Main.c     **** 	static int debugCount = 0;
 120:../Main.c     **** 	static int debugSpeedBuffer[DEBUG_CNT_BUFFER_SIZE];
 121:../Main.c     **** #endif
 122:../Main.c     **** 
 123:../Main.c     **** 
 124:../Main.c     **** 
 125:../Main.c     **** 
 126:../Main.c     **** 	while(1)
 127:../Main.c     **** 	{
 128:../Main.c     **** 		speed++;
 129:../Main.c     **** 		speedLow++;
 130:../Main.c     **** 		
 131:../Main.c     **** 
 132:../Main.c     **** 		int cnt_high=0;
 133:../Main.c     **** 		int cnt_low=0;
 134:../Main.c     **** 		for (int i = 0; i < pinCheckCycles; i++)
 135:../Main.c     **** 		{
 136:../Main.c     **** 			if (PIN_IS_HIGH())
 137:../Main.c     **** 				cnt_high++;
 138:../Main.c     **** 			else
 139:../Main.c     **** 				cnt_low++;
 140:../Main.c     **** 		}
 141:../Main.c     **** 		
 142:../Main.c     **** 		
 143:../Main.c     **** 		if (cnt_low > 0)
 144:../Main.c     **** 		{
 145:../Main.c     **** 			if (lastPinState)
 146:../Main.c     **** 			{
 147:../Main.c     **** 				trigger = TRUE;
 148:../Main.c     **** 				if (PIN_SW_HIGH())
 149:../Main.c     **** 				{
 150:../Main.c     **** 					speedLowHigh =  (speed<<3)/10; // *16/10/2
 151:../Main.c     **** 				}
 152:../Main.c     **** 				else
 153:../Main.c     **** 				{
 154:../Main.c     **** 					speedLowHigh =  speed>>1; // /2
 155:../Main.c     **** 				}
 156:../Main.c     **** 
 157:../Main.c     **** #ifdef DEBUG
 158:../Main.c     **** 				debugSpeedBuffer[debugCount%DEBUG_CNT_BUFFER_SIZE] = speed;
 159:../Main.c     **** 				debugCount++;
 160:../Main.c     **** 				debugSpeedBuffer[debugCount%DEBUG_CNT_BUFFER_SIZE] = speedLowHigh;
 161:../Main.c     **** 				debugCount++;
 162:../Main.c     **** #endif
 163:../Main.c     **** 				speed=0;
 164:../Main.c     **** 
 165:../Main.c     **** 			}
 166:../Main.c     **** 			lastPinState = FALSE;
 167:../Main.c     **** 		}
 168:../Main.c     **** 		else if (cnt_high > 0)
 169:../Main.c     **** 		{
 170:../Main.c     **** 			lastPinState = TRUE;
 171:../Main.c     **** 		}
 172:../Main.c     **** 		
 173:../Main.c     **** 		if (speedLow >= speedLowHigh)
 174:../Main.c     **** 		{
 175:../Main.c     **** 			speedLow = 0;
 176:../Main.c     **** 			
 177:../Main.c     **** 			if (!trigger)
 178:../Main.c     **** 				noTriggerCnt++;
 179:../Main.c     **** 			else
 180:../Main.c     **** 				noTriggerCnt=0;
 181:../Main.c     **** 			trigger = FALSE;
 182:../Main.c     **** 			
 183:../Main.c     **** 			if (noTriggerCnt > 1)
 184:../Main.c     **** 			{
 185:../Main.c     **** 				noTriggerCnt=1;
 186:../Main.c     **** 				PIN_LOW_DEASSERT();
 187:../Main.c     **** 			}
 188:../Main.c     **** 			else
 189:../Main.c     **** 			{
 190:../Main.c     **** 				PIN_LOW_TOGGLE();
 191:../Main.c     **** 			}
 192:../Main.c     **** 		}
 193:../Main.c     **** 
 194:../Main.c     **** 	}
 444              		.loc 2 194 0
 445 005a C046     		mov	r8, r8
 446              	.L44:
 447              	.LBB2:
 128:../Main.c     **** 		speed++;
 448              		.loc 2 128 0
 449 005c FB69     		ldr	r3, [r7, #28]
 450 005e 0133     		add	r3, r3, #1
 451 0060 FB61     		str	r3, [r7, #28]
 129:../Main.c     **** 		speedLow++;
 452              		.loc 2 129 0
 453 0062 BB69     		ldr	r3, [r7, #24]
 454 0064 0133     		add	r3, r3, #1
 455 0066 BB61     		str	r3, [r7, #24]
 132:../Main.c     **** 		int cnt_high=0;
 456              		.loc 2 132 0
 457 0068 0023     		mov	r3, #0
 458 006a 3B61     		str	r3, [r7, #16]
 133:../Main.c     **** 		int cnt_low=0;
 459              		.loc 2 133 0
 460 006c 0023     		mov	r3, #0
 461 006e FB60     		str	r3, [r7, #12]
 462              	.LBB3:
 134:../Main.c     **** 		for (int i = 0; i < pinCheckCycles; i++)
 463              		.loc 2 134 0
 464 0070 0023     		mov	r3, #0
 465 0072 BB60     		str	r3, [r7, #8]
 466 0074 0EE0     		b	.L31
 467              	.L34:
 136:../Main.c     **** 			if (PIN_IS_HIGH())
 468              		.loc 2 136 0
 469 0076 FFF7FEFF 		bl	P0_6_read
 470 007a 031C     		mov	r3, r0
 471 007c 002B     		cmp	r3, #0
 472 007e 03D0     		beq	.L32
 137:../Main.c     **** 				cnt_high++;
 473              		.loc 2 137 0
 474 0080 3B69     		ldr	r3, [r7, #16]
 475 0082 0133     		add	r3, r3, #1
 476 0084 3B61     		str	r3, [r7, #16]
 477 0086 02E0     		b	.L33
 478              	.L32:
 139:../Main.c     **** 				cnt_low++;
 479              		.loc 2 139 0
 480 0088 FB68     		ldr	r3, [r7, #12]
 481 008a 0133     		add	r3, r3, #1
 482 008c FB60     		str	r3, [r7, #12]
 483              	.L33:
 134:../Main.c     **** 		for (int i = 0; i < pinCheckCycles; i++)
 484              		.loc 2 134 0
 485 008e BB68     		ldr	r3, [r7, #8]
 486 0090 0133     		add	r3, r3, #1
 487 0092 BB60     		str	r3, [r7, #8]
 488              	.L31:
 134:../Main.c     **** 		for (int i = 0; i < pinCheckCycles; i++)
 489              		.loc 2 134 0 is_stmt 0 discriminator 1
 490 0094 BA68     		ldr	r2, [r7, #8]
 491 0096 7B68     		ldr	r3, [r7, #4]
 492 0098 9A42     		cmp	r2, r3
 493 009a ECDB     		blt	.L34
 494              	.LBE3:
 143:../Main.c     **** 		if (cnt_low > 0)
 495              		.loc 2 143 0 is_stmt 1
 496 009c FB68     		ldr	r3, [r7, #12]
 497 009e 002B     		cmp	r3, #0
 498 00a0 20DD     		ble	.L35
 145:../Main.c     **** 			if (lastPinState)
 499              		.loc 2 145 0
 500 00a2 3B1C     		mov	r3, r7
 501 00a4 2733     		add	r3, r3, #39
 502 00a6 1B78     		ldrb	r3, [r3]
 503 00a8 002B     		cmp	r3, #0
 504 00aa 16D0     		beq	.L36
 147:../Main.c     **** 				trigger = TRUE;
 505              		.loc 2 147 0
 506 00ac 3B1C     		mov	r3, r7
 507 00ae 2633     		add	r3, r3, #38
 508 00b0 0122     		mov	r2, #1
 509 00b2 1A70     		strb	r2, [r3]
 148:../Main.c     **** 				if (PIN_SW_HIGH())
 510              		.loc 2 148 0
 511 00b4 FFF7FEFF 		bl	P1_4_read
 512 00b8 031C     		mov	r3, r0
 513 00ba 002B     		cmp	r3, #0
 514 00bc 08D0     		beq	.L37
 150:../Main.c     **** 					speedLowHigh =  (speed<<3)/10; // *16/10/2
 515              		.loc 2 150 0
 516 00be FB69     		ldr	r3, [r7, #28]
 517 00c0 DB00     		lsl	r3, r3, #3
 518 00c2 181C     		mov	r0, r3
 519 00c4 0A21     		mov	r1, #10
 520 00c6 FFF7FEFF 		bl	__aeabi_idiv
 521 00ca 031C     		mov	r3, r0
 522 00cc 7B61     		str	r3, [r7, #20]
 523 00ce 02E0     		b	.L38
 524              	.L37:
 154:../Main.c     **** 					speedLowHigh =  speed>>1; // /2
 525              		.loc 2 154 0
 526 00d0 FB69     		ldr	r3, [r7, #28]
 527 00d2 5B10     		asr	r3, r3, #1
 528 00d4 7B61     		str	r3, [r7, #20]
 529              	.L38:
 163:../Main.c     **** 				speed=0;
 530              		.loc 2 163 0
 531 00d6 0023     		mov	r3, #0
 532 00d8 FB61     		str	r3, [r7, #28]
 533              	.L36:
 166:../Main.c     **** 			lastPinState = FALSE;
 534              		.loc 2 166 0
 535 00da 3B1C     		mov	r3, r7
 536 00dc 2733     		add	r3, r3, #39
 537 00de 0022     		mov	r2, #0
 538 00e0 1A70     		strb	r2, [r3]
 539 00e2 06E0     		b	.L39
 540              	.L35:
 168:../Main.c     **** 		else if (cnt_high > 0)
 541              		.loc 2 168 0
 542 00e4 3B69     		ldr	r3, [r7, #16]
 543 00e6 002B     		cmp	r3, #0
 544 00e8 03DD     		ble	.L39
 170:../Main.c     **** 			lastPinState = TRUE;
 545              		.loc 2 170 0
 546 00ea 3B1C     		mov	r3, r7
 547 00ec 2733     		add	r3, r3, #39
 548 00ee 0122     		mov	r2, #1
 549 00f0 1A70     		strb	r2, [r3]
 550              	.L39:
 173:../Main.c     **** 		if (speedLow >= speedLowHigh)
 551              		.loc 2 173 0
 552 00f2 BA69     		ldr	r2, [r7, #24]
 553 00f4 7B69     		ldr	r3, [r7, #20]
 554 00f6 9A42     		cmp	r2, r3
 555 00f8 AFDB     		blt	.L45
 175:../Main.c     **** 			speedLow = 0;
 556              		.loc 2 175 0
 557 00fa 0023     		mov	r3, #0
 558 00fc BB61     		str	r3, [r7, #24]
 177:../Main.c     **** 			if (!trigger)
 559              		.loc 2 177 0
 560 00fe 3B1C     		mov	r3, r7
 561 0100 2633     		add	r3, r3, #38
 562 0102 1B78     		ldrb	r3, [r3]
 563 0104 002B     		cmp	r3, #0
 564 0106 03D1     		bne	.L41
 178:../Main.c     **** 				noTriggerCnt++;
 565              		.loc 2 178 0
 566 0108 3B6A     		ldr	r3, [r7, #32]
 567 010a 0133     		add	r3, r3, #1
 568 010c 3B62     		str	r3, [r7, #32]
 569 010e 01E0     		b	.L42
 570              	.L41:
 180:../Main.c     **** 				noTriggerCnt=0;
 571              		.loc 2 180 0
 572 0110 0023     		mov	r3, #0
 573 0112 3B62     		str	r3, [r7, #32]
 574              	.L42:
 181:../Main.c     **** 			trigger = FALSE;
 575              		.loc 2 181 0
 576 0114 3B1C     		mov	r3, r7
 577 0116 2633     		add	r3, r3, #38
 578 0118 0022     		mov	r2, #0
 579 011a 1A70     		strb	r2, [r3]
 183:../Main.c     **** 			if (noTriggerCnt > 1)
 580              		.loc 2 183 0
 581 011c 3B6A     		ldr	r3, [r7, #32]
 582 011e 012B     		cmp	r3, #1
 583 0120 04DD     		ble	.L43
 185:../Main.c     **** 				noTriggerCnt=1;
 584              		.loc 2 185 0
 585 0122 0123     		mov	r3, #1
 586 0124 3B62     		str	r3, [r7, #32]
 186:../Main.c     **** 				PIN_LOW_DEASSERT();
 587              		.loc 2 186 0
 588 0126 FFF7FEFF 		bl	P0_5_set
 589              	.LBE2:
 590              		.loc 2 194 0
 591 012a 96E7     		b	.L45
 592              	.L43:
 593              	.LBB4:
 190:../Main.c     **** 				PIN_LOW_TOGGLE();
 594              		.loc 2 190 0
 595 012c FFF7FEFF 		bl	P0_5_toggle
 596              	.LBE4:
 597              		.loc 2 194 0
 598 0130 93E7     		b	.L45
 599              		.cfi_endproc
 600              	.LFE402:
 602              		.global	__aeabi_uidivmod
 603 0132 C046     		.section	.text.IRQ_Hdlr_26,"ax",%progbits
 604              		.align	2
 605              		.global	IRQ_Hdlr_26
 606              		.code	16
 607              		.thumb_func
 609              	IRQ_Hdlr_26:
 610              	.LFB403:
 195:../Main.c     **** 	return 0;
 196:../Main.c     **** }
 197:../Main.c     **** 
 198:../Main.c     **** 
 199:../Main.c     **** /*
 200:../Main.c     ****  * PWM_Period_Interrupt handler: executes every period match of PWMSP001/0.
 201:../Main.c     ****  */
 202:../Main.c     **** void PWM_Period_Interrupt(void)
 203:../Main.c     **** {
 611              		.loc 2 203 0
 612              		.cfi_startproc
 613 0000 80B5     		push	{r7, lr}
 614              	.LCFI24:
 615              		.cfi_def_cfa_offset 8
 616              		.cfi_offset 7, -8
 617              		.cfi_offset 14, -4
 618 0002 00AF     		add	r7, sp, #0
 619              	.LCFI25:
 620              		.cfi_def_cfa_register 7
 204:../Main.c     **** #define MAXFREQ 7
 205:../Main.c     **** 	static uint32_t state = 0;
 206:../Main.c     **** 	static uint32_t cycles = 0;
 207:../Main.c     **** 	static status_t status = DAVEApp_SUCCESS;
 208:../Main.c     **** 	/* state machine to change the different duty cycle */
 209:../Main.c     **** 	if (cycles == 0)
 621              		.loc 2 209 0
 622 0004 0F4B     		ldr	r3, .L48
 623 0006 1B68     		ldr	r3, [r3]
 624 0008 002B     		cmp	r3, #0
 625 000a 13D1     		bne	.L47
 210:../Main.c     **** 	{
 211:../Main.c     **** 		cycles = (state%MAXFREQ) + 1;
 626              		.loc 2 211 0
 627 000c 0E4B     		ldr	r3, .L48+4
 628 000e 1B68     		ldr	r3, [r3]
 629 0010 181C     		mov	r0, r3
 630 0012 0721     		mov	r1, #7
 631 0014 FFF7FEFF 		bl	__aeabi_uidivmod
 632 0018 0B1C     		mov	r3, r1
 633 001a 5A1C     		add	r2, r3, #1
 634 001c 094B     		ldr	r3, .L48
 635 001e 1A60     		str	r2, [r3]
 212:../Main.c     **** 		//status = PWMSP001_SetPwmFreqAndDutyCycle((PWMSP001_HandleType*)&PWMSP001_Handle0, cycles, 50);
 213:../Main.c     **** 		cycles = cycles<<2;
 636              		.loc 2 213 0
 637 0020 084B     		ldr	r3, .L48
 638 0022 1B68     		ldr	r3, [r3]
 639 0024 9A00     		lsl	r2, r3, #2
 640 0026 074B     		ldr	r3, .L48
 641 0028 1A60     		str	r2, [r3]
 214:../Main.c     **** 
 215:../Main.c     **** 		state++;
 642              		.loc 2 215 0
 643 002a 074B     		ldr	r3, .L48+4
 644 002c 1B68     		ldr	r3, [r3]
 645 002e 5A1C     		add	r2, r3, #1
 646 0030 054B     		ldr	r3, .L48+4
 647 0032 1A60     		str	r2, [r3]
 648              	.L47:
 216:../Main.c     **** 		if(status != DAVEApp_SUCCESS)
 217:../Main.c     **** 		{
 218:../Main.c     **** 			//PWMSP001_Stop((PWMSP001_HandleType*)&PWMSP001_Handle0);
 219:../Main.c     **** 		}
 220:../Main.c     **** 	}
 221:../Main.c     **** 	cycles--;
 649              		.loc 2 221 0
 650 0034 034B     		ldr	r3, .L48
 651 0036 1B68     		ldr	r3, [r3]
 652 0038 5A1E     		sub	r2, r3, #1
 653 003a 024B     		ldr	r3, .L48
 654 003c 1A60     		str	r2, [r3]
 222:../Main.c     **** }
 655              		.loc 2 222 0
 656 003e BD46     		mov	sp, r7
 657              		@ sp needed for prologue
 658 0040 80BD     		pop	{r7, pc}
 659              	.L49:
 660 0042 C046     		.align	2
 661              	.L48:
 662 0044 00000000 		.word	cycles.5739
 663 0048 04000000 		.word	state.5738
 664              		.cfi_endproc
 665              	.LFE403:
 667              		.bss
 668              		.align	2
 669              	cycles.5739:
 670 0000 00000000 		.space	4
 671              		.align	2
 672              	state.5738:
 673 0004 00000000 		.space	4
 674              		.align	2
 675              	status.5740:
 676 0008 00000000 		.space	4
 677              		.text
 678              	.Letext0:
 679              		.file 3 "c:\\dave-3.1.10\\arm-gcc\\bin\\../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none-eabi/i
 680              		.file 4 "C:\\DAVE-3.1.10\\eclipse\\/../CMSIS/Infineon/XMC1100_series/Include/XMC1100.h"
 681              		.file 5 "C:\\DAVE3_workspace\\ws3.1.10\\boschSpeedUp\\Dave\\Generated\\inc\\DAVESupport/../../inc/
DEFINED SYMBOLS
                            *ABS*:00000000 Main.c
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:18     .text.P0_5_set_mode:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:22     .text.P0_5_set_mode:00000000 P0_5_set_mode
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:65     .text.P0_5_set_mode:00000030 $d
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:71     .text.P0_5_set:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:75     .text.P0_5_set:00000000 P0_5_set
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:98     .text.P0_5_set:00000010 $d
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:103    .text.P0_5_toggle:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:107    .text.P0_5_toggle:00000000 P0_5_toggle
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:130    .text.P0_5_toggle:00000010 $d
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:136    .text.P0_6_set_mode:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:140    .text.P0_6_set_mode:00000000 P0_6_set_mode
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:182    .text.P0_6_set_mode:00000030 $d
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:188    .text.P0_6_set_large_hysteresis:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:192    .text.P0_6_set_large_hysteresis:00000000 P0_6_set_large_hysteresis
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:219    .text.P0_6_set_large_hysteresis:00000018 $d
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:224    .text.P0_6_read:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:228    .text.P0_6_read:00000000 P0_6_read
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:253    .text.P0_6_read:00000014 $d
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:258    .text.P1_4_set_mode:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:262    .text.P1_4_set_mode:00000000 P1_4_set_mode
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:303    .text.P1_4_set_mode:0000002c $d
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:308    .text.P1_4_set_large_hysteresis:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:312    .text.P1_4_set_large_hysteresis:00000000 P1_4_set_large_hysteresis
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:339    .text.P1_4_set_large_hysteresis:00000018 $d
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:344    .text.P1_4_read:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:348    .text.P1_4_read:00000000 P1_4_read
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:373    .text.P1_4_read:00000014 $d
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:379    .text.main:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:384    .text.main:00000000 main
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:604    .text.IRQ_Hdlr_26:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:609    .text.IRQ_Hdlr_26:00000000 IRQ_Hdlr_26
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:662    .text.IRQ_Hdlr_26:00000044 $d
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:669    .bss:00000000 cycles.5739
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:672    .bss:00000004 state.5738
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:668    .bss:00000000 $d
C:\Users\Patrick\AppData\Local\Temp\ccNa62x4.s:675    .bss:00000008 status.5740
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.63d3e0297d6e9004e0e37a0840833abd
                           .group:00000000 wm4.XMC1100.h.45.7a7cd799d7738130fcda8b83b0aa37d4
                           .group:00000000 wm4.core_cm0.h.47.022e66414e77714da7c4b30b3ad99fe8
                           .group:00000000 wm4.newlib.h.8.a9901dc52d1357e3e94003403d43f8b5
                           .group:00000000 wm4.features.h.22.b72b3baab2bb2eab3661375590100b6b
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.7aefdac4826acebbfc9f3822a0aeb14c
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.core_cmInstr.h.39.b7b6650bdd2316848d940915272d75b8
                           .group:00000000 wm4.core_cm0.h.135.ca70469f87e143609670bb393bfa6518
                           .group:00000000 wm4.XMC1000_RomFunctionTable.h.31.6d9a94465618f31b040dc9cea9a47ad7
                           .group:00000000 wm4.XMC1100.h.114.be3711f71ee045884346be801053f4c0
                           .group:00000000 wm4.stddef.h.40.50cf36416e06376af8a9dca28536f2e4
                           .group:00000000 wm4.types.h.60.e75c47576398c648cdcf9000ace5e3d8
                           .group:00000000 wm4.MULTIPLEXER.h.46.383e3edbb9cbf6e538f7c1532ef623c1
                           .group:00000000 wm4.uc_id.h.35.47f40be5760de9fc3332688f9e95febc
                           .group:00000000 wm4.NVIC002_Conf.h.63.9c71769d77b95acb42ba2599ae4f9114
                           .group:00000000 wm4.GPIO.h.2.93bf17ee3a853f64308a0e4d0c9f6a08

UNDEFINED SYMBOLS
__aeabi_idiv
DAVE_Init
__aeabi_uidivmod
