   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"Main.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.P0_5_set_large_hysteresis,"ax",%progbits
  18              		.align	2
  19              		.code	16
  20              		.thumb_func
  22              	P0_5_set_large_hysteresis:
  23              	.LFB91:
  24              		.file 1 "../GPIO.h"
   1:../GPIO.h     **** #ifndef __GPIO_H__
   2:../GPIO.h     **** #define __GPIO_H__
   3:../GPIO.h     **** 
   4:../GPIO.h     **** /* Generated for XMC1100_TSSOP38 on: Wed Feb 13 23:11:00 2013*/
   5:../GPIO.h     **** 
   6:../GPIO.h     **** #include <XMC1100.h>
   7:../GPIO.h     **** 
   8:../GPIO.h     **** #define INPUT           0x00U
   9:../GPIO.h     **** #define INPUT_PD        0x08U
  10:../GPIO.h     **** #define INPUT_PU        0x10U
  11:../GPIO.h     **** #define INPUT_PPS       0x18U
  12:../GPIO.h     **** #define INPUT_INV       0x20U
  13:../GPIO.h     **** #define INPUT_INV_PD    0x28U
  14:../GPIO.h     **** #define INPUT_INV_PU    0x30U
  15:../GPIO.h     **** #define INPUT_INV_PPS   0x38U
  16:../GPIO.h     **** #define OUTPUT_PP_GP    0x80U
  17:../GPIO.h     **** #define OUTPUT_PP_AF1   0x88U
  18:../GPIO.h     **** #define OUTPUT_PP_AF2   0x90U
  19:../GPIO.h     **** #define OUTPUT_PP_AF3   0x98U
  20:../GPIO.h     **** #define OUTPUT_PP_AF4   0xA0U
  21:../GPIO.h     **** #define OUTPUT_PP_AF5   0xA8U
  22:../GPIO.h     **** #define OUTPUT_PP_AF6   0xB0U
  23:../GPIO.h     **** #define OUTPUT_PP_AF7   0xB8U
  24:../GPIO.h     **** #define OUTPUT_OD_GP    0xC0U
  25:../GPIO.h     **** #define OUTPUT_OD_AF1   0xC8U
  26:../GPIO.h     **** #define OUTPUT_OD_AF2   0xD0U
  27:../GPIO.h     **** #define OUTPUT_OD_AF3   0xD8U
  28:../GPIO.h     **** #define OUTPUT_OD_AF4   0XE0U
  29:../GPIO.h     **** #define OUTPUT_OD_AF5   0xE8U
  30:../GPIO.h     **** #define OUTPUT_OD_AF6   0xF0U
  31:../GPIO.h     **** #define OUTPUT_OD_AF7   0XF8U
  32:../GPIO.h     **** 
  33:../GPIO.h     **** #define SOFTWARE        0x0UL
  34:../GPIO.h     **** #define HW0             0x1UL
  35:../GPIO.h     **** #define HW1             0x2UL
  36:../GPIO.h     **** 
  37:../GPIO.h     **** __STATIC_INLINE void P0_0_set_mode(uint8_t mode){
  38:../GPIO.h     ****     PORT0->IOCR0 &= ~0x000000f8UL;
  39:../GPIO.h     ****     PORT0->IOCR0 |= mode << 0;
  40:../GPIO.h     **** }
  41:../GPIO.h     **** 
  42:../GPIO.h     **** __STATIC_INLINE void P0_0_set_hwsel(uint32_t config){
  43:../GPIO.h     ****     PORT0->HWSEL &= ~0x00000003UL;
  44:../GPIO.h     ****     PORT0->HWSEL |= config << 0;
  45:../GPIO.h     **** }
  46:../GPIO.h     **** 
  47:../GPIO.h     **** __STATIC_INLINE void P0_0_set_standard_hysteresis(){
  48:../GPIO.h     ****     PORT0->PHCR0 &= ~0x00000004UL;
  49:../GPIO.h     **** }
  50:../GPIO.h     **** 
  51:../GPIO.h     **** __STATIC_INLINE void P0_0_set_large_hysteresis(){
  52:../GPIO.h     ****     PORT0->PHCR0 |= 0x00000004UL;
  53:../GPIO.h     **** }
  54:../GPIO.h     **** 
  55:../GPIO.h     **** __STATIC_INLINE void P0_0_set(void){
  56:../GPIO.h     ****     PORT0->OMR = 0x00000001UL;
  57:../GPIO.h     **** }
  58:../GPIO.h     **** 
  59:../GPIO.h     **** __STATIC_INLINE void P0_0_reset(void){
  60:../GPIO.h     ****     PORT0->OMR = 0x00010000UL;
  61:../GPIO.h     **** }
  62:../GPIO.h     **** 
  63:../GPIO.h     **** __STATIC_INLINE void P0_0_toggle(void){
  64:../GPIO.h     ****     PORT0->OMR = 0x00010001UL;
  65:../GPIO.h     **** }
  66:../GPIO.h     **** 
  67:../GPIO.h     **** __STATIC_INLINE uint32_t P0_0_read(void){
  68:../GPIO.h     ****     return(PORT0->IN & 0x00000001UL);
  69:../GPIO.h     **** }
  70:../GPIO.h     **** 
  71:../GPIO.h     **** __STATIC_INLINE void P0_0_enable_pps(void){
  72:../GPIO.h     ****     PORT0->PPS |= 0x00000001UL;
  73:../GPIO.h     **** }
  74:../GPIO.h     **** 
  75:../GPIO.h     **** __STATIC_INLINE void P0_0_disable_pps(void){
  76:../GPIO.h     ****     PORT0->PPS &= ~0x00000001UL;
  77:../GPIO.h     **** }
  78:../GPIO.h     **** 
  79:../GPIO.h     **** __STATIC_INLINE void P0_1_set_mode(uint8_t mode){
  80:../GPIO.h     ****     PORT0->IOCR0 &= ~0x0000f800UL;
  81:../GPIO.h     ****     PORT0->IOCR0 |= mode << 8;
  82:../GPIO.h     **** }
  83:../GPIO.h     **** 
  84:../GPIO.h     **** __STATIC_INLINE void P0_1_set_hwsel(uint32_t config){
  85:../GPIO.h     ****     PORT0->HWSEL &= ~0x0000000cUL;
  86:../GPIO.h     ****     PORT0->HWSEL |= config << 2;
  87:../GPIO.h     **** }
  88:../GPIO.h     **** 
  89:../GPIO.h     **** __STATIC_INLINE void P0_1_set_standard_hysteresis(){
  90:../GPIO.h     ****     PORT0->PHCR0 &= ~0x00000040UL;
  91:../GPIO.h     **** }
  92:../GPIO.h     **** 
  93:../GPIO.h     **** __STATIC_INLINE void P0_1_set_large_hysteresis(){
  94:../GPIO.h     ****     PORT0->PHCR0 |= 0x00000040UL;
  95:../GPIO.h     **** }
  96:../GPIO.h     **** 
  97:../GPIO.h     **** __STATIC_INLINE void P0_1_set(void){
  98:../GPIO.h     ****     PORT0->OMR = 0x00000002UL;
  99:../GPIO.h     **** }
 100:../GPIO.h     **** 
 101:../GPIO.h     **** __STATIC_INLINE void P0_1_reset(void){
 102:../GPIO.h     ****     PORT0->OMR = 0x00020000UL;
 103:../GPIO.h     **** }
 104:../GPIO.h     **** 
 105:../GPIO.h     **** __STATIC_INLINE void P0_1_toggle(void){
 106:../GPIO.h     ****     PORT0->OMR = 0x00020002UL;
 107:../GPIO.h     **** }
 108:../GPIO.h     **** 
 109:../GPIO.h     **** __STATIC_INLINE uint32_t P0_1_read(void){
 110:../GPIO.h     ****     return(PORT0->IN & 0x00000002UL);
 111:../GPIO.h     **** }
 112:../GPIO.h     **** 
 113:../GPIO.h     **** __STATIC_INLINE void P0_1_enable_pps(void){
 114:../GPIO.h     ****     PORT0->PPS |= 0x00000002UL;
 115:../GPIO.h     **** }
 116:../GPIO.h     **** 
 117:../GPIO.h     **** __STATIC_INLINE void P0_1_disable_pps(void){
 118:../GPIO.h     ****     PORT0->PPS &= ~0x00000002UL;
 119:../GPIO.h     **** }
 120:../GPIO.h     **** 
 121:../GPIO.h     **** __STATIC_INLINE void P0_2_set_mode(uint8_t mode){
 122:../GPIO.h     ****     PORT0->IOCR0 &= ~0x00f80000UL;
 123:../GPIO.h     ****     PORT0->IOCR0 |= mode << 16;
 124:../GPIO.h     **** }
 125:../GPIO.h     **** 
 126:../GPIO.h     **** __STATIC_INLINE void P0_2_set_hwsel(uint32_t config){
 127:../GPIO.h     ****     PORT0->HWSEL &= ~0x00000030UL;
 128:../GPIO.h     ****     PORT0->HWSEL |= config << 4;
 129:../GPIO.h     **** }
 130:../GPIO.h     **** 
 131:../GPIO.h     **** __STATIC_INLINE void P0_2_set_standard_hysteresis(){
 132:../GPIO.h     ****     PORT0->PHCR0 &= ~0x00000400UL;
 133:../GPIO.h     **** }
 134:../GPIO.h     **** 
 135:../GPIO.h     **** __STATIC_INLINE void P0_2_set_large_hysteresis(){
 136:../GPIO.h     ****     PORT0->PHCR0 |= 0x00000400UL;
 137:../GPIO.h     **** }
 138:../GPIO.h     **** 
 139:../GPIO.h     **** __STATIC_INLINE void P0_2_set(void){
 140:../GPIO.h     ****     PORT0->OMR = 0x00000004UL;
 141:../GPIO.h     **** }
 142:../GPIO.h     **** 
 143:../GPIO.h     **** __STATIC_INLINE void P0_2_reset(void){
 144:../GPIO.h     ****     PORT0->OMR = 0x00040000UL;
 145:../GPIO.h     **** }
 146:../GPIO.h     **** 
 147:../GPIO.h     **** __STATIC_INLINE void P0_2_toggle(void){
 148:../GPIO.h     ****     PORT0->OMR = 0x00040004UL;
 149:../GPIO.h     **** }
 150:../GPIO.h     **** 
 151:../GPIO.h     **** __STATIC_INLINE uint32_t P0_2_read(void){
 152:../GPIO.h     ****     return(PORT0->IN & 0x00000004UL);
 153:../GPIO.h     **** }
 154:../GPIO.h     **** 
 155:../GPIO.h     **** __STATIC_INLINE void P0_2_enable_pps(void){
 156:../GPIO.h     ****     PORT0->PPS |= 0x00000004UL;
 157:../GPIO.h     **** }
 158:../GPIO.h     **** 
 159:../GPIO.h     **** __STATIC_INLINE void P0_2_disable_pps(void){
 160:../GPIO.h     ****     PORT0->PPS &= ~0x00000004UL;
 161:../GPIO.h     **** }
 162:../GPIO.h     **** 
 163:../GPIO.h     **** __STATIC_INLINE void P0_3_set_mode(uint8_t mode){
 164:../GPIO.h     ****     PORT0->IOCR0 &= ~0xf8000000UL;
 165:../GPIO.h     ****     PORT0->IOCR0 |= mode << 24;
 166:../GPIO.h     **** }
 167:../GPIO.h     **** 
 168:../GPIO.h     **** __STATIC_INLINE void P0_3_set_hwsel(uint32_t config){
 169:../GPIO.h     ****     PORT0->HWSEL &= ~0x000000c0UL;
 170:../GPIO.h     ****     PORT0->HWSEL |= config << 6;
 171:../GPIO.h     **** }
 172:../GPIO.h     **** 
 173:../GPIO.h     **** __STATIC_INLINE void P0_3_set_standard_hysteresis(){
 174:../GPIO.h     ****     PORT0->PHCR0 &= ~0x00004000UL;
 175:../GPIO.h     **** }
 176:../GPIO.h     **** 
 177:../GPIO.h     **** __STATIC_INLINE void P0_3_set_large_hysteresis(){
 178:../GPIO.h     ****     PORT0->PHCR0 |= 0x00004000UL;
 179:../GPIO.h     **** }
 180:../GPIO.h     **** 
 181:../GPIO.h     **** __STATIC_INLINE void P0_3_set(void){
 182:../GPIO.h     ****     PORT0->OMR = 0x00000008UL;
 183:../GPIO.h     **** }
 184:../GPIO.h     **** 
 185:../GPIO.h     **** __STATIC_INLINE void P0_3_reset(void){
 186:../GPIO.h     ****     PORT0->OMR = 0x00080000UL;
 187:../GPIO.h     **** }
 188:../GPIO.h     **** 
 189:../GPIO.h     **** __STATIC_INLINE void P0_3_toggle(void){
 190:../GPIO.h     ****     PORT0->OMR = 0x00080008UL;
 191:../GPIO.h     **** }
 192:../GPIO.h     **** 
 193:../GPIO.h     **** __STATIC_INLINE uint32_t P0_3_read(void){
 194:../GPIO.h     ****     return(PORT0->IN & 0x00000008UL);
 195:../GPIO.h     **** }
 196:../GPIO.h     **** 
 197:../GPIO.h     **** __STATIC_INLINE void P0_3_enable_pps(void){
 198:../GPIO.h     ****     PORT0->PPS |= 0x00000008UL;
 199:../GPIO.h     **** }
 200:../GPIO.h     **** 
 201:../GPIO.h     **** __STATIC_INLINE void P0_3_disable_pps(void){
 202:../GPIO.h     ****     PORT0->PPS &= ~0x00000008UL;
 203:../GPIO.h     **** }
 204:../GPIO.h     **** 
 205:../GPIO.h     **** __STATIC_INLINE void P0_4_set_mode(uint8_t mode){
 206:../GPIO.h     ****     PORT0->IOCR4 &= ~0x000000f8UL;
 207:../GPIO.h     ****     PORT0->IOCR4 |= mode << 0;
 208:../GPIO.h     **** }
 209:../GPIO.h     **** 
 210:../GPIO.h     **** __STATIC_INLINE void P0_4_set_hwsel(uint32_t config){
 211:../GPIO.h     ****     PORT0->HWSEL &= ~0x00000300UL;
 212:../GPIO.h     ****     PORT0->HWSEL |= config << 8;
 213:../GPIO.h     **** }
 214:../GPIO.h     **** 
 215:../GPIO.h     **** __STATIC_INLINE void P0_4_set_standard_hysteresis(){
 216:../GPIO.h     ****     PORT0->PHCR0 &= ~0x00040000UL;
 217:../GPIO.h     **** }
 218:../GPIO.h     **** 
 219:../GPIO.h     **** __STATIC_INLINE void P0_4_set_large_hysteresis(){
 220:../GPIO.h     ****     PORT0->PHCR0 |= 0x00040000UL;
 221:../GPIO.h     **** }
 222:../GPIO.h     **** 
 223:../GPIO.h     **** __STATIC_INLINE void P0_4_set(void){
 224:../GPIO.h     ****     PORT0->OMR = 0x00000010UL;
 225:../GPIO.h     **** }
 226:../GPIO.h     **** 
 227:../GPIO.h     **** __STATIC_INLINE void P0_4_reset(void){
 228:../GPIO.h     ****     PORT0->OMR = 0x00100000UL;
 229:../GPIO.h     **** }
 230:../GPIO.h     **** 
 231:../GPIO.h     **** __STATIC_INLINE void P0_4_toggle(void){
 232:../GPIO.h     ****     PORT0->OMR = 0x00100010UL;
 233:../GPIO.h     **** }
 234:../GPIO.h     **** 
 235:../GPIO.h     **** __STATIC_INLINE uint32_t P0_4_read(void){
 236:../GPIO.h     ****     return(PORT0->IN & 0x00000010UL);
 237:../GPIO.h     **** }
 238:../GPIO.h     **** 
 239:../GPIO.h     **** __STATIC_INLINE void P0_4_enable_pps(void){
 240:../GPIO.h     ****     PORT0->PPS |= 0x00000010UL;
 241:../GPIO.h     **** }
 242:../GPIO.h     **** 
 243:../GPIO.h     **** __STATIC_INLINE void P0_4_disable_pps(void){
 244:../GPIO.h     ****     PORT0->PPS &= ~0x00000010UL;
 245:../GPIO.h     **** }
 246:../GPIO.h     **** 
 247:../GPIO.h     **** __STATIC_INLINE void P0_5_set_mode(uint8_t mode){
 248:../GPIO.h     ****     PORT0->IOCR4 &= ~0x0000f800UL;
 249:../GPIO.h     ****     PORT0->IOCR4 |= mode << 8;
 250:../GPIO.h     **** }
 251:../GPIO.h     **** 
 252:../GPIO.h     **** __STATIC_INLINE void P0_5_set_hwsel(uint32_t config){
 253:../GPIO.h     ****     PORT0->HWSEL &= ~0x00000c00UL;
 254:../GPIO.h     ****     PORT0->HWSEL |= config << 10;
 255:../GPIO.h     **** }
 256:../GPIO.h     **** 
 257:../GPIO.h     **** __STATIC_INLINE void P0_5_set_standard_hysteresis(){
 258:../GPIO.h     ****     PORT0->PHCR0 &= ~0x00400000UL;
 259:../GPIO.h     **** }
 260:../GPIO.h     **** 
 261:../GPIO.h     **** __STATIC_INLINE void P0_5_set_large_hysteresis(){
  25              		.loc 1 261 0
  26              		.cfi_startproc
  27 0000 80B5     		push	{r7, lr}
  28              	.LCFI0:
  29              		.cfi_def_cfa_offset 8
  30              		.cfi_offset 7, -8
  31              		.cfi_offset 14, -4
  32 0002 00AF     		add	r7, sp, #0
  33              	.LCFI1:
  34              		.cfi_def_cfa_register 7
 262:../GPIO.h     ****     PORT0->PHCR0 |= 0x00400000UL;
  35              		.loc 1 262 0
  36 0004 044B     		ldr	r3, .L2
  37 0006 044A     		ldr	r2, .L2
  38 0008 126C     		ldr	r2, [r2, #64]
  39 000a 8021     		mov	r1, #128
  40 000c C903     		lsl	r1, r1, #15
  41 000e 0A43     		orr	r2, r1
  42 0010 1A64     		str	r2, [r3, #64]
 263:../GPIO.h     **** }
  43              		.loc 1 263 0
  44 0012 BD46     		mov	sp, r7
  45              		@ sp needed for prologue
  46 0014 80BD     		pop	{r7, pc}
  47              	.L3:
  48 0016 C046     		.align	2
  49              	.L2:
  50 0018 00000440 		.word	1074003968
  51              		.cfi_endproc
  52              	.LFE91:
  54              		.section	.text.P0_5_read,"ax",%progbits
  55              		.align	2
  56              		.code	16
  57              		.thumb_func
  59              	P0_5_read:
  60              	.LFB95:
 264:../GPIO.h     **** 
 265:../GPIO.h     **** __STATIC_INLINE void P0_5_set(void){
 266:../GPIO.h     ****     PORT0->OMR = 0x00000020UL;
 267:../GPIO.h     **** }
 268:../GPIO.h     **** 
 269:../GPIO.h     **** __STATIC_INLINE void P0_5_reset(void){
 270:../GPIO.h     ****     PORT0->OMR = 0x00200000UL;
 271:../GPIO.h     **** }
 272:../GPIO.h     **** 
 273:../GPIO.h     **** __STATIC_INLINE void P0_5_toggle(void){
 274:../GPIO.h     ****     PORT0->OMR = 0x00200020UL;
 275:../GPIO.h     **** }
 276:../GPIO.h     **** 
 277:../GPIO.h     **** __STATIC_INLINE uint32_t P0_5_read(void){
  61              		.loc 1 277 0
  62              		.cfi_startproc
  63 0000 80B5     		push	{r7, lr}
  64              	.LCFI2:
  65              		.cfi_def_cfa_offset 8
  66              		.cfi_offset 7, -8
  67              		.cfi_offset 14, -4
  68 0002 00AF     		add	r7, sp, #0
  69              	.LCFI3:
  70              		.cfi_def_cfa_register 7
 278:../GPIO.h     ****     return(PORT0->IN & 0x00000020UL);
  71              		.loc 1 278 0
  72 0004 034B     		ldr	r3, .L6
  73 0006 5A6A     		ldr	r2, [r3, #36]
  74 0008 2023     		mov	r3, #32
  75 000a 1340     		and	r3, r2
 279:../GPIO.h     **** }
  76              		.loc 1 279 0
  77 000c 181C     		mov	r0, r3
  78 000e BD46     		mov	sp, r7
  79              		@ sp needed for prologue
  80 0010 80BD     		pop	{r7, pc}
  81              	.L7:
  82 0012 C046     		.align	2
  83              	.L6:
  84 0014 00000440 		.word	1074003968
  85              		.cfi_endproc
  86              	.LFE95:
  88              		.section	.text.P0_6_set_mode,"ax",%progbits
  89              		.align	2
  90              		.code	16
  91              		.thumb_func
  93              	P0_6_set_mode:
  94              	.LFB98:
 280:../GPIO.h     **** 
 281:../GPIO.h     **** __STATIC_INLINE void P0_5_enable_pps(void){
 282:../GPIO.h     ****     PORT0->PPS |= 0x00000020UL;
 283:../GPIO.h     **** }
 284:../GPIO.h     **** 
 285:../GPIO.h     **** __STATIC_INLINE void P0_5_disable_pps(void){
 286:../GPIO.h     ****     PORT0->PPS &= ~0x00000020UL;
 287:../GPIO.h     **** }
 288:../GPIO.h     **** 
 289:../GPIO.h     **** __STATIC_INLINE void P0_6_set_mode(uint8_t mode){
  95              		.loc 1 289 0
  96              		.cfi_startproc
  97 0000 80B5     		push	{r7, lr}
  98              	.LCFI4:
  99              		.cfi_def_cfa_offset 8
 100              		.cfi_offset 7, -8
 101              		.cfi_offset 14, -4
 102 0002 82B0     		sub	sp, sp, #8
 103              	.LCFI5:
 104              		.cfi_def_cfa_offset 16
 105 0004 00AF     		add	r7, sp, #0
 106              	.LCFI6:
 107              		.cfi_def_cfa_register 7
 108 0006 021C     		mov	r2, r0
 109 0008 FB1D     		add	r3, r7, #7
 110 000a 1A70     		strb	r2, [r3]
 290:../GPIO.h     ****     PORT0->IOCR4 &= ~0x00f80000UL;
 111              		.loc 1 290 0
 112 000c 084B     		ldr	r3, .L9
 113 000e 084A     		ldr	r2, .L9
 114 0010 5169     		ldr	r1, [r2, #20]
 115 0012 084A     		ldr	r2, .L9+4
 116 0014 0A40     		and	r2, r1
 117 0016 5A61     		str	r2, [r3, #20]
 291:../GPIO.h     ****     PORT0->IOCR4 |= mode << 16;
 118              		.loc 1 291 0
 119 0018 054B     		ldr	r3, .L9
 120 001a 054A     		ldr	r2, .L9
 121 001c 5169     		ldr	r1, [r2, #20]
 122 001e FA1D     		add	r2, r7, #7
 123 0020 1278     		ldrb	r2, [r2]
 124 0022 1204     		lsl	r2, r2, #16
 125 0024 0A43     		orr	r2, r1
 126 0026 5A61     		str	r2, [r3, #20]
 292:../GPIO.h     **** }
 127              		.loc 1 292 0
 128 0028 BD46     		mov	sp, r7
 129 002a 02B0     		add	sp, sp, #8
 130              		@ sp needed for prologue
 131 002c 80BD     		pop	{r7, pc}
 132              	.L10:
 133 002e C046     		.align	2
 134              	.L9:
 135 0030 00000440 		.word	1074003968
 136 0034 FFFF07FF 		.word	-16252929
 137              		.cfi_endproc
 138              	.LFE98:
 140              		.section	.text.P0_6_set,"ax",%progbits
 141              		.align	2
 142              		.code	16
 143              		.thumb_func
 145              	P0_6_set:
 146              	.LFB102:
 293:../GPIO.h     **** 
 294:../GPIO.h     **** __STATIC_INLINE void P0_6_set_hwsel(uint32_t config){
 295:../GPIO.h     ****     PORT0->HWSEL &= ~0x00003000UL;
 296:../GPIO.h     ****     PORT0->HWSEL |= config << 12;
 297:../GPIO.h     **** }
 298:../GPIO.h     **** 
 299:../GPIO.h     **** __STATIC_INLINE void P0_6_set_standard_hysteresis(){
 300:../GPIO.h     ****     PORT0->PHCR0 &= ~0x04000000UL;
 301:../GPIO.h     **** }
 302:../GPIO.h     **** 
 303:../GPIO.h     **** __STATIC_INLINE void P0_6_set_large_hysteresis(){
 304:../GPIO.h     ****     PORT0->PHCR0 |= 0x04000000UL;
 305:../GPIO.h     **** }
 306:../GPIO.h     **** 
 307:../GPIO.h     **** __STATIC_INLINE void P0_6_set(void){
 147              		.loc 1 307 0
 148              		.cfi_startproc
 149 0000 80B5     		push	{r7, lr}
 150              	.LCFI7:
 151              		.cfi_def_cfa_offset 8
 152              		.cfi_offset 7, -8
 153              		.cfi_offset 14, -4
 154 0002 00AF     		add	r7, sp, #0
 155              	.LCFI8:
 156              		.cfi_def_cfa_register 7
 308:../GPIO.h     ****     PORT0->OMR = 0x00000040UL;
 157              		.loc 1 308 0
 158 0004 024B     		ldr	r3, .L12
 159 0006 4022     		mov	r2, #64
 160 0008 5A60     		str	r2, [r3, #4]
 309:../GPIO.h     **** }
 161              		.loc 1 309 0
 162 000a BD46     		mov	sp, r7
 163              		@ sp needed for prologue
 164 000c 80BD     		pop	{r7, pc}
 165              	.L13:
 166 000e C046     		.align	2
 167              	.L12:
 168 0010 00000440 		.word	1074003968
 169              		.cfi_endproc
 170              	.LFE102:
 172              		.section	.text.P0_6_toggle,"ax",%progbits
 173              		.align	2
 174              		.code	16
 175              		.thumb_func
 177              	P0_6_toggle:
 178              	.LFB104:
 310:../GPIO.h     **** 
 311:../GPIO.h     **** __STATIC_INLINE void P0_6_reset(void){
 312:../GPIO.h     ****     PORT0->OMR = 0x00400000UL;
 313:../GPIO.h     **** }
 314:../GPIO.h     **** 
 315:../GPIO.h     **** __STATIC_INLINE void P0_6_toggle(void){
 179              		.loc 1 315 0
 180              		.cfi_startproc
 181 0000 80B5     		push	{r7, lr}
 182              	.LCFI9:
 183              		.cfi_def_cfa_offset 8
 184              		.cfi_offset 7, -8
 185              		.cfi_offset 14, -4
 186 0002 00AF     		add	r7, sp, #0
 187              	.LCFI10:
 188              		.cfi_def_cfa_register 7
 316:../GPIO.h     ****     PORT0->OMR = 0x00400040UL;
 189              		.loc 1 316 0
 190 0004 024B     		ldr	r3, .L15
 191 0006 034A     		ldr	r2, .L15+4
 192 0008 5A60     		str	r2, [r3, #4]
 317:../GPIO.h     **** }
 193              		.loc 1 317 0
 194 000a BD46     		mov	sp, r7
 195              		@ sp needed for prologue
 196 000c 80BD     		pop	{r7, pc}
 197              	.L16:
 198 000e C046     		.align	2
 199              	.L15:
 200 0010 00000440 		.word	1074003968
 201 0014 40004000 		.word	4194368
 202              		.cfi_endproc
 203              	.LFE104:
 205              		.global	__aeabi_idiv
 206              		.global	__aeabi_idivmod
 207              		.section	.text.main,"ax",%progbits
 208              		.align	2
 209              		.global	main
 210              		.code	16
 211              		.thumb_func
 213              	main:
 214              	.LFB402:
 215              		.file 2 "../Main.c"
   1:../Main.c     **** /*=========================================================================== *
   2:../Main.c     ****  * Copyright (c) 2014, Infineon Technologies AG                                *
   3:../Main.c     ****  * All rights reserved.                                                        *
   4:../Main.c     ****  *                                                                             *
   5:../Main.c     ****  * Redistribution and use in source and binary forms, with or without          *
   6:../Main.c     ****  * modification, are permitted provided that the following conditions are met: *
   7:../Main.c     ****  * Redistributions of source code must retain the above copyright notice, this *
   8:../Main.c     ****  * list of conditions and the following disclaimer. Redistributions in binary  *
   9:../Main.c     ****  * form must reproduce the above copyright notice, this list of conditions and *
  10:../Main.c     ****  * the following disclaimer in the documentation and/or other materials        *
  11:../Main.c     ****  * provided with the distribution. Neither the name of the copyright holders   *
  12:../Main.c     ****  * nor the names of its contributors may be used to endorse or promote         *
  13:../Main.c     ****  * products derived from this software without specific prior written          *
  14:../Main.c     ****  * permission.                                                                 *
  15:../Main.c     ****  *                                                                                                 
  16:../Main.c     ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" *
  17:../Main.c     ****  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,       *
  18:../Main.c     ****  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR      *
  19:../Main.c     ****  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR           *
  20:../Main.c     ****  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,       *
  21:../Main.c     ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,         *
  22:../Main.c     ****  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; *
  23:../Main.c     ****  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,    *
  24:../Main.c     ****  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR     *
  25:../Main.c     ****  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF      *
  26:../Main.c     ****  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                                  *
  27:../Main.c     ****  * To improve the quality of the software, users are encouraged to share       *
  28:../Main.c     ****  * modifications, enhancements or bug fixes with                               *
  29:../Main.c     ****  * Infineon Technologies AG (dave@infineon.com).                               *
  30:../Main.c     ****  *                                                                             *
  31:../Main.c     ****  * ========================================================================== */
  32:../Main.c     **** 
  33:../Main.c     **** /********************************************************************************
  34:../Main.c     **** **                                                                            **
  35:../Main.c     **** ** PLATFORM : Infineon XMC1000 Series                                         **
  36:../Main.c     **** **                                                                            **
  37:../Main.c     **** ** AUTHOR : Application Engineering Team                                      **
  38:../Main.c     **** **                                                                            **
  39:../Main.c     **** ** Project version update to v 1.0.0 (Initial version)                        **
  40:../Main.c     **** **                           v 1.0.2 (Updated with latest Dave apps,linker and**
  41:../Main.c     **** **                                    startup files)                          **
  42:../Main.c     **** **                                                                            **
  43:../Main.c     **** ** MODIFICATION DATE : May 27, 2014                                           **
  44:../Main.c     **** **                                                                            **
  45:../Main.c     **** *******************************************************************************/
  46:../Main.c     **** 
  47:../Main.c     **** 
  48:../Main.c     **** /*
  49:../Main.c     ****  *  Main source file for this PWMSP001 demo. This file contains the main
  50:../Main.c     ****  *  tasks of the demo and is responsible for the initial application hardware
  51:../Main.c     ****  *  configuration
  52:../Main.c     ****  */
  53:../Main.c     **** 
  54:../Main.c     **** /*******************************************************************************
  55:../Main.c     ****  ** INCLUDE FILES                                                             **
  56:../Main.c     ****  ******************************************************************************/
  57:../Main.c     **** 
  58:../Main.c     **** #include <DAVE3.h>			//Declarations from DAVE3 Code Generation
  59:../Main.c     **** #include "XMC1100.h"
  60:../Main.c     **** #include "GPIO.h"
  61:../Main.c     **** 
  62:../Main.c     **** #define PIN_IS_HIGH()      P0_5_read()
  63:../Main.c     **** #define PIN_LOW_DEASSERT() P0_6_set()
  64:../Main.c     **** #define PIN_LOW_ASSERT()   P0_6_reset()
  65:../Main.c     **** #define PIN_LOW_TOGGLE()   P0_6_toggle()
  66:../Main.c     **** 
  67:../Main.c     **** #define PIN_LOW_INIT() \
  68:../Main.c     **** 	P0_6_set_mode(OUTPUT_OD_GP); \
  69:../Main.c     **** 	P0_6_set();
  70:../Main.c     **** 
  71:../Main.c     **** #define PIN_IS_INIT() \
  72:../Main.c     **** 	P0_5_set_large_hysteresis(); \
  73:../Main.c     **** 	P0_5_read(); \
  74:../Main.c     **** 	//P0_5_set_mode(INPUT);
  75:../Main.c     **** 
  76:../Main.c     **** 
  77:../Main.c     **** 
  78:../Main.c     **** 
  79:../Main.c     **** 
  80:../Main.c     **** int main(void)
  81:../Main.c     **** {
 216              		.loc 2 81 0
 217              		.cfi_startproc
 218 0000 80B5     		push	{r7, lr}
 219              	.LCFI11:
 220              		.cfi_def_cfa_offset 8
 221              		.cfi_offset 7, -8
 222              		.cfi_offset 14, -4
 223 0002 8AB0     		sub	sp, sp, #40
 224              	.LCFI12:
 225              		.cfi_def_cfa_offset 48
 226 0004 00AF     		add	r7, sp, #0
 227              	.LCFI13:
 228              		.cfi_def_cfa_register 7
  82:../Main.c     **** 	status_t status;		// Declaration of return variable for DAVE3 APIs
  83:../Main.c     **** 
  84:../Main.c     **** 
  85:../Main.c     **** 	DAVE_Init();			// Initialization of DAVE Apps
 229              		.loc 2 85 0
 230 0006 FFF7FEFF 		bl	DAVE_Init
  86:../Main.c     **** 
  87:../Main.c     **** 	
  88:../Main.c     **** 	/* Starts the PWMSP001 App (LED) */
  89:../Main.c     **** 	status = PWMSP001_Start((PWMSP001_HandleType*)&PWMSP001_Handle0);
 231              		.loc 2 89 0
 232 000a 584B     		ldr	r3, .L32
 233 000c 181C     		mov	r0, r3
 234 000e FFF7FEFF 		bl	PWMSP001_Start
 235 0012 031C     		mov	r3, r0
 236 0014 7B60     		str	r3, [r7, #4]
  90:../Main.c     **** 	if(status != DAVEApp_SUCCESS)
 237              		.loc 2 90 0
 238 0016 7B68     		ldr	r3, [r7, #4]
 239 0018 002B     		cmp	r3, #0
 240 001a 03D0     		beq	.L18
  91:../Main.c     **** 	{
  92:../Main.c     **** 		PWMSP001_Stop((PWMSP001_HandleType*)&PWMSP001_Handle0);
 241              		.loc 2 92 0
 242 001c 534B     		ldr	r3, .L32
 243 001e 181C     		mov	r0, r3
 244 0020 FFF7FEFF 		bl	PWMSP001_Stop
 245              	.L18:
  93:../Main.c     **** 	}
  94:../Main.c     **** 
  95:../Main.c     **** 	PIN_LOW_INIT();
 246              		.loc 2 95 0
 247 0024 C020     		mov	r0, #192
 248 0026 FFF7FEFF 		bl	P0_6_set_mode
 249 002a FFF7FEFF 		bl	P0_6_set
  96:../Main.c     **** 	PIN_IS_INIT();
 250              		.loc 2 96 0
 251 002e FFF7FEFF 		bl	P0_5_set_large_hysteresis
 252 0032 FFF7FEFF 		bl	P0_5_read
  97:../Main.c     **** 
  98:../Main.c     **** 
  99:../Main.c     **** 
 100:../Main.c     **** 	bool lastPinState = PIN_IS_HIGH();
 253              		.loc 2 100 0
 254 0036 FFF7FEFF 		bl	P0_5_read
 255 003a 021C     		mov	r2, r0
 256 003c 3B1C     		mov	r3, r7
 257 003e 2733     		add	r3, r3, #39
 258 0040 1A70     		strb	r2, [r3]
 101:../Main.c     **** 	bool trigger = FALSE;
 259              		.loc 2 101 0
 260 0042 3B1C     		mov	r3, r7
 261 0044 2633     		add	r3, r3, #38
 262 0046 0022     		mov	r2, #0
 263 0048 1A70     		strb	r2, [r3]
 102:../Main.c     **** 	int noTriggerCnt=0;
 264              		.loc 2 102 0
 265 004a 0023     		mov	r3, #0
 266 004c 3B62     		str	r3, [r7, #32]
 103:../Main.c     **** 	int speed=0;
 267              		.loc 2 103 0
 268 004e 0023     		mov	r3, #0
 269 0050 FB61     		str	r3, [r7, #28]
 104:../Main.c     **** 	int speedLow=0;
 270              		.loc 2 104 0
 271 0052 0023     		mov	r3, #0
 272 0054 BB61     		str	r3, [r7, #24]
 105:../Main.c     **** 	int speedLowHigh=0;
 273              		.loc 2 105 0
 274 0056 0023     		mov	r3, #0
 275 0058 7B61     		str	r3, [r7, #20]
 106:../Main.c     **** 
 107:../Main.c     **** 	int pinCheckCycles = 100;
 276              		.loc 2 107 0
 277 005a 6423     		mov	r3, #100
 278 005c 3B60     		str	r3, [r7]
 279 005e 00E0     		b	.L30
 280              	.L31:
 108:../Main.c     **** 
 109:../Main.c     **** #define DEBUG_CNT_BUFFER_SIZE 100
 110:../Main.c     **** 	static int debugCount = 0;
 111:../Main.c     **** 	static int debugSpeedBuffer[DEBUG_CNT_BUFFER_SIZE];
 112:../Main.c     **** 
 113:../Main.c     **** 
 114:../Main.c     **** 
 115:../Main.c     **** 
 116:../Main.c     **** 
 117:../Main.c     **** 	while(1)
 118:../Main.c     **** 	{
 119:../Main.c     **** 		speed++;
 120:../Main.c     **** 		speedLow++;
 121:../Main.c     **** 		
 122:../Main.c     **** 
 123:../Main.c     **** 		int cnt_high=0;
 124:../Main.c     **** 		int cnt_low=0;
 125:../Main.c     **** 		for (int i = 0; i < pinCheckCycles; i++)
 126:../Main.c     **** 		{
 127:../Main.c     **** 			if (PIN_IS_HIGH())
 128:../Main.c     **** 				cnt_high++;
 129:../Main.c     **** 			else
 130:../Main.c     **** 				cnt_low++;
 131:../Main.c     **** 		}
 132:../Main.c     **** 		
 133:../Main.c     **** 		
 134:../Main.c     **** 		if (cnt_low > 0)
 135:../Main.c     **** 		{
 136:../Main.c     **** 			if (lastPinState)
 137:../Main.c     **** 			{
 138:../Main.c     **** 				trigger = TRUE;
 139:../Main.c     **** 				speedLowHigh = (speed<<3)/10; // *16/10/2
 140:../Main.c     **** 				debugSpeedBuffer[debugCount%DEBUG_CNT_BUFFER_SIZE] = speed;
 141:../Main.c     **** 				debugCount++;
 142:../Main.c     **** 				debugSpeedBuffer[debugCount%DEBUG_CNT_BUFFER_SIZE] = speedLowHigh;
 143:../Main.c     **** 				debugCount++;
 144:../Main.c     **** 				speed=0;
 145:../Main.c     **** 
 146:../Main.c     **** 			}
 147:../Main.c     **** 			lastPinState = FALSE;
 148:../Main.c     **** 		}
 149:../Main.c     **** 		else if (cnt_high > 0)
 150:../Main.c     **** 		{
 151:../Main.c     **** 			lastPinState = TRUE;
 152:../Main.c     **** 		}
 153:../Main.c     **** 		
 154:../Main.c     **** 		if (speedLow >= speedLowHigh)
 155:../Main.c     **** 		{
 156:../Main.c     **** 			speedLow = 0;
 157:../Main.c     **** 			
 158:../Main.c     **** 			if (!trigger)
 159:../Main.c     **** 				noTriggerCnt++;
 160:../Main.c     **** 			else
 161:../Main.c     **** 				noTriggerCnt=0;
 162:../Main.c     **** 			trigger = FALSE;
 163:../Main.c     **** 			
 164:../Main.c     **** 			if (noTriggerCnt > 1)
 165:../Main.c     **** 			{
 166:../Main.c     **** 				noTriggerCnt=1;
 167:../Main.c     **** 				PIN_LOW_DEASSERT();
 168:../Main.c     **** 			}
 169:../Main.c     **** 			else
 170:../Main.c     **** 			{
 171:../Main.c     **** 				PIN_LOW_TOGGLE();
 172:../Main.c     **** 			}
 173:../Main.c     **** 		}
 174:../Main.c     **** 
 175:../Main.c     **** 	}
 281              		.loc 2 175 0
 282 0060 C046     		mov	r8, r8
 283              	.L30:
 284              	.LBB2:
 119:../Main.c     **** 		speed++;
 285              		.loc 2 119 0
 286 0062 FB69     		ldr	r3, [r7, #28]
 287 0064 0133     		add	r3, r3, #1
 288 0066 FB61     		str	r3, [r7, #28]
 120:../Main.c     **** 		speedLow++;
 289              		.loc 2 120 0
 290 0068 BB69     		ldr	r3, [r7, #24]
 291 006a 0133     		add	r3, r3, #1
 292 006c BB61     		str	r3, [r7, #24]
 123:../Main.c     **** 		int cnt_high=0;
 293              		.loc 2 123 0
 294 006e 0023     		mov	r3, #0
 295 0070 3B61     		str	r3, [r7, #16]
 124:../Main.c     **** 		int cnt_low=0;
 296              		.loc 2 124 0
 297 0072 0023     		mov	r3, #0
 298 0074 FB60     		str	r3, [r7, #12]
 299              	.LBB3:
 125:../Main.c     **** 		for (int i = 0; i < pinCheckCycles; i++)
 300              		.loc 2 125 0
 301 0076 0023     		mov	r3, #0
 302 0078 BB60     		str	r3, [r7, #8]
 303 007a 0EE0     		b	.L19
 304              	.L22:
 127:../Main.c     **** 			if (PIN_IS_HIGH())
 305              		.loc 2 127 0
 306 007c FFF7FEFF 		bl	P0_5_read
 307 0080 031C     		mov	r3, r0
 308 0082 002B     		cmp	r3, #0
 309 0084 03D0     		beq	.L20
 128:../Main.c     **** 				cnt_high++;
 310              		.loc 2 128 0
 311 0086 3B69     		ldr	r3, [r7, #16]
 312 0088 0133     		add	r3, r3, #1
 313 008a 3B61     		str	r3, [r7, #16]
 314 008c 02E0     		b	.L21
 315              	.L20:
 130:../Main.c     **** 				cnt_low++;
 316              		.loc 2 130 0
 317 008e FB68     		ldr	r3, [r7, #12]
 318 0090 0133     		add	r3, r3, #1
 319 0092 FB60     		str	r3, [r7, #12]
 320              	.L21:
 125:../Main.c     **** 		for (int i = 0; i < pinCheckCycles; i++)
 321              		.loc 2 125 0
 322 0094 BB68     		ldr	r3, [r7, #8]
 323 0096 0133     		add	r3, r3, #1
 324 0098 BB60     		str	r3, [r7, #8]
 325              	.L19:
 125:../Main.c     **** 		for (int i = 0; i < pinCheckCycles; i++)
 326              		.loc 2 125 0 is_stmt 0 discriminator 1
 327 009a BA68     		ldr	r2, [r7, #8]
 328 009c 3B68     		ldr	r3, [r7]
 329 009e 9A42     		cmp	r2, r3
 330 00a0 ECDB     		blt	.L22
 331              	.LBE3:
 134:../Main.c     **** 		if (cnt_low > 0)
 332              		.loc 2 134 0 is_stmt 1
 333 00a2 FB68     		ldr	r3, [r7, #12]
 334 00a4 002B     		cmp	r3, #0
 335 00a6 39DD     		ble	.L23
 136:../Main.c     **** 			if (lastPinState)
 336              		.loc 2 136 0
 337 00a8 3B1C     		mov	r3, r7
 338 00aa 2733     		add	r3, r3, #39
 339 00ac 1B78     		ldrb	r3, [r3]
 340 00ae 002B     		cmp	r3, #0
 341 00b0 2FD0     		beq	.L24
 138:../Main.c     **** 				trigger = TRUE;
 342              		.loc 2 138 0
 343 00b2 3B1C     		mov	r3, r7
 344 00b4 2633     		add	r3, r3, #38
 345 00b6 0122     		mov	r2, #1
 346 00b8 1A70     		strb	r2, [r3]
 139:../Main.c     **** 				speedLowHigh = (speed<<3)/10; // *16/10/2
 347              		.loc 2 139 0
 348 00ba FB69     		ldr	r3, [r7, #28]
 349 00bc DB00     		lsl	r3, r3, #3
 350 00be 181C     		mov	r0, r3
 351 00c0 0A21     		mov	r1, #10
 352 00c2 FFF7FEFF 		bl	__aeabi_idiv
 353 00c6 031C     		mov	r3, r0
 354 00c8 7B61     		str	r3, [r7, #20]
 140:../Main.c     **** 				debugSpeedBuffer[debugCount%DEBUG_CNT_BUFFER_SIZE] = speed;
 355              		.loc 2 140 0
 356 00ca 294B     		ldr	r3, .L32+4
 357 00cc 1B68     		ldr	r3, [r3]
 358 00ce 181C     		mov	r0, r3
 359 00d0 6421     		mov	r1, #100
 360 00d2 FFF7FEFF 		bl	__aeabi_idivmod
 361 00d6 0B1C     		mov	r3, r1
 362 00d8 1A1C     		mov	r2, r3
 363 00da 264B     		ldr	r3, .L32+8
 364 00dc 9200     		lsl	r2, r2, #2
 365 00de F969     		ldr	r1, [r7, #28]
 366 00e0 D150     		str	r1, [r2, r3]
 141:../Main.c     **** 				debugCount++;
 367              		.loc 2 141 0
 368 00e2 234B     		ldr	r3, .L32+4
 369 00e4 1B68     		ldr	r3, [r3]
 370 00e6 5A1C     		add	r2, r3, #1
 371 00e8 214B     		ldr	r3, .L32+4
 372 00ea 1A60     		str	r2, [r3]
 142:../Main.c     **** 				debugSpeedBuffer[debugCount%DEBUG_CNT_BUFFER_SIZE] = speedLowHigh;
 373              		.loc 2 142 0
 374 00ec 204B     		ldr	r3, .L32+4
 375 00ee 1B68     		ldr	r3, [r3]
 376 00f0 181C     		mov	r0, r3
 377 00f2 6421     		mov	r1, #100
 378 00f4 FFF7FEFF 		bl	__aeabi_idivmod
 379 00f8 0B1C     		mov	r3, r1
 380 00fa 1A1C     		mov	r2, r3
 381 00fc 1D4B     		ldr	r3, .L32+8
 382 00fe 9200     		lsl	r2, r2, #2
 383 0100 7969     		ldr	r1, [r7, #20]
 384 0102 D150     		str	r1, [r2, r3]
 143:../Main.c     **** 				debugCount++;
 385              		.loc 2 143 0
 386 0104 1A4B     		ldr	r3, .L32+4
 387 0106 1B68     		ldr	r3, [r3]
 388 0108 5A1C     		add	r2, r3, #1
 389 010a 194B     		ldr	r3, .L32+4
 390 010c 1A60     		str	r2, [r3]
 144:../Main.c     **** 				speed=0;
 391              		.loc 2 144 0
 392 010e 0023     		mov	r3, #0
 393 0110 FB61     		str	r3, [r7, #28]
 394              	.L24:
 147:../Main.c     **** 			lastPinState = FALSE;
 395              		.loc 2 147 0
 396 0112 3B1C     		mov	r3, r7
 397 0114 2733     		add	r3, r3, #39
 398 0116 0022     		mov	r2, #0
 399 0118 1A70     		strb	r2, [r3]
 400 011a 06E0     		b	.L25
 401              	.L23:
 149:../Main.c     **** 		else if (cnt_high > 0)
 402              		.loc 2 149 0
 403 011c 3B69     		ldr	r3, [r7, #16]
 404 011e 002B     		cmp	r3, #0
 405 0120 03DD     		ble	.L25
 151:../Main.c     **** 			lastPinState = TRUE;
 406              		.loc 2 151 0
 407 0122 3B1C     		mov	r3, r7
 408 0124 2733     		add	r3, r3, #39
 409 0126 0122     		mov	r2, #1
 410 0128 1A70     		strb	r2, [r3]
 411              	.L25:
 154:../Main.c     **** 		if (speedLow >= speedLowHigh)
 412              		.loc 2 154 0
 413 012a BA69     		ldr	r2, [r7, #24]
 414 012c 7B69     		ldr	r3, [r7, #20]
 415 012e 9A42     		cmp	r2, r3
 416 0130 96DB     		blt	.L31
 156:../Main.c     **** 			speedLow = 0;
 417              		.loc 2 156 0
 418 0132 0023     		mov	r3, #0
 419 0134 BB61     		str	r3, [r7, #24]
 158:../Main.c     **** 			if (!trigger)
 420              		.loc 2 158 0
 421 0136 3B1C     		mov	r3, r7
 422 0138 2633     		add	r3, r3, #38
 423 013a 1B78     		ldrb	r3, [r3]
 424 013c 002B     		cmp	r3, #0
 425 013e 03D1     		bne	.L27
 159:../Main.c     **** 				noTriggerCnt++;
 426              		.loc 2 159 0
 427 0140 3B6A     		ldr	r3, [r7, #32]
 428 0142 0133     		add	r3, r3, #1
 429 0144 3B62     		str	r3, [r7, #32]
 430 0146 01E0     		b	.L28
 431              	.L27:
 161:../Main.c     **** 				noTriggerCnt=0;
 432              		.loc 2 161 0
 433 0148 0023     		mov	r3, #0
 434 014a 3B62     		str	r3, [r7, #32]
 435              	.L28:
 162:../Main.c     **** 			trigger = FALSE;
 436              		.loc 2 162 0
 437 014c 3B1C     		mov	r3, r7
 438 014e 2633     		add	r3, r3, #38
 439 0150 0022     		mov	r2, #0
 440 0152 1A70     		strb	r2, [r3]
 164:../Main.c     **** 			if (noTriggerCnt > 1)
 441              		.loc 2 164 0
 442 0154 3B6A     		ldr	r3, [r7, #32]
 443 0156 012B     		cmp	r3, #1
 444 0158 04DD     		ble	.L29
 166:../Main.c     **** 				noTriggerCnt=1;
 445              		.loc 2 166 0
 446 015a 0123     		mov	r3, #1
 447 015c 3B62     		str	r3, [r7, #32]
 167:../Main.c     **** 				PIN_LOW_DEASSERT();
 448              		.loc 2 167 0
 449 015e FFF7FEFF 		bl	P0_6_set
 450              	.LBE2:
 451              		.loc 2 175 0
 452 0162 7DE7     		b	.L31
 453              	.L29:
 454              	.LBB4:
 171:../Main.c     **** 				PIN_LOW_TOGGLE();
 455              		.loc 2 171 0
 456 0164 FFF7FEFF 		bl	P0_6_toggle
 457              	.LBE4:
 458              		.loc 2 175 0
 459 0168 7AE7     		b	.L31
 460              	.L33:
 461 016a C046     		.align	2
 462              	.L32:
 463 016c 00000000 		.word	PWMSP001_Handle0
 464 0170 0C000000 		.word	debugCount.5894
 465 0174 10000000 		.word	debugSpeedBuffer.5895
 466              		.cfi_endproc
 467              	.LFE402:
 469              		.global	__aeabi_uidivmod
 470              		.global	__aeabi_ui2f
 471              		.section	.text.CCU40_3_IRQHandler,"ax",%progbits
 472              		.align	2
 473              		.global	CCU40_3_IRQHandler
 474              		.code	16
 475              		.thumb_func
 477              	CCU40_3_IRQHandler:
 478              	.LFB403:
 176:../Main.c     **** 	return 0;
 177:../Main.c     **** }
 178:../Main.c     **** 
 179:../Main.c     **** 
 180:../Main.c     **** /*
 181:../Main.c     ****  * PWM_Period_Interrupt handler: executes every period match of PWMSP001/0.
 182:../Main.c     ****  */
 183:../Main.c     **** void PWM_Period_Interrupt(void)
 184:../Main.c     **** {
 479              		.loc 2 184 0
 480              		.cfi_startproc
 481 0000 80B5     		push	{r7, lr}
 482              	.LCFI14:
 483              		.cfi_def_cfa_offset 8
 484              		.cfi_offset 7, -8
 485              		.cfi_offset 14, -4
 486 0002 00AF     		add	r7, sp, #0
 487              	.LCFI15:
 488              		.cfi_def_cfa_register 7
 185:../Main.c     **** //#define FFAST   10
 186:../Main.c     **** //#define FSLOW   1
 187:../Main.c     **** //#define FASTCYCLES (FFAST*6)
 188:../Main.c     **** //#define SLOWCYCLES (FSLOW*6)
 189:../Main.c     **** 
 190:../Main.c     **** #define MAXFREQ 7
 191:../Main.c     **** 
 192:../Main.c     **** 
 193:../Main.c     **** 	static uint32_t state = 0;
 194:../Main.c     **** 	static uint32_t cycles = 0;
 195:../Main.c     **** 	static status_t status = DAVEApp_SUCCESS;
 196:../Main.c     **** 
 197:../Main.c     **** 	/* state machine to change the different duty cycle */
 198:../Main.c     **** 	if (cycles == 0)
 489              		.loc 2 198 0
 490 0004 1B4B     		ldr	r3, .L36
 491 0006 1B68     		ldr	r3, [r3]
 492 0008 002B     		cmp	r3, #0
 493 000a 2BD1     		bne	.L35
 199:../Main.c     **** 	{
 200:../Main.c     **** 		cycles = (state%MAXFREQ) + 1;
 494              		.loc 2 200 0
 495 000c 1A4B     		ldr	r3, .L36+4
 496 000e 1B68     		ldr	r3, [r3]
 497 0010 181C     		mov	r0, r3
 498 0012 0721     		mov	r1, #7
 499 0014 FFF7FEFF 		bl	__aeabi_uidivmod
 500 0018 0B1C     		mov	r3, r1
 501 001a 5A1C     		add	r2, r3, #1
 502 001c 154B     		ldr	r3, .L36
 503 001e 1A60     		str	r2, [r3]
 201:../Main.c     **** 		status = PWMSP001_SetPwmFreqAndDutyCycle((PWMSP001_HandleType*)&PWMSP001_Handle0, cycles, 50);
 504              		.loc 2 201 0
 505 0020 144B     		ldr	r3, .L36
 506 0022 1B68     		ldr	r3, [r3]
 507 0024 181C     		mov	r0, r3
 508 0026 FFF7FEFF 		bl	__aeabi_ui2f
 509 002a 021C     		add	r2, r0, #0
 510 002c 1349     		ldr	r1, .L36+8
 511 002e 144B     		ldr	r3, .L36+12
 512 0030 081C     		mov	r0, r1
 513 0032 111C     		add	r1, r2, #0
 514 0034 1A1C     		add	r2, r3, #0
 515 0036 FFF7FEFF 		bl	PWMSP001_SetPwmFreqAndDutyCycle
 516 003a 021C     		mov	r2, r0
 517 003c 114B     		ldr	r3, .L36+16
 518 003e 1A60     		str	r2, [r3]
 202:../Main.c     **** 		cycles = cycles<<2;
 519              		.loc 2 202 0
 520 0040 0C4B     		ldr	r3, .L36
 521 0042 1B68     		ldr	r3, [r3]
 522 0044 9A00     		lsl	r2, r3, #2
 523 0046 0B4B     		ldr	r3, .L36
 524 0048 1A60     		str	r2, [r3]
 203:../Main.c     **** 
 204:../Main.c     **** 
 205:../Main.c     **** 
 206:../Main.c     **** //		switch(state&0x1)
 207:../Main.c     **** //		{
 208:../Main.c     **** //
 209:../Main.c     **** //			case 0: //status =  PWMSP001_SetCompare(&PWMSP001_Handle0, 0x4AFF); /* Updating of duty cycle 
 210:../Main.c     **** //				status = PWMSP001_SetPwmFreqAndDutyCycle((PWMSP001_HandleType*)&PWMSP001_Handle0, FFAST, 50);
 211:../Main.c     **** //				cycles = FASTCYCLES;
 212:../Main.c     **** //				break;
 213:../Main.c     **** //
 214:../Main.c     **** //			default: //status =  PWMSP001_SetCompare(&PWMSP001_Handle0, 0x0855); /* Updating of duty cycle
 215:../Main.c     **** //				status = PWMSP001_SetPwmFreqAndDutyCycle((PWMSP001_HandleType*)&PWMSP001_Handle0, FSLOW, 50);
 216:../Main.c     **** //				cycles = SLOWCYCLES;
 217:../Main.c     **** //				break;
 218:../Main.c     **** //
 219:../Main.c     **** //		}
 220:../Main.c     **** 		state++;
 525              		.loc 2 220 0
 526 004a 0B4B     		ldr	r3, .L36+4
 527 004c 1B68     		ldr	r3, [r3]
 528 004e 5A1C     		add	r2, r3, #1
 529 0050 094B     		ldr	r3, .L36+4
 530 0052 1A60     		str	r2, [r3]
 221:../Main.c     **** 		if(status != DAVEApp_SUCCESS)
 531              		.loc 2 221 0
 532 0054 0B4B     		ldr	r3, .L36+16
 533 0056 1B68     		ldr	r3, [r3]
 534 0058 002B     		cmp	r3, #0
 535 005a 03D0     		beq	.L35
 222:../Main.c     **** 		{
 223:../Main.c     **** 			PWMSP001_Stop((PWMSP001_HandleType*)&PWMSP001_Handle0);
 536              		.loc 2 223 0
 537 005c 074B     		ldr	r3, .L36+8
 538 005e 181C     		mov	r0, r3
 539 0060 FFF7FEFF 		bl	PWMSP001_Stop
 540              	.L35:
 224:../Main.c     **** 		}
 225:../Main.c     **** 	}
 226:../Main.c     **** 
 227:../Main.c     **** 	/* Updation of the state machine */
 228:../Main.c     **** 
 229:../Main.c     **** 	cycles--;
 541              		.loc 2 229 0
 542 0064 034B     		ldr	r3, .L36
 543 0066 1B68     		ldr	r3, [r3]
 544 0068 5A1E     		sub	r2, r3, #1
 545 006a 024B     		ldr	r3, .L36
 546 006c 1A60     		str	r2, [r3]
 230:../Main.c     **** //	if(state>=PERIODE)
 231:../Main.c     **** //	{
 232:../Main.c     **** //		state= 0;
 233:../Main.c     **** //	}
 234:../Main.c     **** 
 235:../Main.c     **** 
 236:../Main.c     **** }
 547              		.loc 2 236 0
 548 006e BD46     		mov	sp, r7
 549              		@ sp needed for prologue
 550 0070 80BD     		pop	{r7, pc}
 551              	.L37:
 552 0072 C046     		.align	2
 553              	.L36:
 554 0074 00000000 		.word	cycles.5907
 555 0078 04000000 		.word	state.5906
 556 007c 00000000 		.word	PWMSP001_Handle0
 557 0080 00004842 		.word	1112014848
 558 0084 08000000 		.word	status.5908
 559              		.cfi_endproc
 560              	.LFE403:
 562              		.bss
 563              		.align	2
 564              	cycles.5907:
 565 0000 00000000 		.space	4
 566              		.align	2
 567              	state.5906:
 568 0004 00000000 		.space	4
 569              		.align	2
 570              	status.5908:
 571 0008 00000000 		.space	4
 572              		.align	2
 573              	debugCount.5894:
 574 000c 00000000 		.space	4
 575              		.align	2
 576              	debugSpeedBuffer.5895:
 577 0010 00000000 		.space	400
 577      00000000 
 577      00000000 
 577      00000000 
 577      00000000 
 578              		.text
 579              	.Letext0:
 580              		.file 3 "c:\\dave-3.1.10\\arm-gcc\\bin\\../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none-eabi/i
 581              		.file 4 "C:\\DAVE-3.1.10\\eclipse\\/../CMSIS/Infineon/XMC1100_series/Include/XMC1100.h"
 582              		.file 5 "C:\\DAVE3_workspace\\ws3.1.10\\boschSpeedUp\\Dave\\Generated\\inc\\DAVESupport/../../inc/
 583              		.file 6 "C:\\DAVE3_workspace\\ws3.1.10\\boschSpeedUp\\Dave\\Generated\\inc\\DAVESupport/../../inc/
 584              		.file 7 "C:\\DAVE3_workspace\\ws3.1.10\\boschSpeedUp\\Dave\\Generated\\inc\\DAVESupport/../../inc/
DEFINED SYMBOLS
                            *ABS*:00000000 Main.c
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:18     .text.P0_5_set_large_hysteresis:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:22     .text.P0_5_set_large_hysteresis:00000000 P0_5_set_large_hysteresis
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:50     .text.P0_5_set_large_hysteresis:00000018 $d
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:55     .text.P0_5_read:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:59     .text.P0_5_read:00000000 P0_5_read
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:84     .text.P0_5_read:00000014 $d
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:89     .text.P0_6_set_mode:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:93     .text.P0_6_set_mode:00000000 P0_6_set_mode
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:135    .text.P0_6_set_mode:00000030 $d
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:141    .text.P0_6_set:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:145    .text.P0_6_set:00000000 P0_6_set
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:168    .text.P0_6_set:00000010 $d
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:173    .text.P0_6_toggle:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:177    .text.P0_6_toggle:00000000 P0_6_toggle
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:200    .text.P0_6_toggle:00000010 $d
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:208    .text.main:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:213    .text.main:00000000 main
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:463    .text.main:0000016c $d
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:573    .bss:0000000c debugCount.5894
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:576    .bss:00000010 debugSpeedBuffer.5895
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:472    .text.CCU40_3_IRQHandler:00000000 $t
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:477    .text.CCU40_3_IRQHandler:00000000 CCU40_3_IRQHandler
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:554    .text.CCU40_3_IRQHandler:00000074 $d
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:564    .bss:00000000 cycles.5907
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:567    .bss:00000004 state.5906
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:570    .bss:00000008 status.5908
C:\Users\Patrick\AppData\Local\Temp\ccwraVgG.s:563    .bss:00000000 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.63d3e0297d6e9004e0e37a0840833abd
                           .group:00000000 wm4.XMC1100.h.45.7a7cd799d7738130fcda8b83b0aa37d4
                           .group:00000000 wm4.core_cm0.h.47.022e66414e77714da7c4b30b3ad99fe8
                           .group:00000000 wm4.newlib.h.8.a9901dc52d1357e3e94003403d43f8b5
                           .group:00000000 wm4.features.h.22.b72b3baab2bb2eab3661375590100b6b
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.7aefdac4826acebbfc9f3822a0aeb14c
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.core_cmInstr.h.39.b7b6650bdd2316848d940915272d75b8
                           .group:00000000 wm4.core_cm0.h.135.ca70469f87e143609670bb393bfa6518
                           .group:00000000 wm4.XMC1000_RomFunctionTable.h.31.6d9a94465618f31b040dc9cea9a47ad7
                           .group:00000000 wm4.XMC1100.h.114.be3711f71ee045884346be801053f4c0
                           .group:00000000 wm4.stddef.h.40.50cf36416e06376af8a9dca28536f2e4
                           .group:00000000 wm4.types.h.60.e75c47576398c648cdcf9000ace5e3d8
                           .group:00000000 wm4.MULTIPLEXER.h.46.383e3edbb9cbf6e538f7c1532ef623c1
                           .group:00000000 wm4.uc_id.h.35.47f40be5760de9fc3332688f9e95febc
                           .group:00000000 wm4.CCU4Global_Conf.h.63.a52fac0daa39b5f58343578312b4eb54
                           .group:00000000 wm4.PWMSP001.h.57.29b732b86baf3e81f49153f5f495912e
                           .group:00000000 wm4.NVIC002_Conf.h.62.18166a449b9ed77d0131aa9be7c23c90
                           .group:00000000 wm4.GPIO.h.2.93bf17ee3a853f64308a0e4d0c9f6a08

UNDEFINED SYMBOLS
__aeabi_idiv
__aeabi_idivmod
DAVE_Init
PWMSP001_Start
PWMSP001_Stop
PWMSP001_Handle0
__aeabi_uidivmod
__aeabi_ui2f
PWMSP001_SetPwmFreqAndDutyCycle
