package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class pwmsp001c_template
{
  protected static String nl;
  public static synchronized pwmsp001c_template create(String lineSeparator)
  {
    nl = lineSeparator;
    pwmsp001c_template result = new pwmsp001c_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + NL + "/*CODE_BLOCK_BEGIN[PWMSP001.c]*/" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + " Copyright (c) 2014, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without**" + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000/XMC1000 Series                                 **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR   : App Developer                                                   **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : April 28, 2014                                         **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "/*******************************************************************************" + NL + "**                      Author(s) Identity                                    **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials     Name                                                          **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** KS           App Developer                                                 **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/**" + NL + " * @file  PWMSP001.c" + NL + " *" + NL + " * @brief This file contains implementations of all Public and Private functions" + NL + " *        of Single Phase PWM without dead time APP." + NL + " *        This app generates the single PWM waveform without dead time. " + NL + " *        Duty cycle can be changed at runtime. And PWM frequency can be changed" + NL + " *        when timer is not running." + NL + " */" + NL + "" + NL + "/* Revision History\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  " + NL + " * 21 Nov 2012   v1.0.16   coding guidelines  " + NL + " * 10 Dec 2012   v1.0.18   DBG002 Macros are added" + NL + " * 1  Feb 2013   v1.0.20   PDR register constraints are added" + NL + " * 26 Mar 2013   v1.0.22   DAVE3.H inclusion" + NL + " * 22 Apr 2013   v1.0.24   MCSW300000628 utp w.r.t open drain port configuration" + NL + " *                         is fixed" + NL + " * \t\t\t\t\t\t   MCSW300000629 utp w.r.t SetCompare API is fixed by " + NL + " *                         fetching period value from register instead from UI " + NL + " *                         parameter" + NL + " * \t\t\t\t\t\t   Removed the inclusion of other header files" + NL + " *                                                  (PWMSP001.h,PWMSP001_Conf.c)" + NL + " * 30 Aug 2013   v1.0.26   Defect 32385 fix: Duty cycle updation issue when not " + NL + " *                         using timer concatenation in " + NL + " *                         PWMSP001_SetPwmFreqAndDutyCycle() API is fixed." + NL + " * 17 Feb 2014   v1.0.32   1.Trap enabling is shifted from PWMSP001_Start() to" + NL + " *                           PWMSP001_Init()" + NL + " *                         2.In PWMSP001_lSetDutyEdgeAlignTimerConcat()compare" + NL + " *                          value calculation is updated." + NL + " *                         3.During Timer concatenation if single shot mode is " + NL + " *                          enabled lower timer is made as free running." + NL + " * 28 Apr 2014   v1.0.34   Removed the DBG002_FUNCTION_ENTRY() and " + NL + " *                         DBG002_FUNCTION_EXIT() from all the APIs." + NL + " *                         In PWMSP001_SetCompare() period value checks are " + NL + " *                         removed." + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Include Files                                         **" + NL + "*******************************************************************************/" + NL + "#include <DAVE3.h>" + NL;
  protected final String TEXT_2 = NL;
  protected final String TEXT_3 = "  " + NL + "/*****************************************************************************" + NL + "              DUMMY DEFINTIONS OF DEBUG LOG MACROS" + NL + "*****************************************************************************/" + NL + "/*These definitions are included here to avoid compilation errors," + NL + " since the DBG002 app is not part of the project. All the macros are defined" + NL + " as empty*/ " + NL + "#ifndef _DBG002_H_" + NL + "" + NL + "#define DBG002_RegisterCallBack(A,B,C)" + NL + "#define DBG002_I(e) " + NL + "#define DBG002_IG(e,g) " + NL + "#define DBG002_IH(e,h) " + NL + "#define DBG002_IP(e,p) " + NL + "#define DBG002_IGH(e,g,h) " + NL + "#define DBG002_IGP(e,g,p) " + NL + "#define DBG002_IHP(e,h,p) " + NL + "#define DBG002_IGHP(e,g,h,p) " + NL + "#define DBG002_N(e) " + NL + "#define DBG002_NG(e,g) " + NL + "#define DBG002_NH(e,h) " + NL + "#define DBG002_NP(e,p) " + NL + "#define DBG002_NGH(e,g,h) " + NL + "#define DBG002_NGP(e,g,p) " + NL + "#define DBG002_NHP(e,h,p) " + NL + "#define DBG002_NGHP(e,g,h,p) " + NL + "#define DBG002_ID(e) " + NL + "#define DBG002_IS(e) " + NL + "#define DBG002_ISG(e,g) " + NL + "#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_ERROR(groupid,messageid,length,value)" + NL + "#define DBG002_WARNING(groupid,messageid,length,value)" + NL + "#define DBG002_INFO(groupid,messageid,length,value)" + NL + "#define DBG002_TRACE(groupid,messageid,length,value)" + NL + "#define DBG002_FUNCTION_ENTRY(GID, Status) " + NL + "#define DBG002_FUNCTION_EXIT(GID, Status) " + NL + "#define DBG002_MESSAGEID_LITERAL" + NL + "#endif/* End of definitions of dummy Debug Log macros*/";
  protected final String TEXT_4 = "   " + NL + "#define APP_GID DBG002_GID_PWMSP001" + NL + "" + NL + "#define PWMSP001_STATUS_LEN 4U" + NL + "/*******************************************************************************" + NL + " **                 Private Function declarations                              **" + NL + " *******************************************************************************/" + NL + "/**" + NL + " * @cond INTERNAL_DOCS" + NL + " */" + NL + "/**" + NL + " * @ingroup PWMSP001_privatefunc" + NL + " * @{" + NL + " */" + NL + "" + NL + "/**" + NL + " * @brief This function will initialize second slice registers (in case of timer" + NL + " * concatenation) with user configured value" + NL + " * @param[in]   HandlePtr Pointer to PWMSP001_HandleType structure" + NL + " * @return void" + NL + " */" + NL + "void PWMSP001_lConfigureSecondSlice" + NL + "(" + NL + "    const PWMSP001_HandleType* HandlePtr" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function will set duty cycle if center aligned mode is selected." + NL + " * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure" + NL + " * @param[in]  Duty This is duty cycle in percentage" + NL + " * @return status_t void" + NL + " */" + NL + "void PWMSP001_lSetDutyCenterAlign" + NL + "(" + NL + "    void* Handle," + NL + "    float Duty" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function will set duty cycle if edge aligned mode without timer concatenation is selected." + NL + " * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure" + NL + " * @param[in]  Duty This is duty cycle in percentage" + NL + " * @return status_t void" + NL + " */" + NL + "void PWMSP001_lSetDutyEdgeAlign" + NL + "(" + NL + "    void* Handle," + NL + "    float Duty" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function will set duty cycle if edge aligned mode with timer concatenation is supported." + NL + " * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure" + NL + " * @param[in]  Duty This is duty cycle in percentage" + NL + " * @return status_t void" + NL + " */" + NL + "void PWMSP001_lSetDutyEdgeAlignTimerConcat" + NL + "(" + NL + "    void* Handle," + NL + "    float Duty" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function will set duty cycle if center aligned mode is selected." + NL + " * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure" + NL + " * @param[in]  Compare This is duty cycle in percentage" + NL + " * @return status_t void" + NL + " */" + NL + "void PWMSP001_lSetCompareCenterAlign" + NL + "(" + NL + "    void* Handle," + NL + "    uint32_t Compare" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function will set duty cycle if edge aligned mode without timer concatenation is selected." + NL + " * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure" + NL + " * @param[in]  Compare This is duty cycle in percentage" + NL + " * @return status_t void" + NL + " */" + NL + "void PWMSP001_lSetCompareEdgeAlign" + NL + "(" + NL + "    void* Handle," + NL + "    uint32_t Compare" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function will set duty cycle if edge aligned mode with timer concatenation is supported." + NL + " * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure" + NL + " * @param[in]  Compare This is duty cycle in percentage" + NL + " * @return status_t void" + NL + " */" + NL + "void PWMSP001_lSetCompareEdgeAlignTimerConcat" + NL + "(" + NL + "    void* Handle," + NL + "    uint32_t Compare" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function will set pwm frequency if timer concatenation is selected" + NL + " * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure" + NL + " * @param[in]  PwmTime This is PWM frequency in hertz." + NL + " * @return status_t status" + NL + " */" + NL + "status_t PWMSP001_lSetPwmFreqTimerConcat" + NL + "(" + NL + "    const PWMSP001_HandleType* HandlePtr," + NL + "    uint32_t PwmTime" + NL + ");" + NL + "" + NL + "/**" + NL + " * @brief This function initializes CCU4 slice as per GUI configurations." + NL + " * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure" + NL + " * @return status_t status" + NL + " */" + NL + "status_t PWMSP001_lInit(const PWMSP001_HandleType* HandlePtr);" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + " **                 Function definitions                                       **" + NL + " *******************************************************************************/" + NL;
  protected final String TEXT_5 = "   ";
  protected final String TEXT_6 = NL + "/* This function initializes the app */" + NL + "void PWMSP001_Init(void)" + NL + "{" + NL + "  status_t Error = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "  CCU4GLOBAL_Init();";
  protected final String TEXT_7 = NL + "  Error = PWMSP001_lInit((PWMSP001_HandleType*) &PWMSP001_Handle";
  protected final String TEXT_8 = ");" + NL + "  /* Start the app if \"Start after initialization\" is checked */" + NL + "  if(Error == (uint32_t)DAVEApp_SUCCESS)" + NL + "  {   " + NL + "    if (PWMSP001_Handle";
  protected final String TEXT_9 = ".StartControl == (uint8_t)SET)" + NL + "    {" + NL + "      Error = PWMSP001_Start((PWMSP001_HandleType*) &PWMSP001_Handle";
  protected final String TEXT_10 = ");" + NL + "      DBG002_N(Error != DAVEApp_SUCCESS);" + NL + "    }" + NL + "  }";
  protected final String TEXT_11 = NL + "    ";
  protected final String TEXT_12 = NL + "      /* Configuration of Direct Output Pin ";
  protected final String TEXT_13 = ".";
  protected final String TEXT_14 = " based on User configuration */";
  protected final String TEXT_15 = NL + "      PORT";
  protected final String TEXT_16 = "->PDR0  &= (uint32_t)(~(PORT";
  protected final String TEXT_17 = "_PDR0_PD";
  protected final String TEXT_18 = "_Msk));" + NL + "      PORT";
  protected final String TEXT_19 = "->PDR0  |= (((uint32_t)";
  protected final String TEXT_20 = " << (uint32_t)PORT";
  protected final String TEXT_21 = "_PDR0_PD";
  protected final String TEXT_22 = "_Pos) & \\" + NL + "                               (uint32_t)PORT";
  protected final String TEXT_23 = "_PDR0_PD";
  protected final String TEXT_24 = "_Msk);";
  protected final String TEXT_25 = NL + "      PORT";
  protected final String TEXT_26 = "->PDR1 &= (uint32_t)(~(PORT";
  protected final String TEXT_27 = "_PDR1_PD";
  protected final String TEXT_28 = "_Msk));" + NL + "      PORT";
  protected final String TEXT_29 = "->PDR1 |= (((uint32_t)";
  protected final String TEXT_30 = " << (uint32_t)PORT";
  protected final String TEXT_31 = "_PDR1_PD";
  protected final String TEXT_32 = "_Pos) & \\" + NL + "                               (uint32_t)PORT";
  protected final String TEXT_33 = "_PDR1_PD";
  protected final String TEXT_34 = "_Msk);";
  protected final String TEXT_35 = NL + "      PORT";
  protected final String TEXT_36 = "->IOCR0  &= (uint32_t)(~(PORT_IOCR_PC";
  protected final String TEXT_37 = "_PO_Msk));" + NL + "      PORT";
  protected final String TEXT_38 = "->IOCR0  |= (((uint32_t)";
  protected final String TEXT_39 = " << (uint32_t)PORT_IOCR_PC";
  protected final String TEXT_40 = "_PO_Pos) & \\" + NL + "                                   (uint32_t)PORT_IOCR_PC";
  protected final String TEXT_41 = "_PO_Msk);";
  protected final String TEXT_42 = NL + "      PORT";
  protected final String TEXT_43 = "->IOCR4  &= (uint32_t)(~(PORT_IOCR_PC";
  protected final String TEXT_44 = "_PO_Msk));" + NL + "      PORT";
  protected final String TEXT_45 = "->IOCR4  |= (((uint32_t)";
  protected final String TEXT_46 = " << (uint32_t)PORT_IOCR_PC";
  protected final String TEXT_47 = "_PO_Pos) & \\" + NL + "                                   (uint32_t)PORT_IOCR_PC";
  protected final String TEXT_48 = "_PO_Msk);";
  protected final String TEXT_49 = NL + "      PORT";
  protected final String TEXT_50 = "->IOCR8  &= (uint32_t)(~(PORT_IOCR_PC";
  protected final String TEXT_51 = "_PO_Msk));" + NL + "      PORT";
  protected final String TEXT_52 = "->IOCR8  |= (((uint32_t)";
  protected final String TEXT_53 = " << (uint32_t)PORT_IOCR_PC";
  protected final String TEXT_54 = "_PO_Pos) & \\" + NL + "                                   (uint32_t)PORT_IOCR_PC";
  protected final String TEXT_55 = "_PO_Msk);";
  protected final String TEXT_56 = NL + "      PORT";
  protected final String TEXT_57 = "->IOCR12  &= (uint32_t)(~(PORT_IOCR_PC";
  protected final String TEXT_58 = "_PO_Msk));" + NL + "      PORT";
  protected final String TEXT_59 = "->IOCR12  |= (((uint32_t)";
  protected final String TEXT_60 = " << (uint32_t)PORT_IOCR_PC";
  protected final String TEXT_61 = "_PO_Pos) & \\" + NL + "                                   (uint32_t)PORT_IOCR_PC";
  protected final String TEXT_62 = "_PO_Msk);";
  protected final String TEXT_63 = NL + "      /* Direct Output Pin instance (no.";
  protected final String TEXT_64 = ") is not mapped to any port pin. */";
  protected final String TEXT_65 = NL + "}" + NL + "" + NL + "/*<<<DD_PWMSP001_API_1>>>*/" + NL + "/* This function initializes an instance of the app */" + NL + "status_t PWMSP001_lInit(const PWMSP001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  do" + NL + "  {" + NL + "    /*<<<DD_PWMSP001_API_1_1>>>*/" + NL + "    if (HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    HandlePtr->CC4yRegsPtr->TCCLR = PWMSP001_SLICE_CLEAR;" + NL + "" + NL + "    /*<<<DD_PWMSP001_API_1_3>>>*/" + NL + "    /* If external stop trigger is setelected */" + NL + "    if (HandlePtr->kExtStopTrig == (uint8_t)SET)" + NL + "    {" + NL + "      HandlePtr->CC4yRegsPtr->INS &= (uint32_t)~((uint32_t)CCU4_CC4_INS_EV1EM_Msk | CCU4_CC4_INS_LPF1M_Msk);" + NL + "      HandlePtr->CC4yRegsPtr->CMC &= (uint32_t)~CCU4_CC4_CMC_ENDS_Msk;" + NL + "      HandlePtr->CC4yRegsPtr->INS |= ((((uint32_t)HandlePtr->kStopEdge << (uint32_t)CCU4_CC4_INS_EV1EM_Pos)\\" + NL + "\t    & (uint32_t)CCU4_CC4_INS_EV1EM_Msk)| (((uint32_t)PWMSP001_LPF  << (uint32_t)CCU4_CC4_INS_LPF1M_Pos)\\" + NL + "\t\t  & (uint32_t)CCU4_CC4_INS_LPF1M_Msk));" + NL + "" + NL + "      HandlePtr->CC4yRegsPtr->CMC |= (((uint32_t)PWMSP001_EVENT_1  <<" + NL + "          (uint32_t)CCU4_CC4_CMC_ENDS_Pos)& (uint32_t)CCU4_CC4_CMC_ENDS_Msk);" + NL + "    }/*End of if (HandlePtr->kExtStopTrig == SET)*/" + NL + "" + NL + "    /*<<<DD_PWMSP001_API_1_4>>>*/" + NL + "    /* Trap configurations if trap is enabled */" + NL + "    if ((HandlePtr->kTrapEnable == (uint8_t)SET) &&\\" + NL + "        ((HandlePtr->kTimerConcatenation != (uint8_t)SET))" + NL + "    )" + NL + "    {" + NL + "      HandlePtr->CC4yRegsPtr -> INS &= ~((uint32_t)CCU4_CC4_INS_EV2EM_Msk | \\" + NL + "\t    (uint32_t)CCU4_CC4_INS_EV2LM_Msk | (uint32_t)CCU4_CC4_INS_LPF2M_Msk);" + NL + "      HandlePtr->CC4yRegsPtr->CMC &= (uint32_t)~CCU4_CC4_CMC_TS_Msk;" + NL + "      HandlePtr->CC4yRegsPtr -> INS |= ((((uint32_t)0 << (uint32_t)CCU4_CC4_INS_EV2EM_Pos)\\" + NL + "\t    &(uint32_t)CCU4_CC4_INS_EV2EM_Msk) | (((uint32_t)HandlePtr->kTrapLevel  <<\t\\" + NL + "\t\t  (uint32_t)CCU4_CC4_INS_EV2LM_Pos)& (uint32_t)CCU4_CC4_INS_EV2LM_Msk ) | \\" + NL + "\t\t    (((uint32_t)0 << (uint32_t)CCU4_CC4_INS_LPF2M_Pos)& \\" + NL + "\t\t\t  (uint32_t)CCU4_CC4_INS_LPF2M_Msk));" + NL + "" + NL + "      HandlePtr->CC4yRegsPtr->CMC |= ((uint32_t)1 << (uint32_t)CCU4_CC4_CMC_TS_Pos);" + NL + "    }/* End of  if (HandlePtr->kTrapEnable == (uint8_t)SET)*/" + NL + "    " + NL + "    HandlePtr->CC4yRegsPtr->TC &= ~((uint32_t)CCU4_CC4_TC_TCM_Msk | \\" + NL + "\t   (uint32_t)CCU4_CC4_TC_CMOD_Msk | (uint32_t)CCU4_CC4_TC_STRM_Msk | \\" + NL + "\t   (uint32_t)CCU4_CC4_TC_ENDM_Msk | (uint32_t)CCU4_CC4_TC_DITHE_Msk);" + NL + "    " + NL + "    HandlePtr->CC4yRegsPtr->TC |= (((uint32_t)HandlePtr->CountingModeType << \\" + NL + "\t  (uint32_t)CCU4_CC4_TC_TCM_Pos)& (uint32_t)CCU4_CC4_TC_TCM_Msk)|\\" + NL + "\t\t  (((uint32_t)PWMSP001_COMPARE_MODE  << \\" + NL + "\t\t    (uint32_t)CCU4_CC4_TC_CMOD_Pos)& (uint32_t)CCU4_CC4_TC_CMOD_Msk)| \\" + NL + "\t\t\t  (((uint32_t)HandlePtr->ExtStartConfigType  << (uint32_t)CCU4_CC4_TC_STRM_Pos)\\" + NL + "\t\t\t    &(uint32_t)CCU4_CC4_TC_STRM_Msk)|(((uint32_t)HandlePtr->ExtStopConfigType <<\\" + NL + "\t\t\t\t  (uint32_t)CCU4_CC4_TC_ENDM_Pos)& (uint32_t)CCU4_CC4_TC_ENDM_Msk);" + NL + "    /*" + NL + "     * If timer concatenation is enabled during single shot mode lower timer " + NL + "     * should be free running" + NL + "     */" + NL + "\tif (HandlePtr->kTimerConcatenation != (uint8_t)SET)" + NL + "\t{" + NL + "\t\tWR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TSSM_Msk, \\" + NL + "\t\t\t  \t\t  (uint32_t)CCU4_CC4_TC_TSSM_Pos, HandlePtr->kTimerMode);" + NL + "\t} " + NL + "    " + NL + "    /*Set the dither mode setting*/" + NL + "    HandlePtr->CC4yRegsPtr->TC |= ((uint32_t)HandlePtr->kDitherSetting << \\" + NL + "\t  (uint32_t)CCU4_CC4_TC_DITHE_Pos) & (uint32_t)CCU4_CC4_TC_DITHE_Msk ;" + NL + "    " + NL + "    WR_REG(HandlePtr->CC4yRegsPtr->DITS,(uint32_t)CCU4_CC4_DITS_DCVS_Msk,\\" + NL + "      (uint32_t)CCU4_CC4_DITS_DCVS_Pos, HandlePtr->kDitherCompare);" + NL + "" + NL + "    /*Configure Trap mode as per GUI*/" + NL + "    if(HandlePtr->kTimerConcatenation != (uint8_t)SET)" + NL + "    {" + NL + "      /*<<<DD_PWMSP001_API_1_6>>>*/" + NL + "      WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRPSE_Msk," + NL + "          (uint32_t)CCU4_CC4_TC_TRPSE_Pos, HandlePtr->kTrapSync);" + NL + "" + NL + "      WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRPSW_Msk," + NL + "          (uint32_t)CCU4_CC4_TC_TRPSW_Pos, HandlePtr->kTrapExitControl);" + NL + "      " + NL + "\t  WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRAPE_Msk, \\" + NL + "\t\t  (uint32_t)CCU4_CC4_TC_TRAPE_Pos, HandlePtr->kTrapEnable);" + NL + "    }" + NL + "    /*Set the prescalar divider and passive level of the o/p signal.*/" + NL + "    WR_REG(HandlePtr->CC4yRegsPtr->PSC, (uint32_t)CCU4_CC4_PSC_PSIV_Msk,\\" + NL + "      (uint32_t)CCU4_CC4_PSC_PSIV_Pos, HandlePtr->kCCUPrescalar);" + NL + "    HandlePtr->CC4yRegsPtr->PSL = HandlePtr->kPassiveLevel;" + NL + "" + NL + "    /*<<<DD_PWMSP001_API_1_7>>>*/" + NL + "    /*Setting period register's value*/" + NL + "    HandlePtr->CC4yRegsPtr->PRS = (uint32_t)(HandlePtr->kPeriodVal & 0xFFFFU);" + NL + "    /*Setting compare register's value*/" + NL + "    HandlePtr->CC4yRegsPtr->CRS = (uint32_t)(HandlePtr->kCompareValue & 0xFFFFU);" + NL + "    HandlePtr->CC4yRegsPtr->SWR |= PWMSP001_ALL_CCU4_INTR_CLEAR;" + NL + "" + NL + "    /*Applying register's settings for the second slice if timer concatenation" + NL + "     * is set */" + NL + "    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "    {" + NL + "      PWMSP001_lConfigureSecondSlice(HandlePtr);" + NL + "      HandlePtr->CC4yRegs1Ptr->INTE |= HandlePtr->InterruptControl;" + NL + "" + NL + "    } /*End of if (HandlePtr->kTimerConcatenation == SET)*/" + NL + "    else" + NL + "    {" + NL + "      HandlePtr->CC4yRegsPtr->INTE |= HandlePtr->InterruptControl;" + NL + "    }" + NL + "    " + NL + "    " + NL + "    /*Request SW shadow transfer for period, compare, dither and prescalar level*/" + NL + "    HandlePtr->CC4yKernRegsPtr->GCSS |= (((uint32_t)1 << ((uint32_t)4 * \\" + NL + "\t  (uint32_t)HandlePtr->FirstSlice)) | ((uint32_t)1 <<(((uint32_t)4 * \\" + NL + "\t    (uint32_t)HandlePtr->FirstSlice) + (uint32_t)1))| ((uint32_t)1 << \\" + NL + "\t\t  (((uint32_t)4 * (uint32_t)HandlePtr->FirstSlice) + (uint32_t)2)));" + NL + "" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    HandlePtr->DynamicDataType->StateType = PWMSP001_INITIALIZED;" + NL + "  } while (0);" + NL + "" + NL + "  if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "  {" + NL + "\tDBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);" + NL + "  }" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_PWMSP001_API_2>>>*/" + NL + "/* This function de-initializes the app */" + NL + "status_t PWMSP001_Deinit(const PWMSP001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint32_t Temp1;" + NL + "  uint32_t Temp2;" + NL + "  uint32_t Temp3;" + NL + "  uint32_t Temp4;" + NL + "" + NL + "     /*<<<DD_PWMSP001_API_2_1>>>*/" + NL + "    if (HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED)" + NL + "    {" + NL + "    /*<<<DD_PWMSP001_API_2_3>>>*/" + NL + "    HandlePtr->CC4yRegsPtr->TCCLR = PWMSP001_SLICE_CLEAR;" + NL + "    HandlePtr->CC4yRegsPtr->SWR = PWMSP001_ALL_CCU4_INTR_CLEAR;" + NL + "    HandlePtr->CC4yRegsPtr->INTE = 0x00U;" + NL + "" + NL + "    /*Set IDLE mode for selected slice*/" + NL + "    HandlePtr->CC4yKernRegsPtr->GIDLS |= (((uint32_t)1<< ((uint32_t)CCU4_GIDLS_SS0I_Pos \\" + NL + "\t  +(uint32_t)HandlePtr->FirstSlice)) | ((uint32_t)1 << (uint32_t)CCU4_GIDLS_CPRB_Pos)\\" + NL + "\t    |((uint32_t)1 << (uint32_t)CCU4_GIDLS_PSIC_Pos));" + NL + "" + NL + "    /*Clear all the registers*/" + NL + "    HandlePtr->CC4yRegsPtr->INS = 0x00U;" + NL + "    HandlePtr->CC4yRegsPtr->CMC = 0x00U;" + NL + "    HandlePtr->CC4yRegsPtr->TC = 0x00U;" + NL + "    HandlePtr->CC4yRegsPtr->PSC = 0x00U;" + NL + "    HandlePtr->CC4yRegsPtr->PSL = 0x00U;" + NL + "    HandlePtr->CC4yRegsPtr->DITS = 0x00U;" + NL + "    HandlePtr->CC4yRegsPtr->CRS = 0x00U;" + NL + "    HandlePtr->CC4yRegsPtr->PRS = 0x00U;" + NL + "" + NL + "    /*<<<DD_PWMSP001_API_2_2>>>*/" + NL + "    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "    {" + NL + "      /*<<<DD_PWMSP001_API_2_3>>>*/" + NL + "      HandlePtr->CC4yRegs1Ptr->TCCLR = PWMSP001_SLICE_CLEAR;" + NL + "      HandlePtr->CC4yRegs1Ptr->SWR = PWMSP001_ALL_CCU4_INTR_CLEAR;" + NL + "      HandlePtr->CC4yRegs1Ptr->INTE = 0x00U;" + NL + "" + NL + "      /*Set IDLE mode for selected slice*/" + NL + "      Temp4 = ((uint32_t)0x01 << (uint32_t)CCU4_GIDLS_PSIC_Pos);" + NL + "      Temp3 = ((uint32_t)0x01 << CCU4_GIDLS_CPRB_Pos);" + NL + "      Temp2 = ((uint32_t)CCU4_GIDLS_SS0I_Pos + (uint32_t)HandlePtr->SecondSlice);" + NL + "      Temp1 = Temp3 | Temp4;" + NL + "      HandlePtr->CC4yKernRegsPtr->GIDLS |= (uint32_t)(((uint32_t)0x01 << Temp2 ) | Temp1);" + NL + "      /*   Temp3 | Temp4 ); */" + NL + "" + NL + "      /*Clear all the registers*/" + NL + "      HandlePtr->CC4yRegs1Ptr->INS = 0x00U;" + NL + "      HandlePtr->CC4yRegs1Ptr->CMC = 0x00U;" + NL + "      HandlePtr->CC4yRegs1Ptr->TC = 0x00U;" + NL + "      HandlePtr->CC4yRegs1Ptr->PSC = 0x00U;" + NL + "      HandlePtr->CC4yRegs1Ptr->PSL = 0x00U;" + NL + "      HandlePtr->CC4yRegs1Ptr->DITS = 0x00U;" + NL + "      HandlePtr->CC4yRegs1Ptr->CRS = 0x00U;" + NL + "      HandlePtr->CC4yRegs1Ptr->PRS = 0x00U;" + NL + "    }/*End of if (HandlePtr->kTimerConcatenation == (uint8_t)SET)*/" + NL + "" + NL + "    HandlePtr->DynamicDataType->StateType = PWMSP001_UNINITIALIZED;" + NL + "" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "" + NL + "  if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "  {" + NL + "\tDBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);" + NL + "  }" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_PWMSP001_API_3>>>*/" + NL + "/* This function starts the app. " + NL + " * This needs to be called even if external start is configured.*/" + NL + "status_t PWMSP001_Start(const PWMSP001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  do" + NL + "  {" + NL + "    /*<<<DD_PWMSP001_API_3_1>>>*/" + NL + "    if ((HandlePtr->DynamicDataType->StateType != PWMSP001_INITIALIZED) &&" + NL + "        (HandlePtr->DynamicDataType->StateType != PWMSP001_STOPPED))" + NL + "    {" + NL + "      DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);" + NL + "      break;" + NL + "    }" + NL + "" + NL + "    HandlePtr->CC4yRegsPtr->SWR = PWMSP001_ALL_CCU4_INTR_CLEAR;" + NL + "    " + NL + "    /*<<<DD_PWMSP001_API_3_2>>>*/" + NL + "\tHandlePtr->CC4yKernRegsPtr->GIDLC |=" + NL + "\t\t(((uint32_t)1 << ((uint32_t)CCU4_GIDLC_CS0I_Pos + \\" + NL + "\t\t\t(uint32_t)HandlePtr->FirstSlice)) );" + NL + "\tif (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "\t{" + NL + "\t  HandlePtr->CC4yKernRegsPtr->GIDLC |=" + NL + "\t\t  ((uint32_t)1 << ((uint32_t)CCU4_GIDLC_CS0I_Pos + \\" + NL + "\t\t\t(uint32_t)HandlePtr->SecondSlice));" + NL + "\t} /*End if (HandlePtr->kTimerConcatenation == SET)*/" + NL + "\t" + NL + "    /*Set run bit of slices if external start is not configured*/" + NL + "    if (HandlePtr->kExtStartTrig == (uint8_t)RESET)" + NL + "    {" + NL + "      HandlePtr->CC4yRegsPtr->TCSET |= (uint32_t)1;" + NL + "      if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "      {" + NL + "        HandlePtr->CC4yRegs1Ptr->TCSET |= (uint32_t)1;" + NL + "      }" + NL + "    }/*End of  if (HandlePtr->kExtStartTrig == (uint8_t)RESET)*/" + NL + "    else" + NL + "    {" + NL + "      /*<<<DD_PWMSP001_API_1_2>>>*/" + NL + "      if (HandlePtr->kExtStartTrig == (uint8_t)SET)" + NL + "      {" + NL + "        HandlePtr->CC4yRegsPtr->INS &= ~((uint32_t)CCU4_CC4_INS_EV0EM_Msk | \\" + NL + "\t\t  (uint32_t)CCU4_CC4_INS_LPF0M_Msk);" + NL + "        HandlePtr->CC4yRegsPtr->CMC &= ~(uint32_t)CCU4_CC4_CMC_STRTS_Msk;" + NL + "        HandlePtr->CC4yRegsPtr->INS |=" + NL + "            ((((uint32_t)HandlePtr->kStartEdge  << (uint32_t)CCU4_CC4_INS_EV0EM_Pos)& \\" + NL + "\t\t\t  (uint32_t)CCU4_CC4_INS_EV0EM_Msk) | (((uint32_t)PWMSP001_LPF   << \\" + NL + "                (uint32_t)CCU4_CC4_INS_LPF0M_Pos)& (uint32_t)CCU4_CC4_INS_LPF0M_Msk));" + NL + "        HandlePtr->CC4yRegsPtr->CMC |= (((uint32_t)PWMSP001_EVENT_0  <<" + NL + "            (uint32_t)CCU4_CC4_CMC_STRTS_Pos)& (uint32_t)CCU4_CC4_CMC_STRTS_Msk);" + NL + "      }/*End of if (HandlePtr->kExtStartTrig == (uint8_t)SET)*/" + NL + "      /*<<<DD_PWMSP001_nonAPI_1_2>>>*/" + NL + "      if ((HandlePtr->kExtStartTrig == (uint8_t)SET) &&\\" + NL + "          (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "      )" + NL + "      {" + NL + "        HandlePtr->CC4yRegs1Ptr->INS &= (uint32_t)~(CCU4_CC4_INS_EV0EM_Msk | CCU4_CC4_INS_LPF0M_Msk);" + NL + "        HandlePtr->CC4yRegs1Ptr->CMC &= (uint32_t)~(CCU4_CC4_CMC_STRTS_Msk);" + NL + "        HandlePtr->CC4yRegs1Ptr->INS |=" + NL + "            ((((uint32_t)HandlePtr->kStartEdge  << (uint32_t)CCU4_CC4_INS_EV0EM_Pos)& \\" + NL + "\t\t\t  (uint32_t)CCU4_CC4_INS_EV0EM_Msk) | (((uint32_t)PWMSP001_LPF  <<" + NL + "                    (uint32_t)CCU4_CC4_INS_LPF0M_Pos)& (uint32_t)CCU4_CC4_INS_LPF0M_Msk));" + NL + "        HandlePtr->CC4yRegs1Ptr->CMC |= (((uint32_t)PWMSP001_EVENT_0  << \\" + NL + "\t\t  (uint32_t)CCU4_CC4_CMC_STRTS_Pos) & (uint32_t)CCU4_CC4_CMC_STRTS_Msk);" + NL + "      }/*End of if (HandlePtr->kExtStartTrig == SET)*/" + NL + "    }" + NL + "" + NL + "    HandlePtr->DynamicDataType->StateType = PWMSP001_RUNNING;" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  } while (0);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_PWMSP001_API_4>>>*/" + NL + "/* This function stops the app */" + NL + "status_t PWMSP001_Stop(const PWMSP001_HandleType* HandlePtr)" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint32_t Temp1;" + NL + "  uint32_t Temp2;" + NL + "  " + NL + "  do" + NL + "  {" + NL + "    /*<<<DD_PWMSP001_API_4_1>>>*/" + NL + "    if (HandlePtr->DynamicDataType->StateType != PWMSP001_RUNNING)" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Temp1 = ((uint32_t)CCU4_GIDLS_SS0I_Pos + (uint32_t)HandlePtr->FirstSlice);" + NL + "      Temp2 = ((uint32_t)0x01 << CCU4_GIDLS_PSIC_Pos);" + NL + "      HandlePtr->CC4yRegsPtr->TCCLR = PWMSP001_SLICE_CLEAR;" + NL + "      HandlePtr->CC4yKernRegsPtr->GIDLS |= (((uint32_t)0x01 << Temp1 ) | Temp2 );" + NL + "" + NL + "      if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "      {" + NL + "        HandlePtr->CC4yRegs1Ptr->TCCLR = PWMSP001_SLICE_CLEAR;" + NL + "        Temp1 = ((uint32_t)CCU4_GIDLS_SS0I_Pos + (uint32_t)HandlePtr->SecondSlice);" + NL + "        Temp2 = ((uint32_t)0x01 << CCU4_GIDLS_PSIC_Pos);" + NL + "        HandlePtr->CC4yKernRegsPtr->GIDLS |= (((uint32_t)0x01 << Temp1) | Temp2 );" + NL + "      }/*End of  if (HandlePtr->kTimerConcatenation == (uint8_t)SET)*/" + NL + "" + NL + "      HandlePtr->DynamicDataType->StateType = PWMSP001_STOPPED;" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "  } while (0);" + NL + "" + NL + "  if (Status != (uint32_t)DAVEApp_SUCCESS)" + NL + "  {" + NL + "\tDBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);" + NL + "  }" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_PWMSP001_API_5>>>*/" + NL + "/* This function changes the duty cycle of the PWM by changing the compare register value. */" + NL + "status_t PWMSP001_SetCompare" + NL + "(" + NL + "    const PWMSP001_HandleType* HandlePtr," + NL + "    uint32_t Compare" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint32_t period;" + NL + "" + NL + "  if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "\t  period=(uint32_t)(((uint32_t)HandlePtr->CC4yRegs1Ptr->PRS<<16U)|(uint32_t)HandlePtr->CC4yRegsPtr->PRS);" + NL + "  else" + NL + "\t  period=(uint32_t)HandlePtr->CC4yRegsPtr->PRS;" + NL + "" + NL + "  /*<<<DD_PWMSP001_API_5_1>>>*/" + NL + "  if ( HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED)" + NL + "  {" + NL + "    if ((Compare > (uint32_t)HandlePtr->kMaxPeriodVal) &&" + NL + "        (HandlePtr->kTimerConcatenation == (uint8_t)RESET))" + NL + "    {" + NL + "      Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      /*if compare value is greater or equal to the period value, output should be with 0% dutycycle." + NL + "\t  Since setting exact period value will create the spikes,we are adding 1 and setting to the register*/" + NL + "\t  if (Compare >= (uint32_t)period)" + NL + "\t  {" + NL + "\t\t  Compare = (uint32_t)period + 1U;" + NL + "\t  }" + NL + "      /* Call function as per the configured mode */" + NL + "      HandlePtr->SetCompareFuncPtr((const void*)HandlePtr, Compare);" + NL + "      Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "    }" + NL + "  }" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function is used to change the compare register value " + NL + " * in edge-aligned mode." + NL + " */" + NL + "void PWMSP001_lSetCompareEdgeAlign" + NL + "(" + NL + "    void* Handle," + NL + "    uint32_t Compare" + NL + ")" + NL + "{" + NL + "  uint32_t Temp1;" + NL + "  uint32_t Temp2;" + NL + "  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;" + NL + "  HandlePtr->CC4yRegsPtr->CRS = (Compare & 0xFFFFU);" + NL + "  " + NL + "  /* Request shadow transfer */" + NL + "  Temp2 = (4U*(uint32_t)HandlePtr->FirstSlice);" + NL + "  Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + Temp2;" + NL + "  HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1);" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function is used to change the compare register value " + NL + " * in edge-aligned timer concatenation mode." + NL + " */" + NL + "void PWMSP001_lSetCompareEdgeAlignTimerConcat" + NL + "(" + NL + "    void* Handle," + NL + "    uint32_t Compare" + NL + ")" + NL + "{" + NL + "  uint32_t FirstSliceCompareVal = 0x00U;" + NL + "  uint32_t SecondSliceCompareVal = 0x00U;" + NL + "  uint32_t Temp1;" + NL + "  uint32_t Temp2;" + NL + "  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;" + NL + "  /**" + NL;
  protected final String TEXT_66 = "   * In case of timer concatenation, compare register value is divided by" + NL + "   * period register value of the first slice. Remainder is written in" + NL + "   * compare register of first slice and quotient is written in compare" + NL + "   * register of second slice." + NL + "   * This is done to achieve compare register value of first slice" + NL + "   * to be less than period register value." + NL + "   */" + NL + "  FirstSliceCompareVal = (uint32_t)Compare % \\" + NL + "      (uint16_t)HandlePtr->CC4yRegsPtr->PRS;" + NL + "  SecondSliceCompareVal = (uint32_t)Compare /" + NL + "      (uint16_t)HandlePtr->CC4yRegsPtr->PRS;" + NL + "  " + NL + "  HandlePtr->CC4yRegsPtr->CRS = (FirstSliceCompareVal & 0xFFFFU);" + NL + "  HandlePtr->CC4yRegs1Ptr->CRS = (SecondSliceCompareVal & 0xFFFFU);" + NL + "  /* Request shadow transfer */" + NL + "  Temp1 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->SecondSlice));" + NL + "  Temp2 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice));" + NL + "  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)0x01 << Temp2 ) | ((uint32_t)0x01 << Temp1));" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function is used to change the compare register value " + NL + " * in center-aligned mode." + NL + " */" + NL + "void PWMSP001_lSetCompareCenterAlign" + NL + "(" + NL + "    void* Handle," + NL + "    uint32_t Compare" + NL + ")" + NL + "{" + NL + "  uint32_t Temp1;" + NL + "  /*<<<DD_PWMSP001_API_5_3>>>*/" + NL + "  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;" + NL + "  HandlePtr->CC4yRegsPtr->CRS = (Compare & 0xFFFFU);" + NL + "  " + NL + "  /* Request shadow transfer */" + NL + "  Temp1 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U*(uint32_t)HandlePtr->FirstSlice));" + NL + "  HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1);" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function is used to change the duty cycle of the PWM waveform" + NL + " */" + NL + "/*<<<DD_PWMSP001_API_15>>>*/" + NL + "status_t PWMSP001_SetDutyCycle" + NL + "(" + NL + "    const PWMSP001_HandleType* HandlePtr," + NL + "    float Duty" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  if ( HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED)" + NL + "  {" + NL + "  if((Duty > (float)100) || ((float)Duty < (float)0))" + NL + "  {" + NL + "    Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    /* Call the function as per configured mode */" + NL + "    HandlePtr->SetDutyFuncPtr((const void*)HandlePtr, Duty);" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  }" + NL + "  return (Status);" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function is used to change the duty cycle of the PWM waveform" + NL + " * in edge-aligned mode" + NL + " */" + NL + "void PWMSP001_lSetDutyEdgeAlign" + NL + "(" + NL + "    void* Handle," + NL + "    float Duty" + NL + ")" + NL + "{" + NL + "  uint32_t FirstSliceCompareVal = (uint32_t)0;" + NL + "  uint32_t Temp1;" + NL + "  float fDuty, fPRS ;" + NL + "  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;" + NL + "  fDuty = Duty;" + NL + "  " + NL + "  /*<<<DD_PWMSP001_API_15_3>>>*/" + NL + "  " + NL + "  fDuty = (float)((float)100.00 - (float)fDuty)/(float)100.00;" + NL + "  fPRS = (float)((uint32_t)HandlePtr->CC4yRegsPtr->PRS + 1U);" + NL + "  FirstSliceCompareVal = (uint32_t)( fPRS * fDuty);" + NL + "  HandlePtr->CC4yRegsPtr->CRS = FirstSliceCompareVal  & 0xFFFFU;" + NL + "  " + NL + "  /*Shadow transfer */" + NL + "  Temp1 =  ((uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4 *(uint32_t)HandlePtr->FirstSlice));" + NL + "  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)((uint32_t)0x01 << (uint32_t)Temp1);" + NL + "  /*Update dynamic handle */" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function is used to change the duty cycle of the PWM waveform" + NL + " * in edge-aligned timer concatenation mode" + NL + " */" + NL + "void PWMSP001_lSetDutyEdgeAlignTimerConcat" + NL + "(" + NL + "    void* Handle," + NL + "    float Duty" + NL + ")" + NL + "{" + NL + "  uint32_t Compare = (uint32_t)0;" + NL + "  uint32_t FirstSliceCompareVal = (uint32_t)0;" + NL + "  uint32_t SecondSliceCompareVal = (uint32_t)0;" + NL + "  uint32_t Temp2;" + NL + "  uint32_t Temp3;" + NL + "  float fDuty, fPRS ;" + NL + "  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;" + NL + "  " + NL + "  fDuty = Duty;" + NL + "  /*<<<DD_PWMSP001_API_15_4>>>*/" + NL + "  /* Find the compare register value from the duty cycle and period register value */" + NL + "  Compare =(uint32_t)HandlePtr->CC4yRegs1Ptr->PRS + 1U;" + NL + "  Compare *= ((uint32_t)((uint32_t)HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU) +1U); " + NL + "  Compare +=  (uint32_t)1;" + NL + "  " + NL + "  fDuty = ((float)100.00 - (float)fDuty)/(float)100.00;" + NL + "  fPRS = (float)(Compare);" + NL + "  Compare = (uint32_t)( fPRS * fDuty);" + NL + "" + NL + "  FirstSliceCompareVal =(uint32_t)" + NL + "                    ((uint32_t)Compare % ((uint32_t)((uint32_t)HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU)));" + NL + "  HandlePtr->CC4yRegsPtr->CRS = (uint32_t)FirstSliceCompareVal  & 0xFFFFU;" + NL + "  SecondSliceCompareVal = (uint32_t)" + NL + "                    ((uint32_t)Compare / ((uint32_t)((uint32_t)HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU)));" + NL + "  HandlePtr->CC4yRegs1Ptr->CRS = (uint32_t)SecondSliceCompareVal  & 0xFFFFU;" + NL + "" + NL + "  /** shadow transfer */" + NL + "  Temp2 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice));" + NL + "  Temp3 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->SecondSlice));" + NL + "  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)1 << (uint32_t)Temp2 ) | ((uint32_t)1 << (uint32_t)Temp3));" + NL + "}" + NL + "" + NL + "/*" + NL + " * This function is used to change the duty cycle of the PWM waveform" + NL + " * in center-aligned mode" + NL + " */" + NL + "void PWMSP001_lSetDutyCenterAlign" + NL + "(" + NL + "    void* Handle," + NL + "    float Duty" + NL + ")" + NL + "{" + NL + "  /*<<<DD_PWMSP001_API_15_5>>>*/" + NL + "  uint32_t FirstSliceCompareVal = (uint32_t)0x00;" + NL + "  uint32_t Temp1;" + NL + "  float fDuty, fPRS ;" + NL + "  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;" + NL + "  fDuty = Duty;" + NL + "" + NL + "  fDuty = (float)((float)100.00 - (float)fDuty)/(float)100.00;" + NL + "  fPRS = (float)HandlePtr->CC4yRegsPtr->PRS;" + NL + "  FirstSliceCompareVal = (uint32_t)( fPRS * fDuty);" + NL + "  HandlePtr->CC4yRegsPtr->CRS = (uint32_t)FirstSliceCompareVal  & 0xFFFFU;" + NL + "" + NL + "  /*shadow transfer */" + NL + "  Temp1 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice));" + NL + "  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)((uint32_t)0x01 << (uint32_t)Temp1);" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function changes the PWM frequency and duty cycle. " + NL + " * Input parameters are in terms of period and compare register" + NL + " */" + NL + "status_t PWMSP001_SetPeriodAndCompare" + NL + "(" + NL + "    const PWMSP001_HandleType* HandlePtr," + NL + "    uint32_t Period," + NL + "    uint32_t Compare" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint32_t PeriodVal = 0UL;" + NL + "  /*<<<DD_PWMSP001_API_6_1>>>*/" + NL + "  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED))" + NL + "  {" + NL + "   if((Period == (uint32_t)0) || (((uint32_t)Compare > (uint32_t)HandlePtr->kMaxPeriodVal) &&" + NL + "       (HandlePtr->kTimerConcatenation == (uint8_t)RESET)))" + NL + "    {" + NL + "      Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      if ((Period > (uint32_t)HandlePtr->kMaxPeriodVal)&&\\" + NL + "          ((HandlePtr->kTimerConcatenation != (uint8_t)SET))" + NL + "          )" + NL + "      {" + NL + "        Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        PeriodVal = Period;" + NL + "        if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "        {" + NL + "          HandlePtr->CC4yRegs1Ptr->PRS = ((PeriodVal & 0xFFFF0000U) >> 16U);" + NL + "        }" + NL + "        /*<<<DD_PWMSP001_API_6_3>>>*/" + NL + "        HandlePtr->CC4yRegsPtr->PRS = (PeriodVal & 0xFFFFU);" + NL + "        /* Call function as per the configured mode */" + NL + "        HandlePtr->SetCompareFuncPtr((const void*)HandlePtr, Compare);" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      }" + NL + "    }" + NL + "  }" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_PWMSP001_API_6>>>*/" + NL + "/*" + NL + " * This function changes the PWM frequency. Input parameter is the period register value" + NL + " */" + NL + "status_t PWMSP001_SetPeriod" + NL + "(" + NL + "    const PWMSP001_HandleType* HandlePtr," + NL + "    uint32_t Period" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint32_t PeriodVal = 0X00U;" + NL + "  uint32_t Temp1;" + NL + "  " + NL + "  /*<<<DD_PWMSP001_API_6_1>>>*/" + NL + "  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED))" + NL + "  {" + NL + "    if(Period == (uint32_t)0)" + NL + "    {" + NL + "      Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      if((Period > (uint32_t)HandlePtr->kMaxPeriodVal) &&\\" + NL + "         (HandlePtr->kTimerConcatenation != (uint8_t)SET))" + NL + "      {" + NL + "        Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        PeriodVal = Period;" + NL + "        if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "        {" + NL + "          HandlePtr->CC4yRegs1Ptr->PRS = ((PeriodVal & 0xFFFF0000U) >> 16U);" + NL + "        }" + NL + "        HandlePtr->CC4yRegsPtr->PRS = (PeriodVal & 0xFFFFU);" + NL + "        /*Request shadow transfer for the First slice*/" + NL + "        Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4 * (uint32_t)HandlePtr->FirstSlice);" + NL + "        HandlePtr->CC4yKernRegsPtr->GCSS |=\t((uint32_t)0x01 << Temp1);" + NL + "        if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "        {" + NL + "          /*Request shadow transfer for the First slice*/" + NL + "          Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->SecondSlice);" + NL + "          HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1);" + NL + "        }/*End Of if (HandlePtr->kTimerConcatenation == (uint8_t)SET)*/" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      }" + NL + "    }" + NL + "  }" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function changes the PWM frequency and duty cycle. " + NL + " * Input parameters are in terms of the frequency in hertz and duty in %." + NL + " */" + NL + "status_t PWMSP001_SetPwmFreqAndDutyCycle" + NL + "(" + NL + "    const PWMSP001_HandleType* HandlePtr," + NL + "    float PwmFreq," + NL + "    float Duty" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint32_t PwmTime = 0UL;" + NL + "  float fPwmFreq ;" + NL + "  /*<<<DD_PWMSP001_API_16_1>>>*/" + NL + "  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED))" + NL + "  {" + NL + "  if((PwmFreq == (float)0) || (Duty > (float)100) || (Duty < (float)0))" + NL + "  {" + NL + "    Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "      fPwmFreq=(float)HandlePtr->kResolution;" + NL + "\t  fPwmFreq=(float)fPwmFreq*PwmFreq;" + NL + "\t  PwmTime = (uint32_t)((float)1000000000.00 / fPwmFreq);" + NL + "    /*<<<DD_PWMSP001_API_16_2>>>*/" + NL + "    if(HandlePtr->kTimerConcatenation == (uint8_t)RESET)" + NL + "    {" + NL + "      if(PwmTime > PWMSP001_MAX_VALUE)" + NL + "      {" + NL + "        Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        if(HandlePtr->CountingModeType == PWMSP001_EDGE_ALIGNED)" + NL + "        {" + NL + "          HandlePtr->CC4yRegsPtr->PRS = PwmTime -(uint32_t)1;" + NL + "        }" + NL + "        else" + NL + "        {" + NL + "          HandlePtr->CC4yRegsPtr->PRS = (PwmTime - (uint32_t)1) >> (uint32_t)1;" + NL + "        }" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      }" + NL + "    }" + NL + "    else if((HandlePtr->kTimerConcatenation == (uint8_t)SET) &&\\" + NL + "    \t\t                                   (PwmTime <= PWMSP001_MAX_VALUE))" + NL + "    {" + NL + "    \tStatus = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;" + NL + "    }" + NL + "    /*<<<DD_PWMSP001_API_16_3>>>*/" + NL + "    else" + NL + "    {" + NL + "      Status = PWMSP001_lSetPwmFreqTimerConcat(HandlePtr, PwmTime);" + NL + "    }" + NL + "    if(Status == (uint32_t)DAVEApp_SUCCESS)" + NL + "    {" + NL + "     /* Call the function as per configured mode */" + NL + "     HandlePtr->SetDutyFuncPtr((const void*)HandlePtr, Duty);" + NL + "    }" + NL + "   }" + NL + "  }" + NL + "  return (Status);" + NL + "}" + NL + "" + NL + "" + NL + "/*<<<DD_PWMSP001_API_16>>>*/" + NL + "/*" + NL + " * This function changes the PWM frequency. Input parameter is the frequency value" + NL + " */" + NL + "status_t PWMSP001_SetPwmFreq" + NL + "(" + NL + "    const PWMSP001_HandleType* HandlePtr," + NL + "    float PwmFreq" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint32_t PwmTime = 0x00U;" + NL + "  uint32_t Temp1;" + NL + "  uint32_t Temp2;" + NL + "  uint32_t Temp3;" + NL + "  float fPwmFreq ;" + NL + "  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED))" + NL + "  {" + NL + "  if(PwmFreq == (float)0)" + NL + "  {" + NL + "    Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "\t  fPwmFreq=(float)HandlePtr->kResolution;" + NL + "\t  fPwmFreq=(float)fPwmFreq*PwmFreq;" + NL + "\t  PwmTime = (uint32_t)((float)1000000000.00 / fPwmFreq);" + NL + "    /*<<<DD_PWMSP001_API_16_2>>>*/" + NL + "    if(HandlePtr->kTimerConcatenation == (uint8_t)RESET)" + NL + "    {" + NL + "      if(PwmTime > PWMSP001_MAX_VALUE)" + NL + "      {" + NL + "        Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        if(HandlePtr->CountingModeType == PWMSP001_EDGE_ALIGNED)" + NL + "        {" + NL + "          HandlePtr->CC4yRegsPtr->PRS = PwmTime -(uint32_t)1;" + NL + "        }" + NL + "        else" + NL + "        {" + NL + "          HandlePtr->CC4yRegsPtr->PRS = (PwmTime - (uint32_t)1) >> (uint32_t)1;" + NL + "        }" + NL + "        /** Update dynamic handle*/" + NL + "        Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4*(uint32_t)HandlePtr->FirstSlice); " + NL + "        HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1 );" + NL + "        Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "      }" + NL + "    }" + NL + "    /*<<<DD_PWMSP001_API_16_3>>>*/" + NL + "    else" + NL + "    {" + NL + "      Status = PWMSP001_lSetPwmFreqTimerConcat(HandlePtr, PwmTime);" + NL + "      if(Status == (uint32_t)DAVEApp_SUCCESS)" + NL + "      {" + NL + "        Temp2 = (uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice);" + NL + "        Temp3 = (uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->SecondSlice);" + NL + "        HandlePtr->CC4yKernRegsPtr->GCSS |= (((uint32_t)0x01 << Temp2) | \\" + NL + "            ((uint32_t)0x01 << Temp3));" + NL + "      }" + NL + "    }" + NL + "  }" + NL + " }" + NL + "  return (Status);" + NL + "}" + NL + NL;
  protected final String TEXT_67 = "/*" + NL + " * This function is used to set the PWM frequency in case of timer concatenation mode." + NL + " */" + NL + "status_t PWMSP001_lSetPwmFreqTimerConcat" + NL + "(" + NL + "    const PWMSP001_HandleType* HandlePtr," + NL + "    uint32_t PwmTime" + NL + ")" + NL + "{" + NL + "  uint32_t PeriodVal = PwmTime;" + NL + "  uint32_t MsbPeriodVal, LsbPeriodVal;" + NL + "  uint8_t Count = 0x00U;" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  if(PwmTime >= PWMSP001_TC_MAX_VALUE)" + NL + "  {" + NL + "    Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;" + NL + "  }" + NL + "" + NL + "  else" + NL + "  {" + NL + "" + NL + "    if(PwmTime > PWMSP001_MAX_VALUE)" + NL + "    {" + NL + "      do" + NL + "      {" + NL + "        PeriodVal = PeriodVal >> 1;" + NL + "        Count++;" + NL + "      }while(PeriodVal >= PWMSP001_MAX_VALUE);" + NL + "" + NL + "      MsbPeriodVal = ((uint32_t)1 << Count) -(uint32_t)1;" + NL + "      LsbPeriodVal = PeriodVal;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      LsbPeriodVal = PwmTime;" + NL + "      MsbPeriodVal = (uint32_t)0x00;" + NL + "    }" + NL + "" + NL + "    /*<<<DD_PWMSP001_API_16_4>>>*/" + NL + "    if(HandlePtr->CountingModeType == PWMSP001_CENTER_ALIGNED)" + NL + "    {" + NL + "      MsbPeriodVal = MsbPeriodVal >> (uint32_t)1;" + NL + "      LsbPeriodVal = LsbPeriodVal >> (uint32_t)1;" + NL + "    }" + NL + "" + NL + "    HandlePtr->CC4yRegsPtr->PRS = LsbPeriodVal & 0xFFFFU;" + NL + "    HandlePtr->CC4yRegs1Ptr->PRS =MsbPeriodVal & 0xFFFFU;" + NL + "" + NL + "    /*<<<DD_PWMSP001_API_16_5>>>*/" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  return (Status);" + NL + "}" + NL + "" + NL + "" + NL + "" + NL + "/*<<<DD_PWMSP001_API_7>>>*/" + NL + "/*" + NL + " * This function sets the timer value." + NL + " */" + NL + "status_t PWMSP001_SetTimerVal" + NL + "(" + NL + "    const PWMSP001_HandleType* HandlePtr," + NL + "    uint32_t TimerVal" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "  /*<<<DD_PWMSP001_API_7_1>>>*/" + NL + "  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_INITIALIZED) &&" + NL + "      (HandlePtr->DynamicDataType->StateType != PWMSP001_STOPPED))" + NL + "  {" + NL + "\tDBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);" + NL + "  }" + NL + "  /*<<<DD_PWMSP001_API_7_1>>>*/" + NL + "  else" + NL + "  {" + NL + "    HandlePtr->CC4yRegsPtr->TIMER = (uint32_t)TimerVal&0xFFFFU;" + NL + "    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "    {" + NL + "      HandlePtr->CC4yRegs1Ptr->TIMER = (uint32_t)((uint32_t)TimerVal>>16U)&0xFFFFU;" + NL + "    }" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_PWMSP001_API_8>>>*/" + NL + "/*" + NL + " * This function returns the timer status - Running or Idle" + NL + " */" + NL + "status_t PWMSP001_GetTimerStatus" + NL + "(" + NL + "    const PWMSP001_HandleType* HandlePtr," + NL + "    uint32_t* TimerStatus" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint32_t SecondTimerStatus = (uint32_t)0;" + NL + "  /*<<<DD_PWMSP001_API_8_1>>>*/" + NL + "  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)" + NL + "  {" + NL + "\tDBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);" + NL + "  }" + NL + "  /*<<<DD_PWMSP001_API_8_2>>>*/" + NL + "  else" + NL + "  {" + NL + "    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "    {" + NL + "      SecondTimerStatus = (uint32_t)(RD_REG(HandlePtr->CC4yRegs1Ptr->TCST," + NL + "          CCU4_CC4_TCST_TRB_Msk, CCU4_CC4_TCST_TRB_Pos));" + NL + "      *TimerStatus = (uint32_t)((RD_REG(HandlePtr->CC4yRegsPtr->TCST," + NL + "          CCU4_CC4_TCST_TRB_Msk, CCU4_CC4_TCST_TRB_Pos)) &" + NL + "          SecondTimerStatus" + NL + "      );" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      *TimerStatus = (uint32_t) RD_REG(HandlePtr->CC4yRegsPtr->TCST," + NL + "          CCU4_CC4_TCST_TRB_Msk, CCU4_CC4_TCST_TRB_Pos);" + NL + "    }" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  return Status; " + NL + "}" + NL + "" + NL + "/*<<<DD_PWMSP001_API_9>>>*/" + NL + "/*" + NL + " * This function returns the timer registers." + NL + " */" + NL + "status_t PWMSP001_GetTimerRegsVal" + NL + "(" + NL + "    const PWMSP001_HandleType* HandlePtr," + NL + "    PWMSP001_TimerRegsType* TimerRegs" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint32_t ScndSlTMRVal = 0UL;" + NL + "" + NL + "  /*<<<DD_PWMSP001_API_9_1>>>*/" + NL + "  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)" + NL + "  {" + NL + "\tDBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);" + NL + "  }" + NL + "  /*<<<DD_PWMSP001_API_9_2>>>*/" + NL + "  else" + NL + "  {" + NL + "    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "    {" + NL + "      ScndSlTMRVal = (RD_REG(HandlePtr->CC4yRegs1Ptr->TIMER," + NL + "          CCU4_CC4_TIMER_TVAL_Msk, CCU4_CC4_TIMER_TVAL_Pos) << 16UL);" + NL + "" + NL + "      TimerRegs->TimerReg = (uint32_t)(ScndSlTMRVal |" + NL + "          (RD_REG(HandlePtr->CC4yRegsPtr->TIMER," + NL + "              CCU4_CC4_TIMER_TVAL_Msk, CCU4_CC4_TIMER_TVAL_Pos)));" + NL + "" + NL + "      TimerRegs->CompReg = HandlePtr->CC4yRegs1Ptr->CRS; " + NL + "      TimerRegs->CompReg*= HandlePtr->CC4yRegsPtr->PRS;" + NL + "      TimerRegs->CompReg += HandlePtr->CC4yRegsPtr->CRS;" + NL + "      TimerRegs->PeriodReg = HandlePtr->CC4yRegs1Ptr->PRS+ 1U;" + NL + "      TimerRegs->PeriodReg *= (uint32_t)((HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU) +1U);" + NL + "      TimerRegs->PeriodReg += 1U ;" + NL + "    }" + NL + "" + NL + "    else" + NL + "    {" + NL + "      TimerRegs->TimerReg = (uint32_t)RD_REG(HandlePtr->CC4yRegsPtr->TIMER," + NL + "          CCU4_CC4_TIMER_TVAL_Msk, CCU4_CC4_TIMER_TVAL_Pos);" + NL + "" + NL + "      TimerRegs->CompReg = HandlePtr->CC4yRegsPtr->CRS;" + NL + "      TimerRegs->PeriodReg = HandlePtr->CC4yRegsPtr->PRS;" + NL + "" + NL + "    }" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_PWMSP001_API_15>>>*/" + NL + "/*" + NL + " * This function returns the period register value" + NL + " */" + NL + "status_t PWMSP001_GetPeriodReg" + NL + "(" + NL + "    const PWMSP001_HandleType* HandlePtr," + NL + "    uint32_t* PeriodReg" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  /*<<<DD_PWMSP001_API_15_1>>>*/" + NL + "  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)" + NL + "  {" + NL + "\tDBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "    {" + NL + "      *PeriodReg = (HandlePtr->CC4yRegs1Ptr->PRS + 1U);" + NL + "      *PeriodReg  *=(uint32_t)((HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU) +1U);" + NL + "      *PeriodReg  += 1U;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      *PeriodReg = HandlePtr->CC4yRegsPtr->PRS;" + NL + "    }" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_PWMSP001_API_10>>>*/" + NL + "/*" + NL + " * This functions enables the shadow transfer of compare and period register values" + NL + " */" + NL + "status_t PWMSP001_SWRequestShadowTransfer" + NL + "(" + NL + "    const PWMSP001_HandleType* HandlePtr" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "  uint32_t Temp1;" + NL + "  uint32_t Temp2;" + NL + "  uint32_t Temp3;" + NL + "" + NL + "  /*<<<DD_PWMSP001_API_10_1>>>*/" + NL + "  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)" + NL + "  {" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);" + NL + "  }" + NL + "  /*<<<DD_PWMSP001_API_10_2>>>*/" + NL + "  else" + NL + "  {" + NL + "    /*Request shadow transfer for the First Slice*/" + NL + "    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "    {" + NL + "      /*Request shadow transfer for the Second Slice*/" + NL + "      Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4 * (uint32_t)HandlePtr->FirstSlice);" + NL + "      Temp2 = (uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4*(uint32_t)HandlePtr->SecondSlice);" + NL + "      HandlePtr->CC4yKernRegsPtr->GCSS |=  ((uint32_t)0x01 << Temp1) | ((uint32_t)0x01 << Temp2);" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Temp3 =  (uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice);" + NL + "      HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp3);" + NL + "    }" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*<<<DD_PWMSP001_API_13>>>*/" + NL + "/*" + NL + " * This function resets the trap flag if trap condition is inactive" + NL + " */" + NL + "void PWMSP001_ResetTrapFlag(const PWMSP001_HandleType* HandlePtr)" + NL + "{" + NL + "   if (HandlePtr->kTrapExitControl == (uint8_t)SET)" + NL + "    {" + NL + "      SET_BIT(HandlePtr->CC4yRegsPtr->SWR, PWMSP001_EVENT2_INTERRUPT);" + NL + "      if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "      {" + NL + "        SET_BIT(HandlePtr->CC4yRegs1Ptr->SWR, PWMSP001_EVENT2_INTERRUPT);" + NL + "      }" + NL + "    }" + NL + "    SET_BIT(HandlePtr->CC4yRegsPtr->SWR, PWMSP001_TRAP_FLAG_CLEAR);" + NL + "    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "    {" + NL + "      SET_BIT(HandlePtr->CC4yRegs1Ptr->SWR, PWMSP001_TRAP_FLAG_CLEAR);" + NL + "    }" + NL + "}" + NL + "" + NL + "/*<<<DD_PWMSP001_nonAPI_1>>>*/" + NL + "/*" + NL + " * This function configures second slice." + NL + " */" + NL + "" + NL + "void PWMSP001_lConfigureSecondSlice(const PWMSP001_HandleType* HandlePtr)" + NL + "{" + NL + "  HandlePtr->CC4yRegs1Ptr->TCCLR = PWMSP001_SLICE_CLEAR;" + NL + "" + NL + "  /*Set period and compare values for second slice*/" + NL + "  HandlePtr->CC4yRegs1Ptr->PRS = (uint32_t)((HandlePtr->kPeriodVal & 0xFFFF0000U)" + NL + "      >> 16U);" + NL + "  HandlePtr->CC4yRegs1Ptr->CRS =(uint32_t)((HandlePtr->kCompareValue & 0xFFFF0000U)" + NL + "      >> 16U);" + NL + "" + NL + "  HandlePtr->CC4yRegs1Ptr->CMC |= ((uint32_t)0x01 << (uint32_t)CCU4_CC4_CMC_TCE_Pos);" + NL + "" + NL + "  /*<<<DD_PWMSP001_nonAPI_1_3>>>*/" + NL + "  if (HandlePtr->kExtStopTrig == (uint8_t)SET)" + NL + "  {" + NL + "    HandlePtr->CC4yRegs1Ptr->INS &=(uint32_t) ~(CCU4_CC4_INS_EV1EM_Msk | (uint32_t)CCU4_CC4_INS_LPF1M_Msk);" + NL + "    HandlePtr->CC4yRegs1Ptr->CMC &=(uint32_t) ~(CCU4_CC4_CMC_ENDS_Msk);" + NL + "    HandlePtr->CC4yRegs1Ptr->INS |=(uint32_t)((((uint32_t)HandlePtr->kStopEdge  <<   \\" + NL + "      (uint32_t)CCU4_CC4_INS_EV1EM_Pos)& (uint32_t)CCU4_CC4_INS_EV1EM_Msk) | \\" + NL + "\t    (((uint32_t)PWMSP001_LPF << (uint32_t)CCU4_CC4_INS_LPF1M_Pos)& \\" + NL + "\t\t  (uint32_t)CCU4_CC4_INS_LPF1M_Msk));" + NL + "    HandlePtr->CC4yRegs1Ptr->CMC |= (((uint32_t)PWMSP001_EVENT_1  <<  \\" + NL + "      (uint32_t)CCU4_CC4_CMC_ENDS_Pos)& (uint32_t)CCU4_CC4_CMC_ENDS_Msk);" + NL + "  }/*End of if (HandlePtr->kExtStopTrig == SET)*/" + NL + "" + NL + "  /*<<<DD_PWMSP001_nonAPI_1_4>>>*/" + NL + "  if (HandlePtr->kTrapEnable == (uint8_t)SET)" + NL + "  {" + NL + "    HandlePtr->CC4yRegs1Ptr -> INS &=(uint32_t) ~(CCU4_CC4_INS_EV2EM_Msk | CCU4_CC4_INS_EV2LM_Msk " + NL + "        | CCU4_CC4_INS_LPF2M_Msk);" + NL + "    HandlePtr->CC4yRegs1Ptr->CMC &= (uint32_t)~(CCU4_CC4_CMC_TS_Msk);" + NL + "    HandlePtr->CC4yRegs1Ptr -> INS |= (uint32_t) \\" + NL + "        ((((uint32_t)0x00 << CCU4_CC4_INS_EV2EM_Pos)& (uint32_t)CCU4_CC4_INS_EV2EM_Msk) | \\" + NL + "            ((((uint32_t)HandlePtr->kTrapLevel  <<\t\\" + NL + "                CCU4_CC4_INS_EV2LM_Pos)& (uint32_t)CCU4_CC4_INS_EV2LM_Msk) | (((uint32_t)0x00  << \\" + NL + "                    CCU4_CC4_INS_LPF2M_Pos)& (uint32_t)CCU4_CC4_INS_LPF2M_Msk)));" + NL + "    HandlePtr->CC4yRegs1Ptr->CMC |= ((uint32_t)0x01 << (uint32_t)CCU4_CC4_CMC_TS_Pos);" + NL + "  }/*End of if (HandlePtr->kTrapEnable == SET)*/" + NL + "" + NL + "  HandlePtr->CC4yRegs1Ptr->TC &=(uint32_t) ~(CCU4_CC4_TC_TCM_Msk | CCU4_CC4_TC_TSSM_Msk" + NL + "      | CCU4_CC4_TC_CMOD_Msk | CCU4_CC4_TC_STRM_Msk | CCU4_CC4_TC_ENDM_Msk" + NL + "      | CCU4_CC4_TC_DITHE_Msk);" + NL + "  HandlePtr->CC4yRegs1Ptr->TC =\t(((uint32_t)HandlePtr->CountingModeType  << \\" + NL + "    (uint32_t)CCU4_CC4_TC_TCM_Pos)& (uint32_t)CCU4_CC4_TC_TCM_Msk)|\t\\" + NL + "      (((uint32_t)HandlePtr->kTimerMode  << (uint32_t)CCU4_CC4_TC_TSSM_Pos)& \\" + NL + "\t    (uint32_t)CCU4_CC4_TC_TSSM_Msk)|(((uint32_t)PWMSP001_COMPARE_MODE  << \\" + NL + "\t\t  (uint32_t)CCU4_CC4_TC_CMOD_Pos)& (uint32_t)CCU4_CC4_TC_CMOD_Msk)| \\" + NL + "            (((uint32_t)HandlePtr->ExtStartConfigType << (uint32_t)CCU4_CC4_TC_STRM_Pos)\\" + NL + "\t\t\t  &(uint32_t)CCU4_CC4_TC_STRM_Msk)| (((uint32_t)HandlePtr->ExtStopConfigType <<\t\\" + NL + "                (uint32_t)CCU4_CC4_TC_ENDM_Pos)& (uint32_t)CCU4_CC4_TC_ENDM_Msk);" + NL + "" + NL + "  /*<<<DD_PWMSP001_API_non1_5>>>*/" + NL + "  HandlePtr->CC4yRegs1Ptr->TC |= ((uint32_t)HandlePtr->kDitherSetting << (uint32_t)CCU4_CC4_TC_DITHE_Pos)\\" + NL + "    &(uint32_t)CCU4_CC4_TC_DITHE_Msk;" + NL + "  WR_REG(HandlePtr->CC4yRegs1Ptr->DITS, (uint32_t)CCU4_CC4_DITS_DCVS_Msk, \\" + NL + "    (uint32_t)CCU4_CC4_DITS_DCVS_Pos, HandlePtr->kDitherCompare);" + NL + "" + NL + "  /*<<<DD_PWMSP001_API_non1_6>>>*/" + NL + "  WR_REG(HandlePtr->CC4yRegs1Ptr->TC, (uint32_t)CCU4_CC4_TC_TRPSE_Msk," + NL + "      (uint32_t)CCU4_CC4_TC_TRPSE_Pos, HandlePtr->kTrapSync);" + NL + "" + NL + "  WR_REG(HandlePtr->CC4yRegs1Ptr->TC, (uint32_t)CCU4_CC4_TC_TRPSW_Msk," + NL + "      (uint32_t)CCU4_CC4_TC_TRPSW_Pos, HandlePtr->kTrapExitControl);" + NL + "" + NL + "  WR_REG(HandlePtr->CC4yRegs1Ptr->TC, (uint32_t)CCU4_CC4_TC_TRAPE_Msk,\\" + NL + "\t  (uint32_t)CCU4_CC4_TC_TRAPE_Pos, HandlePtr->kTrapEnable);" + NL + "  " + NL + "  WR_REG(HandlePtr->CC4yRegs1Ptr->PSC, (uint32_t)CCU4_CC4_PSC_PSIV_Msk, " + NL + "      (uint32_t)CCU4_CC4_PSC_PSIV_Pos, HandlePtr->kCCUPrescalar);" + NL + "" + NL + "  HandlePtr->CC4yRegs1Ptr->PSL = HandlePtr->kPassiveLevel;" + NL + "" + NL + "  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)0x01 <<\t\\" + NL + "      ((uint32_t)4 * (uint32_t)HandlePtr->SecondSlice)) |\t\\" + NL + "      ((uint32_t)0x01 << (((uint32_t)4 * \\" + NL + "\t    (uint32_t)HandlePtr->SecondSlice) + (uint32_t)1)) |\\" + NL + "          (uint32_t)((uint32_t)0x01 << (((uint32_t)4 * \\" + NL + "\t\t    (uint32_t)HandlePtr->SecondSlice) + (uint32_t)2)));" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function sets the enable event bit for the event given in the argument." + NL + " */" + NL + "status_t PWMSP001_EnableEvent" + NL + "(" + NL + "    const PWMSP001_HandleType * HandlePtr," + NL + "    const PWMSP001_EventNameType Event" + NL + ")" + NL + "{" + NL + "  status_t Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)" + NL + "  {" + NL + "    Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "    {" + NL + "      SET_BIT(HandlePtr->CC4yRegs1Ptr->INTE,(uint8_t) Event);" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      SET_BIT(HandlePtr->CC4yRegsPtr->INTE,(uint8_t) Event);" + NL + "    }" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  return (Status);" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function clears the enable event bit for the event given in the argument." + NL + " */" + NL + "status_t PWMSP001_DisableEvent" + NL + "(" + NL + "    const PWMSP001_HandleType * HandlePtr," + NL + "    const PWMSP001_EventNameType Event" + NL + ")" + NL + "{" + NL + "  status_t Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)" + NL;
  protected final String TEXT_68 = "  {" + NL + "    Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "    {" + NL + "      CLR_BIT(HandlePtr->CC4yRegs1Ptr->INTE,(uint8_t) Event);" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      CLR_BIT(HandlePtr->CC4yRegsPtr->INTE,(uint8_t) Event);" + NL + "    }" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  return (Status);" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function clears the interrupt by software." + NL + " */" + NL + "status_t PWMSP001_ClearPendingEvent" + NL + "(" + NL + "    const PWMSP001_HandleType * HandlePtr," + NL + "    const PWMSP001_EventNameType Event" + NL + ")" + NL + "{" + NL + "  status_t Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)" + NL + "  {" + NL + "    Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "    {" + NL + "      SET_BIT(HandlePtr->CC4yRegs1Ptr->SWR,(uint8_t) Event);" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      SET_BIT(HandlePtr->CC4yRegsPtr->SWR, (uint8_t)Event);" + NL + "    }" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  return (Status);" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function sets the interrupt by software Interrupt pulse is generated" + NL + " * if source is enabled." + NL + " */" + NL + "status_t PWMSP001_SetPendingEvent" + NL + "(" + NL + "    const PWMSP001_HandleType * HandlePtr," + NL + "    const PWMSP001_EventNameType Event" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)" + NL + "  {" + NL + "    Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "    {" + NL + "      SET_BIT(HandlePtr->CC4yRegs1Ptr->SWS,(uint8_t)Event);" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      SET_BIT(HandlePtr->CC4yRegsPtr->SWS, (uint8_t)Event);" + NL + "    }" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  return (Status);" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function check whether given interrupt is set" + NL + " */" + NL + "status_t PWMSP001_GetPendingEvent" + NL + "(" + NL + "    const PWMSP001_HandleType * HandlePtr," + NL + "    const PWMSP001_EventNameType Event," + NL + "    uint8_t*EvtStatus" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "" + NL + "  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)" + NL + "  {" + NL + "    Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;" + NL + "    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)" + NL + "    {" + NL + "" + NL + "      if(RD_REG(HandlePtr->CC4yRegs1Ptr->INTS, ((uint32_t)0x01 <<(uint32_t)Event), (uint32_t)Event))" + NL + "\t  {" + NL + "\t      *EvtStatus = (uint8_t)SET;" + NL + "\t  }" + NL + "\t  else" + NL + "\t  {" + NL + "\t      *EvtStatus = (uint8_t)RESET;" + NL + "\t  }" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      if(RD_REG(HandlePtr->CC4yRegsPtr->INTS, ((uint32_t)0x01 << (uint32_t)Event),(uint32_t)Event))" + NL + "      {" + NL + "        *EvtStatus = (uint8_t)SET;" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        *EvtStatus = (uint8_t)RESET;" + NL + "      }" + NL + "      /* *EvtStatus = RD_REG(HandlePtr->CC4yRegsPtr->INTS, (0x01 << (uint8_t)Event),(uint8_t) Event)\\" + NL + "\t   ? (uint8_t)SET : (uint8_t)RESET;\t*/" + NL + "    }" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  return (Status);" + NL + "}" + NL + "" + NL + "/**" + NL + " * @endcond" + NL + " */" + NL + "/*CODE_BLOCK_END*/" + NL + NL + NL + NL + NL;
  protected final String TEXT_69 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String TempApps = null;
   String MyAppName = null;
   ArrayList<String> apps;
   String TempLowerApps = null; 
   boolean DBGApp = false;   
   apps=(ArrayList<String>)(app.getApps());
        for (int k = 0; k < apps.size(); k++) {
              TempApps = apps.get(k);
//            if(app.isAppInitProvider(apps.get(k)) == true) {
              MyAppName = TempApps.substring(TempApps.indexOf("/app/") + 5, TempApps.lastIndexOf("/"));
              TempLowerApps = MyAppName.toLowerCase();
              if (TempLowerApps.equalsIgnoreCase("dbg002")) {DBGApp = true;}   
//   }  
  } 
    stringBuffer.append(TEXT_2);
     if (!DBGApp) { 
    stringBuffer.append(TEXT_3);
     } 
    stringBuffer.append(TEXT_4);
     String AppBaseuri = "app/pwmsp001/"; 
     String appInst  = null; 
     String pinUri ;
     String portNo ;
     String pinNo ;
    stringBuffer.append(TEXT_5);
     int PDR_PD1 ;
     int PDR_PO ;
     int Pin ;
     int Is1xDevice = -1; 
    stringBuffer.append(TEXT_6);
     ArrayList<String> appsList = (ArrayList<String>)(app.getApps("app/pwmsp001/"));
for (String appIns : appsList ) {
    appInst = appIns.substring(appIns.lastIndexOf("/")+1);
    stringBuffer.append(TEXT_7);
    stringBuffer.append( appInst);
    stringBuffer.append(TEXT_8);
    stringBuffer.append( appInst);
    stringBuffer.append(TEXT_9);
    stringBuffer.append( appInst);
    stringBuffer.append(TEXT_10);
     if(app.getIntegerValue(AppBaseuri + appInst +"/pwmsp001_erwdirectoutputpadenable/0")==1)
     { 
     pinUri = app.getMappedUri(AppBaseuri + appInst +"/pin_directoutput"); 
     if ((pinUri != null) && (pinUri.trim() != "")) 
     { 
     portNo = pinUri.substring(pinUri.indexOf("port/p/")+7,pinUri.indexOf("/pad/")); 
     pinNo = pinUri.substring(pinUri.indexOf("/pad/")+5,pinUri.length()); 
     PDR_PD1 = app.getIntegerValue(AppBaseuri + appInst +"/pin_directoutput/pdr_pd"); 
     PDR_PO = app.getIntegerValue(AppBaseuri + appInst +"/pwmsp001_erwdirectoutputpadchar/1");
     Pin = Integer.parseInt(pinNo);
    stringBuffer.append(TEXT_11);
     Is1xDevice = ((app.getSoftwareId().substring(0,1).compareTo("1")==0)?1:0); 
     if(Is1xDevice==0) 
     { 
    stringBuffer.append(TEXT_12);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_13);
    stringBuffer.append(pinNo);
    stringBuffer.append(TEXT_14);
     if(Pin < 8) 
     { 
    stringBuffer.append(TEXT_15);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_16);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_17);
    stringBuffer.append(Pin);
    stringBuffer.append(TEXT_18);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_19);
    stringBuffer.append(PDR_PD1);
    stringBuffer.append(TEXT_20);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_21);
    stringBuffer.append(Pin);
    stringBuffer.append(TEXT_22);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_23);
    stringBuffer.append(Pin);
    stringBuffer.append(TEXT_24);
     } else { 
    stringBuffer.append(TEXT_25);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_26);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_27);
    stringBuffer.append(Pin);
    stringBuffer.append(TEXT_28);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_29);
    stringBuffer.append(PDR_PD1);
    stringBuffer.append(TEXT_30);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_31);
    stringBuffer.append(Pin);
    stringBuffer.append(TEXT_32);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_33);
    stringBuffer.append(Pin);
    stringBuffer.append(TEXT_34);
     } 
     } 
     if(Pin < 4) 
     { 
    stringBuffer.append(TEXT_35);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_36);
    stringBuffer.append(Pin);
    stringBuffer.append(TEXT_37);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_38);
    stringBuffer.append(PDR_PO);
    stringBuffer.append(TEXT_39);
    stringBuffer.append(Pin);
    stringBuffer.append(TEXT_40);
    stringBuffer.append(Pin);
    stringBuffer.append(TEXT_41);
     } else  if(Pin < 8){ 
    stringBuffer.append(TEXT_42);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_43);
    stringBuffer.append(Pin - 4);
    stringBuffer.append(TEXT_44);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_45);
    stringBuffer.append(PDR_PO);
    stringBuffer.append(TEXT_46);
    stringBuffer.append(Pin -4);
    stringBuffer.append(TEXT_47);
    stringBuffer.append(Pin -4 );
    stringBuffer.append(TEXT_48);
     } else  if(Pin < 12){ 
    stringBuffer.append(TEXT_49);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_50);
    stringBuffer.append(Pin - 8);
    stringBuffer.append(TEXT_51);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_52);
    stringBuffer.append(PDR_PO);
    stringBuffer.append(TEXT_53);
    stringBuffer.append(Pin -8);
    stringBuffer.append(TEXT_54);
    stringBuffer.append(Pin - 8 );
    stringBuffer.append(TEXT_55);
     } else { 
    stringBuffer.append(TEXT_56);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_57);
    stringBuffer.append(Pin - 12);
    stringBuffer.append(TEXT_58);
    stringBuffer.append(portNo);
    stringBuffer.append(TEXT_59);
    stringBuffer.append(PDR_PO);
    stringBuffer.append(TEXT_60);
    stringBuffer.append(Pin -12);
    stringBuffer.append(TEXT_61);
    stringBuffer.append(Pin - 12 );
    stringBuffer.append(TEXT_62);
     } 
     }else { 
    stringBuffer.append(TEXT_63);
    stringBuffer.append( appInst );
    stringBuffer.append(TEXT_64);
     } 
     } 
    }
    stringBuffer.append(TEXT_65);
    stringBuffer.append(TEXT_66);
    stringBuffer.append(TEXT_67);
    stringBuffer.append(TEXT_68);
    stringBuffer.append(TEXT_69);
    return stringBuffer.toString();
  }
}
